
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model logs
 * 
 */
export type logs = $Result.DefaultSelection<Prisma.$logsPayload>
/**
 * Model auth
 * 
 */
export type auth = $Result.DefaultSelection<Prisma.$authPayload>
/**
 * Model memory_usage
 * 
 */
export type memory_usage = $Result.DefaultSelection<Prisma.$memory_usagePayload>
/**
 * Model system_metrics
 * 
 */
export type system_metrics = $Result.DefaultSelection<Prisma.$system_metricsPayload>
/**
 * Model diskmetric
 * 
 */
export type diskmetric = $Result.DefaultSelection<Prisma.$diskmetricPayload>
/**
 * Model notes
 * 
 */
export type notes = $Result.DefaultSelection<Prisma.$notesPayload>
/**
 * Model devices
 * 
 */
export type devices = $Result.DefaultSelection<Prisma.$devicesPayload>
/**
 * Model DeviceUser
 * 
 */
export type DeviceUser = $Result.DefaultSelection<Prisma.$DeviceUserPayload>
/**
 * Model Command
 * 
 */
export type Command = $Result.DefaultSelection<Prisma.$CommandPayload>
/**
 * Model Rule
 * 
 */
export type Rule = $Result.DefaultSelection<Prisma.$RulePayload>
/**
 * Model RuleGroup
 * 
 */
export type RuleGroup = $Result.DefaultSelection<Prisma.$RuleGroupPayload>
/**
 * Model CommandMatch
 * 
 */
export type CommandMatch = $Result.DefaultSelection<Prisma.$CommandMatchPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model UserEmailTemplate
 * 
 */
export type UserEmailTemplate = $Result.DefaultSelection<Prisma.$UserEmailTemplatePayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationRead
 * 
 */
export type NotificationRead = $Result.DefaultSelection<Prisma.$NotificationReadPayload>
/**
 * Model SavedQuery
 * 
 */
export type SavedQuery = $Result.DefaultSelection<Prisma.$SavedQueryPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model TicketAttachment
 * 
 */
export type TicketAttachment = $Result.DefaultSelection<Prisma.$TicketAttachmentPayload>
/**
 * Model AlertCondition
 * 
 */
export type AlertCondition = $Result.DefaultSelection<Prisma.$AlertConditionPayload>
/**
 * Model AlertEvent
 * 
 */
export type AlertEvent = $Result.DefaultSelection<Prisma.$AlertEventPayload>
/**
 * Model LibraryEntry
 * 
 */
export type LibraryEntry = $Result.DefaultSelection<Prisma.$LibraryEntryPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model FeedbackRecipient
 * 
 */
export type FeedbackRecipient = $Result.DefaultSelection<Prisma.$FeedbackRecipientPayload>
/**
 * Model PagePermission
 * 
 */
export type PagePermission = $Result.DefaultSelection<Prisma.$PagePermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserPermission
 * 
 */
export type UserPermission = $Result.DefaultSelection<Prisma.$UserPermissionPayload>
/**
 * Model pages
 * 
 */
export type pages = $Result.DefaultSelection<Prisma.$pagesPayload>
/**
 * Model ProjectType
 * 
 */
export type ProjectType = $Result.DefaultSelection<Prisma.$ProjectTypePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ModelEntry
 * 
 */
export type ModelEntry = $Result.DefaultSelection<Prisma.$ModelEntryPayload>
/**
 * Model ProjectAssignment
 * 
 */
export type ProjectAssignment = $Result.DefaultSelection<Prisma.$ProjectAssignmentPayload>
/**
 * Model SambaLog
 * 
 */
export type SambaLog = $Result.DefaultSelection<Prisma.$SambaLogPayload>
/**
 * Model location
 * 
 */
export type location = $Result.DefaultSelection<Prisma.$locationPayload>
/**
 * Model ldapuser
 * 
 */
export type ldapuser = $Result.DefaultSelection<Prisma.$ldapuserPayload>
/**
 * Model DriveFolder
 * 
 */
export type DriveFolder = $Result.DefaultSelection<Prisma.$DriveFolderPayload>
/**
 * Model DriveFile
 * 
 */
export type DriveFile = $Result.DefaultSelection<Prisma.$DriveFilePayload>
/**
 * Model DriveFilePermission
 * 
 */
export type DriveFilePermission = $Result.DefaultSelection<Prisma.$DriveFilePermissionPayload>
/**
 * Model JobTitle
 * 
 */
export type JobTitle = $Result.DefaultSelection<Prisma.$JobTitlePayload>
/**
 * Model UserActivity
 * 
 */
export type UserActivity = $Result.DefaultSelection<Prisma.$UserActivityPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamLeader
 * 
 */
export type TeamLeader = $Result.DefaultSelection<Prisma.$TeamLeaderPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model TeamLocation
 * 
 */
export type TeamLocation = $Result.DefaultSelection<Prisma.$TeamLocationPayload>
/**
 * Model AuditWorkflow
 * 
 */
export type AuditWorkflow = $Result.DefaultSelection<Prisma.$AuditWorkflowPayload>
/**
 * Model AuditStep
 * 
 */
export type AuditStep = $Result.DefaultSelection<Prisma.$AuditStepPayload>
/**
 * Model StepLog
 * 
 */
export type StepLog = $Result.DefaultSelection<Prisma.$StepLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StepStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type StepStatus = (typeof StepStatus)[keyof typeof StepStatus]

}

export type StepStatus = $Enums.StepStatus

export const StepStatus: typeof $Enums.StepStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Logs
 * const logs = await prisma.logs.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Logs
   * const logs = await prisma.logs.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.logs`: Exposes CRUD operations for the **logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auth`: Exposes CRUD operations for the **auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auths
    * const auths = await prisma.auth.findMany()
    * ```
    */
  get auth(): Prisma.authDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memory_usage`: Exposes CRUD operations for the **memory_usage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memory_usages
    * const memory_usages = await prisma.memory_usage.findMany()
    * ```
    */
  get memory_usage(): Prisma.memory_usageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.system_metrics`: Exposes CRUD operations for the **system_metrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more System_metrics
    * const system_metrics = await prisma.system_metrics.findMany()
    * ```
    */
  get system_metrics(): Prisma.system_metricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diskmetric`: Exposes CRUD operations for the **diskmetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diskmetrics
    * const diskmetrics = await prisma.diskmetric.findMany()
    * ```
    */
  get diskmetric(): Prisma.diskmetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.devices`: Exposes CRUD operations for the **devices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.devices.findMany()
    * ```
    */
  get devices(): Prisma.devicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceUser`: Exposes CRUD operations for the **DeviceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceUsers
    * const deviceUsers = await prisma.deviceUser.findMany()
    * ```
    */
  get deviceUser(): Prisma.DeviceUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.command`: Exposes CRUD operations for the **Command** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commands
    * const commands = await prisma.command.findMany()
    * ```
    */
  get command(): Prisma.CommandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rule`: Exposes CRUD operations for the **Rule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rules
    * const rules = await prisma.rule.findMany()
    * ```
    */
  get rule(): Prisma.RuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ruleGroup`: Exposes CRUD operations for the **RuleGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RuleGroups
    * const ruleGroups = await prisma.ruleGroup.findMany()
    * ```
    */
  get ruleGroup(): Prisma.RuleGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commandMatch`: Exposes CRUD operations for the **CommandMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandMatches
    * const commandMatches = await prisma.commandMatch.findMany()
    * ```
    */
  get commandMatch(): Prisma.CommandMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userEmailTemplate`: Exposes CRUD operations for the **UserEmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEmailTemplates
    * const userEmailTemplates = await prisma.userEmailTemplate.findMany()
    * ```
    */
  get userEmailTemplate(): Prisma.UserEmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationRead`: Exposes CRUD operations for the **NotificationRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationReads
    * const notificationReads = await prisma.notificationRead.findMany()
    * ```
    */
  get notificationRead(): Prisma.NotificationReadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedQuery`: Exposes CRUD operations for the **SavedQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedQueries
    * const savedQueries = await prisma.savedQuery.findMany()
    * ```
    */
  get savedQuery(): Prisma.SavedQueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketAttachment`: Exposes CRUD operations for the **TicketAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAttachments
    * const ticketAttachments = await prisma.ticketAttachment.findMany()
    * ```
    */
  get ticketAttachment(): Prisma.TicketAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertCondition`: Exposes CRUD operations for the **AlertCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertConditions
    * const alertConditions = await prisma.alertCondition.findMany()
    * ```
    */
  get alertCondition(): Prisma.AlertConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertEvent`: Exposes CRUD operations for the **AlertEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertEvents
    * const alertEvents = await prisma.alertEvent.findMany()
    * ```
    */
  get alertEvent(): Prisma.AlertEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryEntry`: Exposes CRUD operations for the **LibraryEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryEntries
    * const libraryEntries = await prisma.libraryEntry.findMany()
    * ```
    */
  get libraryEntry(): Prisma.LibraryEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedbackRecipient`: Exposes CRUD operations for the **FeedbackRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackRecipients
    * const feedbackRecipients = await prisma.feedbackRecipient.findMany()
    * ```
    */
  get feedbackRecipient(): Prisma.FeedbackRecipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagePermission`: Exposes CRUD operations for the **PagePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PagePermissions
    * const pagePermissions = await prisma.pagePermission.findMany()
    * ```
    */
  get pagePermission(): Prisma.PagePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPermission`: Exposes CRUD operations for the **UserPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPermissions
    * const userPermissions = await prisma.userPermission.findMany()
    * ```
    */
  get userPermission(): Prisma.UserPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pages`: Exposes CRUD operations for the **pages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.pages.findMany()
    * ```
    */
  get pages(): Prisma.pagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectType`: Exposes CRUD operations for the **ProjectType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTypes
    * const projectTypes = await prisma.projectType.findMany()
    * ```
    */
  get projectType(): Prisma.ProjectTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelEntry`: Exposes CRUD operations for the **ModelEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelEntries
    * const modelEntries = await prisma.modelEntry.findMany()
    * ```
    */
  get modelEntry(): Prisma.ModelEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectAssignment`: Exposes CRUD operations for the **ProjectAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectAssignments
    * const projectAssignments = await prisma.projectAssignment.findMany()
    * ```
    */
  get projectAssignment(): Prisma.ProjectAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sambaLog`: Exposes CRUD operations for the **SambaLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SambaLogs
    * const sambaLogs = await prisma.sambaLog.findMany()
    * ```
    */
  get sambaLog(): Prisma.SambaLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ldapuser`: Exposes CRUD operations for the **ldapuser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ldapusers
    * const ldapusers = await prisma.ldapuser.findMany()
    * ```
    */
  get ldapuser(): Prisma.ldapuserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driveFolder`: Exposes CRUD operations for the **DriveFolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriveFolders
    * const driveFolders = await prisma.driveFolder.findMany()
    * ```
    */
  get driveFolder(): Prisma.DriveFolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driveFile`: Exposes CRUD operations for the **DriveFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriveFiles
    * const driveFiles = await prisma.driveFile.findMany()
    * ```
    */
  get driveFile(): Prisma.DriveFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driveFilePermission`: Exposes CRUD operations for the **DriveFilePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriveFilePermissions
    * const driveFilePermissions = await prisma.driveFilePermission.findMany()
    * ```
    */
  get driveFilePermission(): Prisma.DriveFilePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobTitle`: Exposes CRUD operations for the **JobTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobTitles
    * const jobTitles = await prisma.jobTitle.findMany()
    * ```
    */
  get jobTitle(): Prisma.JobTitleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivity`: Exposes CRUD operations for the **UserActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivities
    * const userActivities = await prisma.userActivity.findMany()
    * ```
    */
  get userActivity(): Prisma.UserActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamLeader`: Exposes CRUD operations for the **TeamLeader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamLeaders
    * const teamLeaders = await prisma.teamLeader.findMany()
    * ```
    */
  get teamLeader(): Prisma.TeamLeaderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamLocation`: Exposes CRUD operations for the **TeamLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamLocations
    * const teamLocations = await prisma.teamLocation.findMany()
    * ```
    */
  get teamLocation(): Prisma.TeamLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditWorkflow`: Exposes CRUD operations for the **AuditWorkflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditWorkflows
    * const auditWorkflows = await prisma.auditWorkflow.findMany()
    * ```
    */
  get auditWorkflow(): Prisma.AuditWorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditStep`: Exposes CRUD operations for the **AuditStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditSteps
    * const auditSteps = await prisma.auditStep.findMany()
    * ```
    */
  get auditStep(): Prisma.AuditStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stepLog`: Exposes CRUD operations for the **StepLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StepLogs
    * const stepLogs = await prisma.stepLog.findMany()
    * ```
    */
  get stepLog(): Prisma.StepLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    logs: 'logs',
    auth: 'auth',
    memory_usage: 'memory_usage',
    system_metrics: 'system_metrics',
    diskmetric: 'diskmetric',
    notes: 'notes',
    devices: 'devices',
    DeviceUser: 'DeviceUser',
    Command: 'Command',
    Rule: 'Rule',
    RuleGroup: 'RuleGroup',
    CommandMatch: 'CommandMatch',
    ActivityLog: 'ActivityLog',
    EmailTemplate: 'EmailTemplate',
    User: 'User',
    Group: 'Group',
    GroupMember: 'GroupMember',
    Message: 'Message',
    UserEmailTemplate: 'UserEmailTemplate',
    Roles: 'Roles',
    Notification: 'Notification',
    NotificationRead: 'NotificationRead',
    SavedQuery: 'SavedQuery',
    TicketComment: 'TicketComment',
    SupportTicket: 'SupportTicket',
    TicketAttachment: 'TicketAttachment',
    AlertCondition: 'AlertCondition',
    AlertEvent: 'AlertEvent',
    LibraryEntry: 'LibraryEntry',
    Feedback: 'Feedback',
    FeedbackRecipient: 'FeedbackRecipient',
    PagePermission: 'PagePermission',
    RolePermission: 'RolePermission',
    UserPermission: 'UserPermission',
    pages: 'pages',
    ProjectType: 'ProjectType',
    Project: 'Project',
    ModelEntry: 'ModelEntry',
    ProjectAssignment: 'ProjectAssignment',
    SambaLog: 'SambaLog',
    location: 'location',
    ldapuser: 'ldapuser',
    DriveFolder: 'DriveFolder',
    DriveFile: 'DriveFile',
    DriveFilePermission: 'DriveFilePermission',
    JobTitle: 'JobTitle',
    UserActivity: 'UserActivity',
    Team: 'Team',
    TeamLeader: 'TeamLeader',
    TeamMember: 'TeamMember',
    TeamLocation: 'TeamLocation',
    AuditWorkflow: 'AuditWorkflow',
    AuditStep: 'AuditStep',
    StepLog: 'StepLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "logs" | "auth" | "memory_usage" | "system_metrics" | "diskmetric" | "notes" | "devices" | "deviceUser" | "command" | "rule" | "ruleGroup" | "commandMatch" | "activityLog" | "emailTemplate" | "user" | "group" | "groupMember" | "message" | "userEmailTemplate" | "roles" | "notification" | "notificationRead" | "savedQuery" | "ticketComment" | "supportTicket" | "ticketAttachment" | "alertCondition" | "alertEvent" | "libraryEntry" | "feedback" | "feedbackRecipient" | "pagePermission" | "rolePermission" | "userPermission" | "pages" | "projectType" | "project" | "modelEntry" | "projectAssignment" | "sambaLog" | "location" | "ldapuser" | "driveFolder" | "driveFile" | "driveFilePermission" | "jobTitle" | "userActivity" | "team" | "teamLeader" | "teamMember" | "teamLocation" | "auditWorkflow" | "auditStep" | "stepLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      logs: {
        payload: Prisma.$logsPayload<ExtArgs>
        fields: Prisma.logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          findFirst: {
            args: Prisma.logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          findMany: {
            args: Prisma.logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>[]
          }
          create: {
            args: Prisma.logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          createMany: {
            args: Prisma.logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>[]
          }
          delete: {
            args: Prisma.logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          update: {
            args: Prisma.logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          deleteMany: {
            args: Prisma.logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>[]
          }
          upsert: {
            args: Prisma.logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.logsCountArgs<ExtArgs>
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      auth: {
        payload: Prisma.$authPayload<ExtArgs>
        fields: Prisma.authFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>
          }
          findFirst: {
            args: Prisma.authFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>
          }
          findMany: {
            args: Prisma.authFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>[]
          }
          create: {
            args: Prisma.authCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>
          }
          createMany: {
            args: Prisma.authCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.authCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>[]
          }
          delete: {
            args: Prisma.authDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>
          }
          update: {
            args: Prisma.authUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>
          }
          deleteMany: {
            args: Prisma.authDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.authUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.authUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>[]
          }
          upsert: {
            args: Prisma.authUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authPayload>
          }
          aggregate: {
            args: Prisma.AuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth>
          }
          groupBy: {
            args: Prisma.authGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.authCountArgs<ExtArgs>
            result: $Utils.Optional<AuthCountAggregateOutputType> | number
          }
        }
      }
      memory_usage: {
        payload: Prisma.$memory_usagePayload<ExtArgs>
        fields: Prisma.memory_usageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.memory_usageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.memory_usageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>
          }
          findFirst: {
            args: Prisma.memory_usageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.memory_usageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>
          }
          findMany: {
            args: Prisma.memory_usageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>[]
          }
          create: {
            args: Prisma.memory_usageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>
          }
          createMany: {
            args: Prisma.memory_usageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.memory_usageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>[]
          }
          delete: {
            args: Prisma.memory_usageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>
          }
          update: {
            args: Prisma.memory_usageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>
          }
          deleteMany: {
            args: Prisma.memory_usageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.memory_usageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.memory_usageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>[]
          }
          upsert: {
            args: Prisma.memory_usageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memory_usagePayload>
          }
          aggregate: {
            args: Prisma.Memory_usageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemory_usage>
          }
          groupBy: {
            args: Prisma.memory_usageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Memory_usageGroupByOutputType>[]
          }
          count: {
            args: Prisma.memory_usageCountArgs<ExtArgs>
            result: $Utils.Optional<Memory_usageCountAggregateOutputType> | number
          }
        }
      }
      system_metrics: {
        payload: Prisma.$system_metricsPayload<ExtArgs>
        fields: Prisma.system_metricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.system_metricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.system_metricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>
          }
          findFirst: {
            args: Prisma.system_metricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.system_metricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>
          }
          findMany: {
            args: Prisma.system_metricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>[]
          }
          create: {
            args: Prisma.system_metricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>
          }
          createMany: {
            args: Prisma.system_metricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.system_metricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>[]
          }
          delete: {
            args: Prisma.system_metricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>
          }
          update: {
            args: Prisma.system_metricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>
          }
          deleteMany: {
            args: Prisma.system_metricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.system_metricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.system_metricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>[]
          }
          upsert: {
            args: Prisma.system_metricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_metricsPayload>
          }
          aggregate: {
            args: Prisma.System_metricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystem_metrics>
          }
          groupBy: {
            args: Prisma.system_metricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<System_metricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.system_metricsCountArgs<ExtArgs>
            result: $Utils.Optional<System_metricsCountAggregateOutputType> | number
          }
        }
      }
      diskmetric: {
        payload: Prisma.$diskmetricPayload<ExtArgs>
        fields: Prisma.diskmetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diskmetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diskmetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>
          }
          findFirst: {
            args: Prisma.diskmetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diskmetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>
          }
          findMany: {
            args: Prisma.diskmetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>[]
          }
          create: {
            args: Prisma.diskmetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>
          }
          createMany: {
            args: Prisma.diskmetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.diskmetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>[]
          }
          delete: {
            args: Prisma.diskmetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>
          }
          update: {
            args: Prisma.diskmetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>
          }
          deleteMany: {
            args: Prisma.diskmetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.diskmetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.diskmetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>[]
          }
          upsert: {
            args: Prisma.diskmetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diskmetricPayload>
          }
          aggregate: {
            args: Prisma.DiskmetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiskmetric>
          }
          groupBy: {
            args: Prisma.diskmetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiskmetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.diskmetricCountArgs<ExtArgs>
            result: $Utils.Optional<DiskmetricCountAggregateOutputType> | number
          }
        }
      }
      notes: {
        payload: Prisma.$notesPayload<ExtArgs>
        fields: Prisma.notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findFirst: {
            args: Prisma.notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findMany: {
            args: Prisma.notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          create: {
            args: Prisma.notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          createMany: {
            args: Prisma.notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          delete: {
            args: Prisma.notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          update: {
            args: Prisma.notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          deleteMany: {
            args: Prisma.notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          upsert: {
            args: Prisma.notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      devices: {
        payload: Prisma.$devicesPayload<ExtArgs>
        fields: Prisma.devicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.devicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.devicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>
          }
          findFirst: {
            args: Prisma.devicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.devicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>
          }
          findMany: {
            args: Prisma.devicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>[]
          }
          create: {
            args: Prisma.devicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>
          }
          createMany: {
            args: Prisma.devicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.devicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>[]
          }
          delete: {
            args: Prisma.devicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>
          }
          update: {
            args: Prisma.devicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>
          }
          deleteMany: {
            args: Prisma.devicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.devicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.devicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>[]
          }
          upsert: {
            args: Prisma.devicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicesPayload>
          }
          aggregate: {
            args: Prisma.DevicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevices>
          }
          groupBy: {
            args: Prisma.devicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DevicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.devicesCountArgs<ExtArgs>
            result: $Utils.Optional<DevicesCountAggregateOutputType> | number
          }
        }
      }
      DeviceUser: {
        payload: Prisma.$DeviceUserPayload<ExtArgs>
        fields: Prisma.DeviceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          findFirst: {
            args: Prisma.DeviceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          findMany: {
            args: Prisma.DeviceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>[]
          }
          create: {
            args: Prisma.DeviceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          createMany: {
            args: Prisma.DeviceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>[]
          }
          delete: {
            args: Prisma.DeviceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          update: {
            args: Prisma.DeviceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          deleteMany: {
            args: Prisma.DeviceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>[]
          }
          upsert: {
            args: Prisma.DeviceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          aggregate: {
            args: Prisma.DeviceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceUser>
          }
          groupBy: {
            args: Prisma.DeviceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceUserCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceUserCountAggregateOutputType> | number
          }
        }
      }
      Command: {
        payload: Prisma.$CommandPayload<ExtArgs>
        fields: Prisma.CommandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findFirst: {
            args: Prisma.CommandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findMany: {
            args: Prisma.CommandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          create: {
            args: Prisma.CommandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          createMany: {
            args: Prisma.CommandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          delete: {
            args: Prisma.CommandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          update: {
            args: Prisma.CommandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          deleteMany: {
            args: Prisma.CommandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          upsert: {
            args: Prisma.CommandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          aggregate: {
            args: Prisma.CommandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommand>
          }
          groupBy: {
            args: Prisma.CommandGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandCountArgs<ExtArgs>
            result: $Utils.Optional<CommandCountAggregateOutputType> | number
          }
        }
      }
      Rule: {
        payload: Prisma.$RulePayload<ExtArgs>
        fields: Prisma.RuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>
          }
          findFirst: {
            args: Prisma.RuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>
          }
          findMany: {
            args: Prisma.RuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>[]
          }
          create: {
            args: Prisma.RuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>
          }
          createMany: {
            args: Prisma.RuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>[]
          }
          delete: {
            args: Prisma.RuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>
          }
          update: {
            args: Prisma.RuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>
          }
          deleteMany: {
            args: Prisma.RuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>[]
          }
          upsert: {
            args: Prisma.RuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RulePayload>
          }
          aggregate: {
            args: Prisma.RuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRule>
          }
          groupBy: {
            args: Prisma.RuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RuleCountArgs<ExtArgs>
            result: $Utils.Optional<RuleCountAggregateOutputType> | number
          }
        }
      }
      RuleGroup: {
        payload: Prisma.$RuleGroupPayload<ExtArgs>
        fields: Prisma.RuleGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RuleGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RuleGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>
          }
          findFirst: {
            args: Prisma.RuleGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RuleGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>
          }
          findMany: {
            args: Prisma.RuleGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>[]
          }
          create: {
            args: Prisma.RuleGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>
          }
          createMany: {
            args: Prisma.RuleGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RuleGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>[]
          }
          delete: {
            args: Prisma.RuleGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>
          }
          update: {
            args: Prisma.RuleGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>
          }
          deleteMany: {
            args: Prisma.RuleGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RuleGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RuleGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>[]
          }
          upsert: {
            args: Prisma.RuleGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RuleGroupPayload>
          }
          aggregate: {
            args: Prisma.RuleGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRuleGroup>
          }
          groupBy: {
            args: Prisma.RuleGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<RuleGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.RuleGroupCountArgs<ExtArgs>
            result: $Utils.Optional<RuleGroupCountAggregateOutputType> | number
          }
        }
      }
      CommandMatch: {
        payload: Prisma.$CommandMatchPayload<ExtArgs>
        fields: Prisma.CommandMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>
          }
          findFirst: {
            args: Prisma.CommandMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>
          }
          findMany: {
            args: Prisma.CommandMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>[]
          }
          create: {
            args: Prisma.CommandMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>
          }
          createMany: {
            args: Prisma.CommandMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>[]
          }
          delete: {
            args: Prisma.CommandMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>
          }
          update: {
            args: Prisma.CommandMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>
          }
          deleteMany: {
            args: Prisma.CommandMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommandMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>[]
          }
          upsert: {
            args: Prisma.CommandMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandMatchPayload>
          }
          aggregate: {
            args: Prisma.CommandMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommandMatch>
          }
          groupBy: {
            args: Prisma.CommandMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandMatchCountArgs<ExtArgs>
            result: $Utils.Optional<CommandMatchCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      UserEmailTemplate: {
        payload: Prisma.$UserEmailTemplatePayload<ExtArgs>
        fields: Prisma.UserEmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.UserEmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>
          }
          findMany: {
            args: Prisma.UserEmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>[]
          }
          create: {
            args: Prisma.UserEmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>
          }
          createMany: {
            args: Prisma.UserEmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.UserEmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>
          }
          update: {
            args: Prisma.UserEmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.UserEmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserEmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.UserEmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.UserEmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEmailTemplate>
          }
          groupBy: {
            args: Prisma.UserEmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<UserEmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationRead: {
        payload: Prisma.$NotificationReadPayload<ExtArgs>
        fields: Prisma.NotificationReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          findFirst: {
            args: Prisma.NotificationReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          findMany: {
            args: Prisma.NotificationReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>[]
          }
          create: {
            args: Prisma.NotificationReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          createMany: {
            args: Prisma.NotificationReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>[]
          }
          delete: {
            args: Prisma.NotificationReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          update: {
            args: Prisma.NotificationReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          deleteMany: {
            args: Prisma.NotificationReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>[]
          }
          upsert: {
            args: Prisma.NotificationReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          aggregate: {
            args: Prisma.NotificationReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRead>
          }
          groupBy: {
            args: Prisma.NotificationReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationReadCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationReadCountAggregateOutputType> | number
          }
        }
      }
      SavedQuery: {
        payload: Prisma.$SavedQueryPayload<ExtArgs>
        fields: Prisma.SavedQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>
          }
          findFirst: {
            args: Prisma.SavedQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>
          }
          findMany: {
            args: Prisma.SavedQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>[]
          }
          create: {
            args: Prisma.SavedQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>
          }
          createMany: {
            args: Prisma.SavedQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>[]
          }
          delete: {
            args: Prisma.SavedQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>
          }
          update: {
            args: Prisma.SavedQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>
          }
          deleteMany: {
            args: Prisma.SavedQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedQueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>[]
          }
          upsert: {
            args: Prisma.SavedQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedQueryPayload>
          }
          aggregate: {
            args: Prisma.SavedQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedQuery>
          }
          groupBy: {
            args: Prisma.SavedQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SavedQueryCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      TicketAttachment: {
        payload: Prisma.$TicketAttachmentPayload<ExtArgs>
        fields: Prisma.TicketAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findMany: {
            args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          create: {
            args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          createMany: {
            args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          update: {
            args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAttachment>
          }
          groupBy: {
            args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentCountAggregateOutputType> | number
          }
        }
      }
      AlertCondition: {
        payload: Prisma.$AlertConditionPayload<ExtArgs>
        fields: Prisma.AlertConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>
          }
          findFirst: {
            args: Prisma.AlertConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>
          }
          findMany: {
            args: Prisma.AlertConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>[]
          }
          create: {
            args: Prisma.AlertConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>
          }
          createMany: {
            args: Prisma.AlertConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>[]
          }
          delete: {
            args: Prisma.AlertConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>
          }
          update: {
            args: Prisma.AlertConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>
          }
          deleteMany: {
            args: Prisma.AlertConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>[]
          }
          upsert: {
            args: Prisma.AlertConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertConditionPayload>
          }
          aggregate: {
            args: Prisma.AlertConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertCondition>
          }
          groupBy: {
            args: Prisma.AlertConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertConditionCountArgs<ExtArgs>
            result: $Utils.Optional<AlertConditionCountAggregateOutputType> | number
          }
        }
      }
      AlertEvent: {
        payload: Prisma.$AlertEventPayload<ExtArgs>
        fields: Prisma.AlertEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          findFirst: {
            args: Prisma.AlertEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          findMany: {
            args: Prisma.AlertEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          create: {
            args: Prisma.AlertEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          createMany: {
            args: Prisma.AlertEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          delete: {
            args: Prisma.AlertEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          update: {
            args: Prisma.AlertEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          deleteMany: {
            args: Prisma.AlertEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          upsert: {
            args: Prisma.AlertEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          aggregate: {
            args: Prisma.AlertEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertEvent>
          }
          groupBy: {
            args: Prisma.AlertEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertEventCountArgs<ExtArgs>
            result: $Utils.Optional<AlertEventCountAggregateOutputType> | number
          }
        }
      }
      LibraryEntry: {
        payload: Prisma.$LibraryEntryPayload<ExtArgs>
        fields: Prisma.LibraryEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          findFirst: {
            args: Prisma.LibraryEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          findMany: {
            args: Prisma.LibraryEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>[]
          }
          create: {
            args: Prisma.LibraryEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          createMany: {
            args: Prisma.LibraryEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>[]
          }
          delete: {
            args: Prisma.LibraryEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          update: {
            args: Prisma.LibraryEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          deleteMany: {
            args: Prisma.LibraryEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LibraryEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>[]
          }
          upsert: {
            args: Prisma.LibraryEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryEntryPayload>
          }
          aggregate: {
            args: Prisma.LibraryEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibraryEntry>
          }
          groupBy: {
            args: Prisma.LibraryEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryEntryCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      FeedbackRecipient: {
        payload: Prisma.$FeedbackRecipientPayload<ExtArgs>
        fields: Prisma.FeedbackRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>
          }
          findFirst: {
            args: Prisma.FeedbackRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>
          }
          findMany: {
            args: Prisma.FeedbackRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>[]
          }
          create: {
            args: Prisma.FeedbackRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>
          }
          createMany: {
            args: Prisma.FeedbackRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>[]
          }
          delete: {
            args: Prisma.FeedbackRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>
          }
          update: {
            args: Prisma.FeedbackRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackRecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRecipientPayload>
          }
          aggregate: {
            args: Prisma.FeedbackRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbackRecipient>
          }
          groupBy: {
            args: Prisma.FeedbackRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackRecipientCountAggregateOutputType> | number
          }
        }
      }
      PagePermission: {
        payload: Prisma.$PagePermissionPayload<ExtArgs>
        fields: Prisma.PagePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>
          }
          findFirst: {
            args: Prisma.PagePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>
          }
          findMany: {
            args: Prisma.PagePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>[]
          }
          create: {
            args: Prisma.PagePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>
          }
          createMany: {
            args: Prisma.PagePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>[]
          }
          delete: {
            args: Prisma.PagePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>
          }
          update: {
            args: Prisma.PagePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>
          }
          deleteMany: {
            args: Prisma.PagePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>[]
          }
          upsert: {
            args: Prisma.PagePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePermissionPayload>
          }
          aggregate: {
            args: Prisma.PagePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagePermission>
          }
          groupBy: {
            args: Prisma.PagePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PagePermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserPermission: {
        payload: Prisma.$UserPermissionPayload<ExtArgs>
        fields: Prisma.UserPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          findFirst: {
            args: Prisma.UserPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          findMany: {
            args: Prisma.UserPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          create: {
            args: Prisma.UserPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          createMany: {
            args: Prisma.UserPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          delete: {
            args: Prisma.UserPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          update: {
            args: Prisma.UserPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          deleteMany: {
            args: Prisma.UserPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          upsert: {
            args: Prisma.UserPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          aggregate: {
            args: Prisma.UserPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPermission>
          }
          groupBy: {
            args: Prisma.UserPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionCountAggregateOutputType> | number
          }
        }
      }
      pages: {
        payload: Prisma.$pagesPayload<ExtArgs>
        fields: Prisma.pagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          findFirst: {
            args: Prisma.pagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          findMany: {
            args: Prisma.pagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>[]
          }
          create: {
            args: Prisma.pagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          createMany: {
            args: Prisma.pagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>[]
          }
          delete: {
            args: Prisma.pagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          update: {
            args: Prisma.pagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          deleteMany: {
            args: Prisma.pagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>[]
          }
          upsert: {
            args: Prisma.pagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          aggregate: {
            args: Prisma.PagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePages>
          }
          groupBy: {
            args: Prisma.pagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagesCountArgs<ExtArgs>
            result: $Utils.Optional<PagesCountAggregateOutputType> | number
          }
        }
      }
      ProjectType: {
        payload: Prisma.$ProjectTypePayload<ExtArgs>
        fields: Prisma.ProjectTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          findFirst: {
            args: Prisma.ProjectTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          findMany: {
            args: Prisma.ProjectTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          create: {
            args: Prisma.ProjectTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          createMany: {
            args: Prisma.ProjectTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          delete: {
            args: Prisma.ProjectTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          update: {
            args: Prisma.ProjectTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          deleteMany: {
            args: Prisma.ProjectTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          upsert: {
            args: Prisma.ProjectTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          aggregate: {
            args: Prisma.ProjectTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectType>
          }
          groupBy: {
            args: Prisma.ProjectTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTypeCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ModelEntry: {
        payload: Prisma.$ModelEntryPayload<ExtArgs>
        fields: Prisma.ModelEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>
          }
          findFirst: {
            args: Prisma.ModelEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>
          }
          findMany: {
            args: Prisma.ModelEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>[]
          }
          create: {
            args: Prisma.ModelEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>
          }
          createMany: {
            args: Prisma.ModelEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>[]
          }
          delete: {
            args: Prisma.ModelEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>
          }
          update: {
            args: Prisma.ModelEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>
          }
          deleteMany: {
            args: Prisma.ModelEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>[]
          }
          upsert: {
            args: Prisma.ModelEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEntryPayload>
          }
          aggregate: {
            args: Prisma.ModelEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelEntry>
          }
          groupBy: {
            args: Prisma.ModelEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ModelEntryCountAggregateOutputType> | number
          }
        }
      }
      ProjectAssignment: {
        payload: Prisma.$ProjectAssignmentPayload<ExtArgs>
        fields: Prisma.ProjectAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ProjectAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>
          }
          findMany: {
            args: Prisma.ProjectAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>[]
          }
          create: {
            args: Prisma.ProjectAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>
          }
          createMany: {
            args: Prisma.ProjectAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ProjectAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>
          }
          update: {
            args: Prisma.ProjectAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ProjectAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ProjectAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ProjectAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectAssignment>
          }
          groupBy: {
            args: Prisma.ProjectAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectAssignmentCountAggregateOutputType> | number
          }
        }
      }
      SambaLog: {
        payload: Prisma.$SambaLogPayload<ExtArgs>
        fields: Prisma.SambaLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SambaLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SambaLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>
          }
          findFirst: {
            args: Prisma.SambaLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SambaLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>
          }
          findMany: {
            args: Prisma.SambaLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>[]
          }
          create: {
            args: Prisma.SambaLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>
          }
          createMany: {
            args: Prisma.SambaLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SambaLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>[]
          }
          delete: {
            args: Prisma.SambaLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>
          }
          update: {
            args: Prisma.SambaLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>
          }
          deleteMany: {
            args: Prisma.SambaLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SambaLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SambaLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>[]
          }
          upsert: {
            args: Prisma.SambaLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SambaLogPayload>
          }
          aggregate: {
            args: Prisma.SambaLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSambaLog>
          }
          groupBy: {
            args: Prisma.SambaLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SambaLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SambaLogCountArgs<ExtArgs>
            result: $Utils.Optional<SambaLogCountAggregateOutputType> | number
          }
        }
      }
      location: {
        payload: Prisma.$locationPayload<ExtArgs>
        fields: Prisma.locationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findFirst: {
            args: Prisma.locationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findMany: {
            args: Prisma.locationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          create: {
            args: Prisma.locationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          createMany: {
            args: Prisma.locationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.locationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          delete: {
            args: Prisma.locationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          update: {
            args: Prisma.locationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          deleteMany: {
            args: Prisma.locationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.locationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          upsert: {
            args: Prisma.locationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.locationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      ldapuser: {
        payload: Prisma.$ldapuserPayload<ExtArgs>
        fields: Prisma.ldapuserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ldapuserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ldapuserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>
          }
          findFirst: {
            args: Prisma.ldapuserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ldapuserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>
          }
          findMany: {
            args: Prisma.ldapuserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>[]
          }
          create: {
            args: Prisma.ldapuserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>
          }
          createMany: {
            args: Prisma.ldapuserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ldapuserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>[]
          }
          delete: {
            args: Prisma.ldapuserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>
          }
          update: {
            args: Prisma.ldapuserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>
          }
          deleteMany: {
            args: Prisma.ldapuserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ldapuserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ldapuserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>[]
          }
          upsert: {
            args: Prisma.ldapuserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ldapuserPayload>
          }
          aggregate: {
            args: Prisma.LdapuserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLdapuser>
          }
          groupBy: {
            args: Prisma.ldapuserGroupByArgs<ExtArgs>
            result: $Utils.Optional<LdapuserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ldapuserCountArgs<ExtArgs>
            result: $Utils.Optional<LdapuserCountAggregateOutputType> | number
          }
        }
      }
      DriveFolder: {
        payload: Prisma.$DriveFolderPayload<ExtArgs>
        fields: Prisma.DriveFolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriveFolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriveFolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>
          }
          findFirst: {
            args: Prisma.DriveFolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriveFolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>
          }
          findMany: {
            args: Prisma.DriveFolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>[]
          }
          create: {
            args: Prisma.DriveFolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>
          }
          createMany: {
            args: Prisma.DriveFolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriveFolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>[]
          }
          delete: {
            args: Prisma.DriveFolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>
          }
          update: {
            args: Prisma.DriveFolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>
          }
          deleteMany: {
            args: Prisma.DriveFolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriveFolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriveFolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>[]
          }
          upsert: {
            args: Prisma.DriveFolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFolderPayload>
          }
          aggregate: {
            args: Prisma.DriveFolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriveFolder>
          }
          groupBy: {
            args: Prisma.DriveFolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriveFolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriveFolderCountArgs<ExtArgs>
            result: $Utils.Optional<DriveFolderCountAggregateOutputType> | number
          }
        }
      }
      DriveFile: {
        payload: Prisma.$DriveFilePayload<ExtArgs>
        fields: Prisma.DriveFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriveFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriveFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>
          }
          findFirst: {
            args: Prisma.DriveFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriveFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>
          }
          findMany: {
            args: Prisma.DriveFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>[]
          }
          create: {
            args: Prisma.DriveFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>
          }
          createMany: {
            args: Prisma.DriveFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriveFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>[]
          }
          delete: {
            args: Prisma.DriveFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>
          }
          update: {
            args: Prisma.DriveFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>
          }
          deleteMany: {
            args: Prisma.DriveFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriveFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriveFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>[]
          }
          upsert: {
            args: Prisma.DriveFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePayload>
          }
          aggregate: {
            args: Prisma.DriveFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriveFile>
          }
          groupBy: {
            args: Prisma.DriveFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriveFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriveFileCountArgs<ExtArgs>
            result: $Utils.Optional<DriveFileCountAggregateOutputType> | number
          }
        }
      }
      DriveFilePermission: {
        payload: Prisma.$DriveFilePermissionPayload<ExtArgs>
        fields: Prisma.DriveFilePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriveFilePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriveFilePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>
          }
          findFirst: {
            args: Prisma.DriveFilePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriveFilePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>
          }
          findMany: {
            args: Prisma.DriveFilePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>[]
          }
          create: {
            args: Prisma.DriveFilePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>
          }
          createMany: {
            args: Prisma.DriveFilePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriveFilePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>[]
          }
          delete: {
            args: Prisma.DriveFilePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>
          }
          update: {
            args: Prisma.DriveFilePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>
          }
          deleteMany: {
            args: Prisma.DriveFilePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriveFilePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriveFilePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>[]
          }
          upsert: {
            args: Prisma.DriveFilePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriveFilePermissionPayload>
          }
          aggregate: {
            args: Prisma.DriveFilePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriveFilePermission>
          }
          groupBy: {
            args: Prisma.DriveFilePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriveFilePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriveFilePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<DriveFilePermissionCountAggregateOutputType> | number
          }
        }
      }
      JobTitle: {
        payload: Prisma.$JobTitlePayload<ExtArgs>
        fields: Prisma.JobTitleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobTitleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobTitleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          findFirst: {
            args: Prisma.JobTitleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobTitleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          findMany: {
            args: Prisma.JobTitleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>[]
          }
          create: {
            args: Prisma.JobTitleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          createMany: {
            args: Prisma.JobTitleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobTitleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>[]
          }
          delete: {
            args: Prisma.JobTitleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          update: {
            args: Prisma.JobTitleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          deleteMany: {
            args: Prisma.JobTitleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobTitleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobTitleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>[]
          }
          upsert: {
            args: Prisma.JobTitleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          aggregate: {
            args: Prisma.JobTitleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobTitle>
          }
          groupBy: {
            args: Prisma.JobTitleGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobTitleGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobTitleCountArgs<ExtArgs>
            result: $Utils.Optional<JobTitleCountAggregateOutputType> | number
          }
        }
      }
      UserActivity: {
        payload: Prisma.$UserActivityPayload<ExtArgs>
        fields: Prisma.UserActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findFirst: {
            args: Prisma.UserActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findMany: {
            args: Prisma.UserActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          create: {
            args: Prisma.UserActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          createMany: {
            args: Prisma.UserActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          delete: {
            args: Prisma.UserActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          update: {
            args: Prisma.UserActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          deleteMany: {
            args: Prisma.UserActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          upsert: {
            args: Prisma.UserActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          aggregate: {
            args: Prisma.UserActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivity>
          }
          groupBy: {
            args: Prisma.UserActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivityCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamLeader: {
        payload: Prisma.$TeamLeaderPayload<ExtArgs>
        fields: Prisma.TeamLeaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamLeaderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamLeaderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>
          }
          findFirst: {
            args: Prisma.TeamLeaderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamLeaderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>
          }
          findMany: {
            args: Prisma.TeamLeaderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>[]
          }
          create: {
            args: Prisma.TeamLeaderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>
          }
          createMany: {
            args: Prisma.TeamLeaderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamLeaderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>[]
          }
          delete: {
            args: Prisma.TeamLeaderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>
          }
          update: {
            args: Prisma.TeamLeaderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>
          }
          deleteMany: {
            args: Prisma.TeamLeaderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamLeaderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamLeaderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>[]
          }
          upsert: {
            args: Prisma.TeamLeaderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLeaderPayload>
          }
          aggregate: {
            args: Prisma.TeamLeaderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamLeader>
          }
          groupBy: {
            args: Prisma.TeamLeaderGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamLeaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamLeaderCountArgs<ExtArgs>
            result: $Utils.Optional<TeamLeaderCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      TeamLocation: {
        payload: Prisma.$TeamLocationPayload<ExtArgs>
        fields: Prisma.TeamLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>
          }
          findFirst: {
            args: Prisma.TeamLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>
          }
          findMany: {
            args: Prisma.TeamLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>[]
          }
          create: {
            args: Prisma.TeamLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>
          }
          createMany: {
            args: Prisma.TeamLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>[]
          }
          delete: {
            args: Prisma.TeamLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>
          }
          update: {
            args: Prisma.TeamLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>
          }
          deleteMany: {
            args: Prisma.TeamLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>[]
          }
          upsert: {
            args: Prisma.TeamLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamLocationPayload>
          }
          aggregate: {
            args: Prisma.TeamLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamLocation>
          }
          groupBy: {
            args: Prisma.TeamLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamLocationCountArgs<ExtArgs>
            result: $Utils.Optional<TeamLocationCountAggregateOutputType> | number
          }
        }
      }
      AuditWorkflow: {
        payload: Prisma.$AuditWorkflowPayload<ExtArgs>
        fields: Prisma.AuditWorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditWorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditWorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>
          }
          findFirst: {
            args: Prisma.AuditWorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditWorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>
          }
          findMany: {
            args: Prisma.AuditWorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>[]
          }
          create: {
            args: Prisma.AuditWorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>
          }
          createMany: {
            args: Prisma.AuditWorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditWorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>[]
          }
          delete: {
            args: Prisma.AuditWorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>
          }
          update: {
            args: Prisma.AuditWorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>
          }
          deleteMany: {
            args: Prisma.AuditWorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditWorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditWorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>[]
          }
          upsert: {
            args: Prisma.AuditWorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditWorkflowPayload>
          }
          aggregate: {
            args: Prisma.AuditWorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditWorkflow>
          }
          groupBy: {
            args: Prisma.AuditWorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditWorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditWorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<AuditWorkflowCountAggregateOutputType> | number
          }
        }
      }
      AuditStep: {
        payload: Prisma.$AuditStepPayload<ExtArgs>
        fields: Prisma.AuditStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>
          }
          findFirst: {
            args: Prisma.AuditStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>
          }
          findMany: {
            args: Prisma.AuditStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>[]
          }
          create: {
            args: Prisma.AuditStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>
          }
          createMany: {
            args: Prisma.AuditStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>[]
          }
          delete: {
            args: Prisma.AuditStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>
          }
          update: {
            args: Prisma.AuditStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>
          }
          deleteMany: {
            args: Prisma.AuditStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>[]
          }
          upsert: {
            args: Prisma.AuditStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStepPayload>
          }
          aggregate: {
            args: Prisma.AuditStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditStep>
          }
          groupBy: {
            args: Prisma.AuditStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditStepCountArgs<ExtArgs>
            result: $Utils.Optional<AuditStepCountAggregateOutputType> | number
          }
        }
      }
      StepLog: {
        payload: Prisma.$StepLogPayload<ExtArgs>
        fields: Prisma.StepLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StepLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StepLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>
          }
          findFirst: {
            args: Prisma.StepLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StepLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>
          }
          findMany: {
            args: Prisma.StepLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>[]
          }
          create: {
            args: Prisma.StepLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>
          }
          createMany: {
            args: Prisma.StepLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StepLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>[]
          }
          delete: {
            args: Prisma.StepLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>
          }
          update: {
            args: Prisma.StepLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>
          }
          deleteMany: {
            args: Prisma.StepLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StepLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StepLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>[]
          }
          upsert: {
            args: Prisma.StepLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepLogPayload>
          }
          aggregate: {
            args: Prisma.StepLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStepLog>
          }
          groupBy: {
            args: Prisma.StepLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StepLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StepLogCountArgs<ExtArgs>
            result: $Utils.Optional<StepLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    logs?: logsOmit
    auth?: authOmit
    memory_usage?: memory_usageOmit
    system_metrics?: system_metricsOmit
    diskmetric?: diskmetricOmit
    notes?: notesOmit
    devices?: devicesOmit
    deviceUser?: DeviceUserOmit
    command?: CommandOmit
    rule?: RuleOmit
    ruleGroup?: RuleGroupOmit
    commandMatch?: CommandMatchOmit
    activityLog?: ActivityLogOmit
    emailTemplate?: EmailTemplateOmit
    user?: UserOmit
    group?: GroupOmit
    groupMember?: GroupMemberOmit
    message?: MessageOmit
    userEmailTemplate?: UserEmailTemplateOmit
    roles?: RolesOmit
    notification?: NotificationOmit
    notificationRead?: NotificationReadOmit
    savedQuery?: SavedQueryOmit
    ticketComment?: TicketCommentOmit
    supportTicket?: SupportTicketOmit
    ticketAttachment?: TicketAttachmentOmit
    alertCondition?: AlertConditionOmit
    alertEvent?: AlertEventOmit
    libraryEntry?: LibraryEntryOmit
    feedback?: FeedbackOmit
    feedbackRecipient?: FeedbackRecipientOmit
    pagePermission?: PagePermissionOmit
    rolePermission?: RolePermissionOmit
    userPermission?: UserPermissionOmit
    pages?: pagesOmit
    projectType?: ProjectTypeOmit
    project?: ProjectOmit
    modelEntry?: ModelEntryOmit
    projectAssignment?: ProjectAssignmentOmit
    sambaLog?: SambaLogOmit
    location?: locationOmit
    ldapuser?: ldapuserOmit
    driveFolder?: DriveFolderOmit
    driveFile?: DriveFileOmit
    driveFilePermission?: DriveFilePermissionOmit
    jobTitle?: JobTitleOmit
    userActivity?: UserActivityOmit
    team?: TeamOmit
    teamLeader?: TeamLeaderOmit
    teamMember?: TeamMemberOmit
    teamLocation?: TeamLocationOmit
    auditWorkflow?: AuditWorkflowOmit
    auditStep?: AuditStepOmit
    stepLog?: StepLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DevicesCountOutputType
   */

  export type DevicesCountOutputType = {
    users: number
    SupportTicket: number
  }

  export type DevicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DevicesCountOutputTypeCountUsersArgs
    SupportTicket?: boolean | DevicesCountOutputTypeCountSupportTicketArgs
  }

  // Custom InputTypes
  /**
   * DevicesCountOutputType without action
   */
  export type DevicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicesCountOutputType
     */
    select?: DevicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DevicesCountOutputType without action
   */
  export type DevicesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceUserWhereInput
  }

  /**
   * DevicesCountOutputType without action
   */
  export type DevicesCountOutputTypeCountSupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type CommandCountOutputType
   */

  export type CommandCountOutputType = {
    matches: number
  }

  export type CommandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matches?: boolean | CommandCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * CommandCountOutputType without action
   */
  export type CommandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandCountOutputType
     */
    select?: CommandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandCountOutputType without action
   */
  export type CommandCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandMatchWhereInput
  }


  /**
   * Count Type RuleCountOutputType
   */

  export type RuleCountOutputType = {
    commands: number
    matches: number
  }

  export type RuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commands?: boolean | RuleCountOutputTypeCountCommandsArgs
    matches?: boolean | RuleCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * RuleCountOutputType without action
   */
  export type RuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleCountOutputType
     */
    select?: RuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RuleCountOutputType without action
   */
  export type RuleCountOutputTypeCountCommandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * RuleCountOutputType without action
   */
  export type RuleCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandMatchWhereInput
  }


  /**
   * Count Type RuleGroupCountOutputType
   */

  export type RuleGroupCountOutputType = {
    rules: number
  }

  export type RuleGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | RuleGroupCountOutputTypeCountRulesArgs
  }

  // Custom InputTypes
  /**
   * RuleGroupCountOutputType without action
   */
  export type RuleGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroupCountOutputType
     */
    select?: RuleGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RuleGroupCountOutputType without action
   */
  export type RuleGroupCountOutputTypeCountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RuleWhereInput
  }


  /**
   * Count Type CommandMatchCountOutputType
   */

  export type CommandMatchCountOutputType = {
    User: number
  }

  export type CommandMatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | CommandMatchCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * CommandMatchCountOutputType without action
   */
  export type CommandMatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatchCountOutputType
     */
    select?: CommandMatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandMatchCountOutputType without action
   */
  export type CommandMatchCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    AlertCondition: number
    Command: number
    Rule: number
    RuleGroup: number
    SavedQuery: number
    assignedUsers: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AlertCondition?: boolean | EmailTemplateCountOutputTypeCountAlertConditionArgs
    Command?: boolean | EmailTemplateCountOutputTypeCountCommandArgs
    Rule?: boolean | EmailTemplateCountOutputTypeCountRuleArgs
    RuleGroup?: boolean | EmailTemplateCountOutputTypeCountRuleGroupArgs
    SavedQuery?: boolean | EmailTemplateCountOutputTypeCountSavedQueryArgs
    assignedUsers?: boolean | EmailTemplateCountOutputTypeCountAssignedUsersArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountAlertConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertConditionWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountCommandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RuleWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountRuleGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RuleGroupWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountSavedQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedQueryWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountAssignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailTemplateWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ActivityLog: number
    CommandMatch: number
    devices: number
    DriveFile: number
    grantedPermissions: number
    DriveFilePermission: number
    DriveFolder: number
    Feedback: number
    FeedbackRecipient: number
    GroupMember: number
    Message: number
    NotificationRead: number
    ProjectAssignment: number
    assignedTickets: number
    createdTickets: number
    TeamLeader: number
    TeamMember: number
    TicketAttachment: number
    ticketComments: number
    emailTemplates: number
    UserPermission: number
    audit_steps: number
    receivedPermissions: number
    addressedMatches: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | UserCountOutputTypeCountActivityLogArgs
    CommandMatch?: boolean | UserCountOutputTypeCountCommandMatchArgs
    devices?: boolean | UserCountOutputTypeCountDevicesArgs
    DriveFile?: boolean | UserCountOutputTypeCountDriveFileArgs
    grantedPermissions?: boolean | UserCountOutputTypeCountGrantedPermissionsArgs
    DriveFilePermission?: boolean | UserCountOutputTypeCountDriveFilePermissionArgs
    DriveFolder?: boolean | UserCountOutputTypeCountDriveFolderArgs
    Feedback?: boolean | UserCountOutputTypeCountFeedbackArgs
    FeedbackRecipient?: boolean | UserCountOutputTypeCountFeedbackRecipientArgs
    GroupMember?: boolean | UserCountOutputTypeCountGroupMemberArgs
    Message?: boolean | UserCountOutputTypeCountMessageArgs
    NotificationRead?: boolean | UserCountOutputTypeCountNotificationReadArgs
    ProjectAssignment?: boolean | UserCountOutputTypeCountProjectAssignmentArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    createdTickets?: boolean | UserCountOutputTypeCountCreatedTicketsArgs
    TeamLeader?: boolean | UserCountOutputTypeCountTeamLeaderArgs
    TeamMember?: boolean | UserCountOutputTypeCountTeamMemberArgs
    TicketAttachment?: boolean | UserCountOutputTypeCountTicketAttachmentArgs
    ticketComments?: boolean | UserCountOutputTypeCountTicketCommentsArgs
    emailTemplates?: boolean | UserCountOutputTypeCountEmailTemplatesArgs
    UserPermission?: boolean | UserCountOutputTypeCountUserPermissionArgs
    audit_steps?: boolean | UserCountOutputTypeCountAudit_stepsArgs
    receivedPermissions?: boolean | UserCountOutputTypeCountReceivedPermissionsArgs
    addressedMatches?: boolean | UserCountOutputTypeCountAddressedMatchesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommandMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandMatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDriveFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGrantedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFilePermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDriveFilePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFilePermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDriveFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFolderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackRecipientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamLeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLeaderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudit_stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditStepWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFilePermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressedMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandMatchWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    messages: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    messages?: boolean | GroupCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    reads: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reads?: boolean | NotificationCountOutputTypeCountReadsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReadWhereInput
  }


  /**
   * Count Type TicketCommentCountOutputType
   */

  export type TicketCommentCountOutputType = {
    TicketAttachment: number
  }

  export type TicketCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TicketAttachment?: boolean | TicketCommentCountOutputTypeCountTicketAttachmentArgs
  }

  // Custom InputTypes
  /**
   * TicketCommentCountOutputType without action
   */
  export type TicketCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCommentCountOutputType
     */
    select?: TicketCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCommentCountOutputType without action
   */
  export type TicketCommentCountOutputTypeCountTicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    attachments: number
    comments: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | SupportTicketCountOutputTypeCountAttachmentsArgs
    comments?: boolean | SupportTicketCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }


  /**
   * Count Type AlertConditionCountOutputType
   */

  export type AlertConditionCountOutputType = {
    triggeredAlerts: number
  }

  export type AlertConditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    triggeredAlerts?: boolean | AlertConditionCountOutputTypeCountTriggeredAlertsArgs
  }

  // Custom InputTypes
  /**
   * AlertConditionCountOutputType without action
   */
  export type AlertConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertConditionCountOutputType
     */
    select?: AlertConditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertConditionCountOutputType without action
   */
  export type AlertConditionCountOutputTypeCountTriggeredAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
  }


  /**
   * Count Type FeedbackCountOutputType
   */

  export type FeedbackCountOutputType = {
    recipients: number
  }

  export type FeedbackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | FeedbackCountOutputTypeCountRecipientsArgs
  }

  // Custom InputTypes
  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackCountOutputType
     */
    select?: FeedbackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackRecipientWhereInput
  }


  /**
   * Count Type PagePermissionCountOutputType
   */

  export type PagePermissionCountOutputType = {
    allowedRoles: number
    allowedUsers: number
  }

  export type PagePermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allowedRoles?: boolean | PagePermissionCountOutputTypeCountAllowedRolesArgs
    allowedUsers?: boolean | PagePermissionCountOutputTypeCountAllowedUsersArgs
  }

  // Custom InputTypes
  /**
   * PagePermissionCountOutputType without action
   */
  export type PagePermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermissionCountOutputType
     */
    select?: PagePermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PagePermissionCountOutputType without action
   */
  export type PagePermissionCountOutputTypeCountAllowedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * PagePermissionCountOutputType without action
   */
  export type PagePermissionCountOutputTypeCountAllowedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
  }


  /**
   * Count Type ProjectTypeCountOutputType
   */

  export type ProjectTypeCountOutputType = {
    projects: number
  }

  export type ProjectTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectTypeCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProjectTypeCountOutputType without action
   */
  export type ProjectTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTypeCountOutputType
     */
    select?: ProjectTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectTypeCountOutputType without action
   */
  export type ProjectTypeCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    models: number
    assignments: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | ProjectCountOutputTypeCountModelsArgs
    assignments?: boolean | ProjectCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelEntryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectAssignmentWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    TeamLocation: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TeamLocation?: boolean | LocationCountOutputTypeCountTeamLocationArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountTeamLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLocationWhereInput
  }


  /**
   * Count Type DriveFolderCountOutputType
   */

  export type DriveFolderCountOutputType = {
    files: number
    children: number
  }

  export type DriveFolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | DriveFolderCountOutputTypeCountFilesArgs
    children?: boolean | DriveFolderCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * DriveFolderCountOutputType without action
   */
  export type DriveFolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolderCountOutputType
     */
    select?: DriveFolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriveFolderCountOutputType without action
   */
  export type DriveFolderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFileWhereInput
  }

  /**
   * DriveFolderCountOutputType without action
   */
  export type DriveFolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFolderWhereInput
  }


  /**
   * Count Type DriveFileCountOutputType
   */

  export type DriveFileCountOutputType = {
    permissions: number
  }

  export type DriveFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | DriveFileCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * DriveFileCountOutputType without action
   */
  export type DriveFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFileCountOutputType
     */
    select?: DriveFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriveFileCountOutputType without action
   */
  export type DriveFileCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFilePermissionWhereInput
  }


  /**
   * Count Type DriveFilePermissionCountOutputType
   */

  export type DriveFilePermissionCountOutputType = {
    User: number
  }

  export type DriveFilePermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | DriveFilePermissionCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * DriveFilePermissionCountOutputType without action
   */
  export type DriveFilePermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermissionCountOutputType
     */
    select?: DriveFilePermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriveFilePermissionCountOutputType without action
   */
  export type DriveFilePermissionCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    leaders: number
    locations: number
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaders?: boolean | TeamCountOutputTypeCountLeadersArgs
    locations?: boolean | TeamCountOutputTypeCountLocationsArgs
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLeadersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLeaderWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLocationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Count Type AuditWorkflowCountOutputType
   */

  export type AuditWorkflowCountOutputType = {
    steps: number
  }

  export type AuditWorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | AuditWorkflowCountOutputTypeCountStepsArgs
  }

  // Custom InputTypes
  /**
   * AuditWorkflowCountOutputType without action
   */
  export type AuditWorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflowCountOutputType
     */
    select?: AuditWorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditWorkflowCountOutputType without action
   */
  export type AuditWorkflowCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditStepWhereInput
  }


  /**
   * Count Type AuditStepCountOutputType
   */

  export type AuditStepCountOutputType = {
    logs: number
  }

  export type AuditStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | AuditStepCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * AuditStepCountOutputType without action
   */
  export type AuditStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStepCountOutputType
     */
    select?: AuditStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditStepCountOutputType without action
   */
  export type AuditStepCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsAvgAggregateOutputType = {
    id: number | null
    pid: number | null
    cpu: number | null
    mem: number | null
    port: number | null
  }

  export type LogsSumAggregateOutputType = {
    id: number | null
    pid: number | null
    cpu: number | null
    mem: number | null
    port: number | null
  }

  export type LogsMinAggregateOutputType = {
    id: number | null
    name: string | null
    host: string | null
    timestamp: Date | null
    piuser: string | null
    pid: number | null
    action: string | null
    cpu: number | null
    mem: number | null
    command: string | null
    port: number | null
    ipAddress: string | null
  }

  export type LogsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    host: string | null
    timestamp: Date | null
    piuser: string | null
    pid: number | null
    action: string | null
    cpu: number | null
    mem: number | null
    command: string | null
    port: number | null
    ipAddress: string | null
  }

  export type LogsCountAggregateOutputType = {
    id: number
    name: number
    host: number
    timestamp: number
    piuser: number
    pid: number
    action: number
    cpu: number
    mem: number
    command: number
    port: number
    ipAddress: number
    _all: number
  }


  export type LogsAvgAggregateInputType = {
    id?: true
    pid?: true
    cpu?: true
    mem?: true
    port?: true
  }

  export type LogsSumAggregateInputType = {
    id?: true
    pid?: true
    cpu?: true
    mem?: true
    port?: true
  }

  export type LogsMinAggregateInputType = {
    id?: true
    name?: true
    host?: true
    timestamp?: true
    piuser?: true
    pid?: true
    action?: true
    cpu?: true
    mem?: true
    command?: true
    port?: true
    ipAddress?: true
  }

  export type LogsMaxAggregateInputType = {
    id?: true
    name?: true
    host?: true
    timestamp?: true
    piuser?: true
    pid?: true
    action?: true
    cpu?: true
    mem?: true
    command?: true
    port?: true
    ipAddress?: true
  }

  export type LogsCountAggregateInputType = {
    id?: true
    name?: true
    host?: true
    timestamp?: true
    piuser?: true
    pid?: true
    action?: true
    cpu?: true
    mem?: true
    command?: true
    port?: true
    ipAddress?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs to aggregate.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logsWhereInput
    orderBy?: logsOrderByWithAggregationInput | logsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _avg?: LogsAvgAggregateInputType
    _sum?: LogsSumAggregateInputType
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    id: number
    name: string
    host: string | null
    timestamp: Date
    piuser: string | null
    pid: number | null
    action: string | null
    cpu: number | null
    mem: number | null
    command: string | null
    port: number | null
    ipAddress: string | null
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    host?: boolean
    timestamp?: boolean
    piuser?: boolean
    pid?: boolean
    action?: boolean
    cpu?: boolean
    mem?: boolean
    command?: boolean
    port?: boolean
    ipAddress?: boolean
  }, ExtArgs["result"]["logs"]>

  export type logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    host?: boolean
    timestamp?: boolean
    piuser?: boolean
    pid?: boolean
    action?: boolean
    cpu?: boolean
    mem?: boolean
    command?: boolean
    port?: boolean
    ipAddress?: boolean
  }, ExtArgs["result"]["logs"]>

  export type logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    host?: boolean
    timestamp?: boolean
    piuser?: boolean
    pid?: boolean
    action?: boolean
    cpu?: boolean
    mem?: boolean
    command?: boolean
    port?: boolean
    ipAddress?: boolean
  }, ExtArgs["result"]["logs"]>

  export type logsSelectScalar = {
    id?: boolean
    name?: boolean
    host?: boolean
    timestamp?: boolean
    piuser?: boolean
    pid?: boolean
    action?: boolean
    cpu?: boolean
    mem?: boolean
    command?: boolean
    port?: boolean
    ipAddress?: boolean
  }

  export type logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "host" | "timestamp" | "piuser" | "pid" | "action" | "cpu" | "mem" | "command" | "port" | "ipAddress", ExtArgs["result"]["logs"]>

  export type $logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      host: string | null
      timestamp: Date
      piuser: string | null
      pid: number | null
      action: string | null
      cpu: number | null
      mem: number | null
      command: string | null
      port: number | null
      ipAddress: string | null
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }

  type logsGetPayload<S extends boolean | null | undefined | logsDefaultArgs> = $Result.GetResult<Prisma.$logsPayload, S>

  type logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logs'], meta: { name: 'logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {logsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logsFindUniqueArgs>(args: SelectSubset<T, logsFindUniqueArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {logsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logsFindUniqueOrThrowArgs>(args: SelectSubset<T, logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logsFindFirstArgs>(args?: SelectSubset<T, logsFindFirstArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logsFindFirstOrThrowArgs>(args?: SelectSubset<T, logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsWithIdOnly = await prisma.logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logsFindManyArgs>(args?: SelectSubset<T, logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Logs.
     * @param {logsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
     */
    create<T extends logsCreateArgs>(args: SelectSubset<T, logsCreateArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Logs.
     * @param {logsCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logsCreateManyArgs>(args?: SelectSubset<T, logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {logsCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logsWithIdOnly = await prisma.logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends logsCreateManyAndReturnArgs>(args?: SelectSubset<T, logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Logs.
     * @param {logsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
     */
    delete<T extends logsDeleteArgs>(args: SelectSubset<T, logsDeleteArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Logs.
     * @param {logsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logsUpdateArgs>(args: SelectSubset<T, logsUpdateArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Logs.
     * @param {logsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logsDeleteManyArgs>(args?: SelectSubset<T, logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logsUpdateManyArgs>(args: SelectSubset<T, logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {logsUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logsWithIdOnly = await prisma.logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends logsUpdateManyAndReturnArgs>(args: SelectSubset<T, logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Logs.
     * @param {logsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
     */
    upsert<T extends logsUpsertArgs>(args: SelectSubset<T, logsUpsertArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends logsCountArgs>(
      args?: Subset<T, logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logsGroupByArgs['orderBy'] }
        : { orderBy?: logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logs model
   */
  readonly fields: logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logs model
   */ 
  interface logsFieldRefs {
    readonly id: FieldRef<"logs", 'Int'>
    readonly name: FieldRef<"logs", 'String'>
    readonly host: FieldRef<"logs", 'String'>
    readonly timestamp: FieldRef<"logs", 'DateTime'>
    readonly piuser: FieldRef<"logs", 'String'>
    readonly pid: FieldRef<"logs", 'Int'>
    readonly action: FieldRef<"logs", 'String'>
    readonly cpu: FieldRef<"logs", 'Float'>
    readonly mem: FieldRef<"logs", 'Float'>
    readonly command: FieldRef<"logs", 'String'>
    readonly port: FieldRef<"logs", 'Int'>
    readonly ipAddress: FieldRef<"logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * logs findUnique
   */
  export type logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs findUniqueOrThrow
   */
  export type logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs findFirst
   */
  export type logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * logs findFirstOrThrow
   */
  export type logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * logs findMany
   */
  export type logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs.
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * logs create
   */
  export type logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * The data needed to create a logs.
     */
    data: XOR<logsCreateInput, logsUncheckedCreateInput>
  }

  /**
   * logs createMany
   */
  export type logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs.
     */
    data: logsCreateManyInput | logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logs createManyAndReturn
   */
  export type logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * The data used to create many logs.
     */
    data: logsCreateManyInput | logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logs update
   */
  export type logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * The data needed to update a logs.
     */
    data: XOR<logsUpdateInput, logsUncheckedUpdateInput>
    /**
     * Choose, which logs to update.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs updateMany
   */
  export type logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs.
     */
    data: XOR<logsUpdateManyMutationInput, logsUncheckedUpdateManyInput>
    /**
     * Filter which logs to update
     */
    where?: logsWhereInput
    /**
     * Limit how many logs to update.
     */
    limit?: number
  }

  /**
   * logs updateManyAndReturn
   */
  export type logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * The data used to update logs.
     */
    data: XOR<logsUpdateManyMutationInput, logsUncheckedUpdateManyInput>
    /**
     * Filter which logs to update
     */
    where?: logsWhereInput
    /**
     * Limit how many logs to update.
     */
    limit?: number
  }

  /**
   * logs upsert
   */
  export type logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * The filter to search for the logs to update in case it exists.
     */
    where: logsWhereUniqueInput
    /**
     * In case the logs found by the `where` argument doesn't exist, create a new logs with this data.
     */
    create: XOR<logsCreateInput, logsUncheckedCreateInput>
    /**
     * In case the logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logsUpdateInput, logsUncheckedUpdateInput>
  }

  /**
   * logs delete
   */
  export type logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Filter which logs to delete.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs deleteMany
   */
  export type logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs to delete
     */
    where?: logsWhereInput
    /**
     * Limit how many logs to delete.
     */
    limit?: number
  }

  /**
   * logs without action
   */
  export type logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
  }


  /**
   * Model auth
   */

  export type AggregateAuth = {
    _count: AuthCountAggregateOutputType | null
    _avg: AuthAvgAggregateOutputType | null
    _sum: AuthSumAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  export type AuthAvgAggregateOutputType = {
    id: number | null
  }

  export type AuthSumAggregateOutputType = {
    id: number | null
  }

  export type AuthMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    username: string | null
    log_entry: string | null
  }

  export type AuthMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    username: string | null
    log_entry: string | null
  }

  export type AuthCountAggregateOutputType = {
    id: number
    timestamp: number
    username: number
    log_entry: number
    _all: number
  }


  export type AuthAvgAggregateInputType = {
    id?: true
  }

  export type AuthSumAggregateInputType = {
    id?: true
  }

  export type AuthMinAggregateInputType = {
    id?: true
    timestamp?: true
    username?: true
    log_entry?: true
  }

  export type AuthMaxAggregateInputType = {
    id?: true
    timestamp?: true
    username?: true
    log_entry?: true
  }

  export type AuthCountAggregateInputType = {
    id?: true
    timestamp?: true
    username?: true
    log_entry?: true
    _all?: true
  }

  export type AuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth to aggregate.
     */
    where?: authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auths to fetch.
     */
    orderBy?: authOrderByWithRelationInput | authOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auths
    **/
    _count?: true | AuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthMaxAggregateInputType
  }

  export type GetAuthAggregateType<T extends AuthAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth[P]>
      : GetScalarType<T[P], AggregateAuth[P]>
  }




  export type authGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authWhereInput
    orderBy?: authOrderByWithAggregationInput | authOrderByWithAggregationInput[]
    by: AuthScalarFieldEnum[] | AuthScalarFieldEnum
    having?: authScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthCountAggregateInputType | true
    _avg?: AuthAvgAggregateInputType
    _sum?: AuthSumAggregateInputType
    _min?: AuthMinAggregateInputType
    _max?: AuthMaxAggregateInputType
  }

  export type AuthGroupByOutputType = {
    id: number
    timestamp: Date
    username: string
    log_entry: string
    _count: AuthCountAggregateOutputType | null
    _avg: AuthAvgAggregateOutputType | null
    _sum: AuthSumAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  type GetAuthGroupByPayload<T extends authGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthGroupByOutputType[P]>
            : GetScalarType<T[P], AuthGroupByOutputType[P]>
        }
      >
    >


  export type authSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    username?: boolean
    log_entry?: boolean
  }, ExtArgs["result"]["auth"]>

  export type authSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    username?: boolean
    log_entry?: boolean
  }, ExtArgs["result"]["auth"]>

  export type authSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    username?: boolean
    log_entry?: boolean
  }, ExtArgs["result"]["auth"]>

  export type authSelectScalar = {
    id?: boolean
    timestamp?: boolean
    username?: boolean
    log_entry?: boolean
  }

  export type authOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "username" | "log_entry", ExtArgs["result"]["auth"]>

  export type $authPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      username: string
      log_entry: string
    }, ExtArgs["result"]["auth"]>
    composites: {}
  }

  type authGetPayload<S extends boolean | null | undefined | authDefaultArgs> = $Result.GetResult<Prisma.$authPayload, S>

  type authCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<authFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthCountAggregateInputType | true
    }

  export interface authDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth'], meta: { name: 'auth' } }
    /**
     * Find zero or one Auth that matches the filter.
     * @param {authFindUniqueArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends authFindUniqueArgs>(args: SelectSubset<T, authFindUniqueArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Auth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {authFindUniqueOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends authFindUniqueOrThrowArgs>(args: SelectSubset<T, authFindUniqueOrThrowArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Auth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authFindFirstArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends authFindFirstArgs>(args?: SelectSubset<T, authFindFirstArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Auth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authFindFirstOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends authFindFirstOrThrowArgs>(args?: SelectSubset<T, authFindFirstOrThrowArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Auths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auths
     * const auths = await prisma.auth.findMany()
     * 
     * // Get first 10 Auths
     * const auths = await prisma.auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authWithIdOnly = await prisma.auth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends authFindManyArgs>(args?: SelectSubset<T, authFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Auth.
     * @param {authCreateArgs} args - Arguments to create a Auth.
     * @example
     * // Create one Auth
     * const Auth = await prisma.auth.create({
     *   data: {
     *     // ... data to create a Auth
     *   }
     * })
     * 
     */
    create<T extends authCreateArgs>(args: SelectSubset<T, authCreateArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Auths.
     * @param {authCreateManyArgs} args - Arguments to create many Auths.
     * @example
     * // Create many Auths
     * const auth = await prisma.auth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends authCreateManyArgs>(args?: SelectSubset<T, authCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auths and returns the data saved in the database.
     * @param {authCreateManyAndReturnArgs} args - Arguments to create many Auths.
     * @example
     * // Create many Auths
     * const auth = await prisma.auth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auths and only return the `id`
     * const authWithIdOnly = await prisma.auth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends authCreateManyAndReturnArgs>(args?: SelectSubset<T, authCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Auth.
     * @param {authDeleteArgs} args - Arguments to delete one Auth.
     * @example
     * // Delete one Auth
     * const Auth = await prisma.auth.delete({
     *   where: {
     *     // ... filter to delete one Auth
     *   }
     * })
     * 
     */
    delete<T extends authDeleteArgs>(args: SelectSubset<T, authDeleteArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Auth.
     * @param {authUpdateArgs} args - Arguments to update one Auth.
     * @example
     * // Update one Auth
     * const auth = await prisma.auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends authUpdateArgs>(args: SelectSubset<T, authUpdateArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Auths.
     * @param {authDeleteManyArgs} args - Arguments to filter Auths to delete.
     * @example
     * // Delete a few Auths
     * const { count } = await prisma.auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends authDeleteManyArgs>(args?: SelectSubset<T, authDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends authUpdateManyArgs>(args: SelectSubset<T, authUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths and returns the data updated in the database.
     * @param {authUpdateManyAndReturnArgs} args - Arguments to update many Auths.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auths and only return the `id`
     * const authWithIdOnly = await prisma.auth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends authUpdateManyAndReturnArgs>(args: SelectSubset<T, authUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Auth.
     * @param {authUpsertArgs} args - Arguments to update or create a Auth.
     * @example
     * // Update or create a Auth
     * const auth = await prisma.auth.upsert({
     *   create: {
     *     // ... data to create a Auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth we want to update
     *   }
     * })
     */
    upsert<T extends authUpsertArgs>(args: SelectSubset<T, authUpsertArgs<ExtArgs>>): Prisma__authClient<$Result.GetResult<Prisma.$authPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authCountArgs} args - Arguments to filter Auths to count.
     * @example
     * // Count the number of Auths
     * const count = await prisma.auth.count({
     *   where: {
     *     // ... the filter for the Auths we want to count
     *   }
     * })
    **/
    count<T extends authCountArgs>(
      args?: Subset<T, authCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthAggregateArgs>(args: Subset<T, AuthAggregateArgs>): Prisma.PrismaPromise<GetAuthAggregateType<T>>

    /**
     * Group by Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authGroupByArgs['orderBy'] }
        : { orderBy?: authGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth model
   */
  readonly fields: authFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth model
   */ 
  interface authFieldRefs {
    readonly id: FieldRef<"auth", 'Int'>
    readonly timestamp: FieldRef<"auth", 'DateTime'>
    readonly username: FieldRef<"auth", 'String'>
    readonly log_entry: FieldRef<"auth", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auth findUnique
   */
  export type authFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * Filter, which auth to fetch.
     */
    where: authWhereUniqueInput
  }

  /**
   * auth findUniqueOrThrow
   */
  export type authFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * Filter, which auth to fetch.
     */
    where: authWhereUniqueInput
  }

  /**
   * auth findFirst
   */
  export type authFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * Filter, which auth to fetch.
     */
    where?: authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auths to fetch.
     */
    orderBy?: authOrderByWithRelationInput | authOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auths.
     */
    cursor?: authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * auth findFirstOrThrow
   */
  export type authFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * Filter, which auth to fetch.
     */
    where?: authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auths to fetch.
     */
    orderBy?: authOrderByWithRelationInput | authOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auths.
     */
    cursor?: authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * auth findMany
   */
  export type authFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * Filter, which auths to fetch.
     */
    where?: authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auths to fetch.
     */
    orderBy?: authOrderByWithRelationInput | authOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auths.
     */
    cursor?: authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auths.
     */
    skip?: number
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * auth create
   */
  export type authCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * The data needed to create a auth.
     */
    data: XOR<authCreateInput, authUncheckedCreateInput>
  }

  /**
   * auth createMany
   */
  export type authCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auths.
     */
    data: authCreateManyInput | authCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth createManyAndReturn
   */
  export type authCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * The data used to create many auths.
     */
    data: authCreateManyInput | authCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth update
   */
  export type authUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * The data needed to update a auth.
     */
    data: XOR<authUpdateInput, authUncheckedUpdateInput>
    /**
     * Choose, which auth to update.
     */
    where: authWhereUniqueInput
  }

  /**
   * auth updateMany
   */
  export type authUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auths.
     */
    data: XOR<authUpdateManyMutationInput, authUncheckedUpdateManyInput>
    /**
     * Filter which auths to update
     */
    where?: authWhereInput
    /**
     * Limit how many auths to update.
     */
    limit?: number
  }

  /**
   * auth updateManyAndReturn
   */
  export type authUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * The data used to update auths.
     */
    data: XOR<authUpdateManyMutationInput, authUncheckedUpdateManyInput>
    /**
     * Filter which auths to update
     */
    where?: authWhereInput
    /**
     * Limit how many auths to update.
     */
    limit?: number
  }

  /**
   * auth upsert
   */
  export type authUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * The filter to search for the auth to update in case it exists.
     */
    where: authWhereUniqueInput
    /**
     * In case the auth found by the `where` argument doesn't exist, create a new auth with this data.
     */
    create: XOR<authCreateInput, authUncheckedCreateInput>
    /**
     * In case the auth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authUpdateInput, authUncheckedUpdateInput>
  }

  /**
   * auth delete
   */
  export type authDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
    /**
     * Filter which auth to delete.
     */
    where: authWhereUniqueInput
  }

  /**
   * auth deleteMany
   */
  export type authDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auths to delete
     */
    where?: authWhereInput
    /**
     * Limit how many auths to delete.
     */
    limit?: number
  }

  /**
   * auth without action
   */
  export type authDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth
     */
    select?: authSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth
     */
    omit?: authOmit<ExtArgs> | null
  }


  /**
   * Model memory_usage
   */

  export type AggregateMemory_usage = {
    _count: Memory_usageCountAggregateOutputType | null
    _avg: Memory_usageAvgAggregateOutputType | null
    _sum: Memory_usageSumAggregateOutputType | null
    _min: Memory_usageMinAggregateOutputType | null
    _max: Memory_usageMaxAggregateOutputType | null
  }

  export type Memory_usageAvgAggregateOutputType = {
    id: number | null
    total_memory: number | null
    used_memory: number | null
    free_memory: number | null
    available_memory: number | null
    percent_usage: number | null
  }

  export type Memory_usageSumAggregateOutputType = {
    id: number | null
    total_memory: bigint | null
    used_memory: bigint | null
    free_memory: bigint | null
    available_memory: bigint | null
    percent_usage: number | null
  }

  export type Memory_usageMinAggregateOutputType = {
    id: number | null
    total_memory: bigint | null
    used_memory: bigint | null
    free_memory: bigint | null
    available_memory: bigint | null
    percent_usage: number | null
    host: string | null
    time: Date | null
  }

  export type Memory_usageMaxAggregateOutputType = {
    id: number | null
    total_memory: bigint | null
    used_memory: bigint | null
    free_memory: bigint | null
    available_memory: bigint | null
    percent_usage: number | null
    host: string | null
    time: Date | null
  }

  export type Memory_usageCountAggregateOutputType = {
    id: number
    total_memory: number
    used_memory: number
    free_memory: number
    available_memory: number
    percent_usage: number
    host: number
    time: number
    _all: number
  }


  export type Memory_usageAvgAggregateInputType = {
    id?: true
    total_memory?: true
    used_memory?: true
    free_memory?: true
    available_memory?: true
    percent_usage?: true
  }

  export type Memory_usageSumAggregateInputType = {
    id?: true
    total_memory?: true
    used_memory?: true
    free_memory?: true
    available_memory?: true
    percent_usage?: true
  }

  export type Memory_usageMinAggregateInputType = {
    id?: true
    total_memory?: true
    used_memory?: true
    free_memory?: true
    available_memory?: true
    percent_usage?: true
    host?: true
    time?: true
  }

  export type Memory_usageMaxAggregateInputType = {
    id?: true
    total_memory?: true
    used_memory?: true
    free_memory?: true
    available_memory?: true
    percent_usage?: true
    host?: true
    time?: true
  }

  export type Memory_usageCountAggregateInputType = {
    id?: true
    total_memory?: true
    used_memory?: true
    free_memory?: true
    available_memory?: true
    percent_usage?: true
    host?: true
    time?: true
    _all?: true
  }

  export type Memory_usageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which memory_usage to aggregate.
     */
    where?: memory_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memory_usages to fetch.
     */
    orderBy?: memory_usageOrderByWithRelationInput | memory_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: memory_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memory_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memory_usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned memory_usages
    **/
    _count?: true | Memory_usageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Memory_usageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Memory_usageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Memory_usageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Memory_usageMaxAggregateInputType
  }

  export type GetMemory_usageAggregateType<T extends Memory_usageAggregateArgs> = {
        [P in keyof T & keyof AggregateMemory_usage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemory_usage[P]>
      : GetScalarType<T[P], AggregateMemory_usage[P]>
  }




  export type memory_usageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: memory_usageWhereInput
    orderBy?: memory_usageOrderByWithAggregationInput | memory_usageOrderByWithAggregationInput[]
    by: Memory_usageScalarFieldEnum[] | Memory_usageScalarFieldEnum
    having?: memory_usageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Memory_usageCountAggregateInputType | true
    _avg?: Memory_usageAvgAggregateInputType
    _sum?: Memory_usageSumAggregateInputType
    _min?: Memory_usageMinAggregateInputType
    _max?: Memory_usageMaxAggregateInputType
  }

  export type Memory_usageGroupByOutputType = {
    id: number
    total_memory: bigint
    used_memory: bigint
    free_memory: bigint
    available_memory: bigint
    percent_usage: number
    host: string | null
    time: Date
    _count: Memory_usageCountAggregateOutputType | null
    _avg: Memory_usageAvgAggregateOutputType | null
    _sum: Memory_usageSumAggregateOutputType | null
    _min: Memory_usageMinAggregateOutputType | null
    _max: Memory_usageMaxAggregateOutputType | null
  }

  type GetMemory_usageGroupByPayload<T extends memory_usageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Memory_usageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Memory_usageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Memory_usageGroupByOutputType[P]>
            : GetScalarType<T[P], Memory_usageGroupByOutputType[P]>
        }
      >
    >


  export type memory_usageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_memory?: boolean
    used_memory?: boolean
    free_memory?: boolean
    available_memory?: boolean
    percent_usage?: boolean
    host?: boolean
    time?: boolean
  }, ExtArgs["result"]["memory_usage"]>

  export type memory_usageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_memory?: boolean
    used_memory?: boolean
    free_memory?: boolean
    available_memory?: boolean
    percent_usage?: boolean
    host?: boolean
    time?: boolean
  }, ExtArgs["result"]["memory_usage"]>

  export type memory_usageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_memory?: boolean
    used_memory?: boolean
    free_memory?: boolean
    available_memory?: boolean
    percent_usage?: boolean
    host?: boolean
    time?: boolean
  }, ExtArgs["result"]["memory_usage"]>

  export type memory_usageSelectScalar = {
    id?: boolean
    total_memory?: boolean
    used_memory?: boolean
    free_memory?: boolean
    available_memory?: boolean
    percent_usage?: boolean
    host?: boolean
    time?: boolean
  }

  export type memory_usageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "total_memory" | "used_memory" | "free_memory" | "available_memory" | "percent_usage" | "host" | "time", ExtArgs["result"]["memory_usage"]>

  export type $memory_usagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "memory_usage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      total_memory: bigint
      used_memory: bigint
      free_memory: bigint
      available_memory: bigint
      percent_usage: number
      host: string | null
      time: Date
    }, ExtArgs["result"]["memory_usage"]>
    composites: {}
  }

  type memory_usageGetPayload<S extends boolean | null | undefined | memory_usageDefaultArgs> = $Result.GetResult<Prisma.$memory_usagePayload, S>

  type memory_usageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<memory_usageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Memory_usageCountAggregateInputType | true
    }

  export interface memory_usageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['memory_usage'], meta: { name: 'memory_usage' } }
    /**
     * Find zero or one Memory_usage that matches the filter.
     * @param {memory_usageFindUniqueArgs} args - Arguments to find a Memory_usage
     * @example
     * // Get one Memory_usage
     * const memory_usage = await prisma.memory_usage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends memory_usageFindUniqueArgs>(args: SelectSubset<T, memory_usageFindUniqueArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Memory_usage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {memory_usageFindUniqueOrThrowArgs} args - Arguments to find a Memory_usage
     * @example
     * // Get one Memory_usage
     * const memory_usage = await prisma.memory_usage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends memory_usageFindUniqueOrThrowArgs>(args: SelectSubset<T, memory_usageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Memory_usage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memory_usageFindFirstArgs} args - Arguments to find a Memory_usage
     * @example
     * // Get one Memory_usage
     * const memory_usage = await prisma.memory_usage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends memory_usageFindFirstArgs>(args?: SelectSubset<T, memory_usageFindFirstArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Memory_usage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memory_usageFindFirstOrThrowArgs} args - Arguments to find a Memory_usage
     * @example
     * // Get one Memory_usage
     * const memory_usage = await prisma.memory_usage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends memory_usageFindFirstOrThrowArgs>(args?: SelectSubset<T, memory_usageFindFirstOrThrowArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Memory_usages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memory_usageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memory_usages
     * const memory_usages = await prisma.memory_usage.findMany()
     * 
     * // Get first 10 Memory_usages
     * const memory_usages = await prisma.memory_usage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memory_usageWithIdOnly = await prisma.memory_usage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends memory_usageFindManyArgs>(args?: SelectSubset<T, memory_usageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Memory_usage.
     * @param {memory_usageCreateArgs} args - Arguments to create a Memory_usage.
     * @example
     * // Create one Memory_usage
     * const Memory_usage = await prisma.memory_usage.create({
     *   data: {
     *     // ... data to create a Memory_usage
     *   }
     * })
     * 
     */
    create<T extends memory_usageCreateArgs>(args: SelectSubset<T, memory_usageCreateArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Memory_usages.
     * @param {memory_usageCreateManyArgs} args - Arguments to create many Memory_usages.
     * @example
     * // Create many Memory_usages
     * const memory_usage = await prisma.memory_usage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends memory_usageCreateManyArgs>(args?: SelectSubset<T, memory_usageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memory_usages and returns the data saved in the database.
     * @param {memory_usageCreateManyAndReturnArgs} args - Arguments to create many Memory_usages.
     * @example
     * // Create many Memory_usages
     * const memory_usage = await prisma.memory_usage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memory_usages and only return the `id`
     * const memory_usageWithIdOnly = await prisma.memory_usage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends memory_usageCreateManyAndReturnArgs>(args?: SelectSubset<T, memory_usageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Memory_usage.
     * @param {memory_usageDeleteArgs} args - Arguments to delete one Memory_usage.
     * @example
     * // Delete one Memory_usage
     * const Memory_usage = await prisma.memory_usage.delete({
     *   where: {
     *     // ... filter to delete one Memory_usage
     *   }
     * })
     * 
     */
    delete<T extends memory_usageDeleteArgs>(args: SelectSubset<T, memory_usageDeleteArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Memory_usage.
     * @param {memory_usageUpdateArgs} args - Arguments to update one Memory_usage.
     * @example
     * // Update one Memory_usage
     * const memory_usage = await prisma.memory_usage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends memory_usageUpdateArgs>(args: SelectSubset<T, memory_usageUpdateArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Memory_usages.
     * @param {memory_usageDeleteManyArgs} args - Arguments to filter Memory_usages to delete.
     * @example
     * // Delete a few Memory_usages
     * const { count } = await prisma.memory_usage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends memory_usageDeleteManyArgs>(args?: SelectSubset<T, memory_usageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memory_usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memory_usageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memory_usages
     * const memory_usage = await prisma.memory_usage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends memory_usageUpdateManyArgs>(args: SelectSubset<T, memory_usageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memory_usages and returns the data updated in the database.
     * @param {memory_usageUpdateManyAndReturnArgs} args - Arguments to update many Memory_usages.
     * @example
     * // Update many Memory_usages
     * const memory_usage = await prisma.memory_usage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memory_usages and only return the `id`
     * const memory_usageWithIdOnly = await prisma.memory_usage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends memory_usageUpdateManyAndReturnArgs>(args: SelectSubset<T, memory_usageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Memory_usage.
     * @param {memory_usageUpsertArgs} args - Arguments to update or create a Memory_usage.
     * @example
     * // Update or create a Memory_usage
     * const memory_usage = await prisma.memory_usage.upsert({
     *   create: {
     *     // ... data to create a Memory_usage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memory_usage we want to update
     *   }
     * })
     */
    upsert<T extends memory_usageUpsertArgs>(args: SelectSubset<T, memory_usageUpsertArgs<ExtArgs>>): Prisma__memory_usageClient<$Result.GetResult<Prisma.$memory_usagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Memory_usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memory_usageCountArgs} args - Arguments to filter Memory_usages to count.
     * @example
     * // Count the number of Memory_usages
     * const count = await prisma.memory_usage.count({
     *   where: {
     *     // ... the filter for the Memory_usages we want to count
     *   }
     * })
    **/
    count<T extends memory_usageCountArgs>(
      args?: Subset<T, memory_usageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Memory_usageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memory_usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Memory_usageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Memory_usageAggregateArgs>(args: Subset<T, Memory_usageAggregateArgs>): Prisma.PrismaPromise<GetMemory_usageAggregateType<T>>

    /**
     * Group by Memory_usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memory_usageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends memory_usageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: memory_usageGroupByArgs['orderBy'] }
        : { orderBy?: memory_usageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, memory_usageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemory_usageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the memory_usage model
   */
  readonly fields: memory_usageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for memory_usage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__memory_usageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the memory_usage model
   */ 
  interface memory_usageFieldRefs {
    readonly id: FieldRef<"memory_usage", 'Int'>
    readonly total_memory: FieldRef<"memory_usage", 'BigInt'>
    readonly used_memory: FieldRef<"memory_usage", 'BigInt'>
    readonly free_memory: FieldRef<"memory_usage", 'BigInt'>
    readonly available_memory: FieldRef<"memory_usage", 'BigInt'>
    readonly percent_usage: FieldRef<"memory_usage", 'Float'>
    readonly host: FieldRef<"memory_usage", 'String'>
    readonly time: FieldRef<"memory_usage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * memory_usage findUnique
   */
  export type memory_usageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * Filter, which memory_usage to fetch.
     */
    where: memory_usageWhereUniqueInput
  }

  /**
   * memory_usage findUniqueOrThrow
   */
  export type memory_usageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * Filter, which memory_usage to fetch.
     */
    where: memory_usageWhereUniqueInput
  }

  /**
   * memory_usage findFirst
   */
  export type memory_usageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * Filter, which memory_usage to fetch.
     */
    where?: memory_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memory_usages to fetch.
     */
    orderBy?: memory_usageOrderByWithRelationInput | memory_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for memory_usages.
     */
    cursor?: memory_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memory_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memory_usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of memory_usages.
     */
    distinct?: Memory_usageScalarFieldEnum | Memory_usageScalarFieldEnum[]
  }

  /**
   * memory_usage findFirstOrThrow
   */
  export type memory_usageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * Filter, which memory_usage to fetch.
     */
    where?: memory_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memory_usages to fetch.
     */
    orderBy?: memory_usageOrderByWithRelationInput | memory_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for memory_usages.
     */
    cursor?: memory_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memory_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memory_usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of memory_usages.
     */
    distinct?: Memory_usageScalarFieldEnum | Memory_usageScalarFieldEnum[]
  }

  /**
   * memory_usage findMany
   */
  export type memory_usageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * Filter, which memory_usages to fetch.
     */
    where?: memory_usageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memory_usages to fetch.
     */
    orderBy?: memory_usageOrderByWithRelationInput | memory_usageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing memory_usages.
     */
    cursor?: memory_usageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memory_usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memory_usages.
     */
    skip?: number
    distinct?: Memory_usageScalarFieldEnum | Memory_usageScalarFieldEnum[]
  }

  /**
   * memory_usage create
   */
  export type memory_usageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * The data needed to create a memory_usage.
     */
    data: XOR<memory_usageCreateInput, memory_usageUncheckedCreateInput>
  }

  /**
   * memory_usage createMany
   */
  export type memory_usageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many memory_usages.
     */
    data: memory_usageCreateManyInput | memory_usageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * memory_usage createManyAndReturn
   */
  export type memory_usageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * The data used to create many memory_usages.
     */
    data: memory_usageCreateManyInput | memory_usageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * memory_usage update
   */
  export type memory_usageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * The data needed to update a memory_usage.
     */
    data: XOR<memory_usageUpdateInput, memory_usageUncheckedUpdateInput>
    /**
     * Choose, which memory_usage to update.
     */
    where: memory_usageWhereUniqueInput
  }

  /**
   * memory_usage updateMany
   */
  export type memory_usageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update memory_usages.
     */
    data: XOR<memory_usageUpdateManyMutationInput, memory_usageUncheckedUpdateManyInput>
    /**
     * Filter which memory_usages to update
     */
    where?: memory_usageWhereInput
    /**
     * Limit how many memory_usages to update.
     */
    limit?: number
  }

  /**
   * memory_usage updateManyAndReturn
   */
  export type memory_usageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * The data used to update memory_usages.
     */
    data: XOR<memory_usageUpdateManyMutationInput, memory_usageUncheckedUpdateManyInput>
    /**
     * Filter which memory_usages to update
     */
    where?: memory_usageWhereInput
    /**
     * Limit how many memory_usages to update.
     */
    limit?: number
  }

  /**
   * memory_usage upsert
   */
  export type memory_usageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * The filter to search for the memory_usage to update in case it exists.
     */
    where: memory_usageWhereUniqueInput
    /**
     * In case the memory_usage found by the `where` argument doesn't exist, create a new memory_usage with this data.
     */
    create: XOR<memory_usageCreateInput, memory_usageUncheckedCreateInput>
    /**
     * In case the memory_usage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<memory_usageUpdateInput, memory_usageUncheckedUpdateInput>
  }

  /**
   * memory_usage delete
   */
  export type memory_usageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
    /**
     * Filter which memory_usage to delete.
     */
    where: memory_usageWhereUniqueInput
  }

  /**
   * memory_usage deleteMany
   */
  export type memory_usageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which memory_usages to delete
     */
    where?: memory_usageWhereInput
    /**
     * Limit how many memory_usages to delete.
     */
    limit?: number
  }

  /**
   * memory_usage without action
   */
  export type memory_usageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the memory_usage
     */
    select?: memory_usageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the memory_usage
     */
    omit?: memory_usageOmit<ExtArgs> | null
  }


  /**
   * Model system_metrics
   */

  export type AggregateSystem_metrics = {
    _count: System_metricsCountAggregateOutputType | null
    _avg: System_metricsAvgAggregateOutputType | null
    _sum: System_metricsSumAggregateOutputType | null
    _min: System_metricsMinAggregateOutputType | null
    _max: System_metricsMaxAggregateOutputType | null
  }

  export type System_metricsAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type System_metricsSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type System_metricsMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    sensor_name: string | null
    value_type: string | null
    value: number | null
    host: string | null
    min: string | null
    max: string | null
  }

  export type System_metricsMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    sensor_name: string | null
    value_type: string | null
    value: number | null
    host: string | null
    min: string | null
    max: string | null
  }

  export type System_metricsCountAggregateOutputType = {
    id: number
    timestamp: number
    sensor_name: number
    value_type: number
    value: number
    host: number
    min: number
    max: number
    _all: number
  }


  export type System_metricsAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type System_metricsSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type System_metricsMinAggregateInputType = {
    id?: true
    timestamp?: true
    sensor_name?: true
    value_type?: true
    value?: true
    host?: true
    min?: true
    max?: true
  }

  export type System_metricsMaxAggregateInputType = {
    id?: true
    timestamp?: true
    sensor_name?: true
    value_type?: true
    value?: true
    host?: true
    min?: true
    max?: true
  }

  export type System_metricsCountAggregateInputType = {
    id?: true
    timestamp?: true
    sensor_name?: true
    value_type?: true
    value?: true
    host?: true
    min?: true
    max?: true
    _all?: true
  }

  export type System_metricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_metrics to aggregate.
     */
    where?: system_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_metrics to fetch.
     */
    orderBy?: system_metricsOrderByWithRelationInput | system_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: system_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned system_metrics
    **/
    _count?: true | System_metricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: System_metricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: System_metricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: System_metricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: System_metricsMaxAggregateInputType
  }

  export type GetSystem_metricsAggregateType<T extends System_metricsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystem_metrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystem_metrics[P]>
      : GetScalarType<T[P], AggregateSystem_metrics[P]>
  }




  export type system_metricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: system_metricsWhereInput
    orderBy?: system_metricsOrderByWithAggregationInput | system_metricsOrderByWithAggregationInput[]
    by: System_metricsScalarFieldEnum[] | System_metricsScalarFieldEnum
    having?: system_metricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: System_metricsCountAggregateInputType | true
    _avg?: System_metricsAvgAggregateInputType
    _sum?: System_metricsSumAggregateInputType
    _min?: System_metricsMinAggregateInputType
    _max?: System_metricsMaxAggregateInputType
  }

  export type System_metricsGroupByOutputType = {
    id: number
    timestamp: Date
    sensor_name: string
    value_type: string
    value: number
    host: string
    min: string | null
    max: string | null
    _count: System_metricsCountAggregateOutputType | null
    _avg: System_metricsAvgAggregateOutputType | null
    _sum: System_metricsSumAggregateOutputType | null
    _min: System_metricsMinAggregateOutputType | null
    _max: System_metricsMaxAggregateOutputType | null
  }

  type GetSystem_metricsGroupByPayload<T extends system_metricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<System_metricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof System_metricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], System_metricsGroupByOutputType[P]>
            : GetScalarType<T[P], System_metricsGroupByOutputType[P]>
        }
      >
    >


  export type system_metricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    sensor_name?: boolean
    value_type?: boolean
    value?: boolean
    host?: boolean
    min?: boolean
    max?: boolean
  }, ExtArgs["result"]["system_metrics"]>

  export type system_metricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    sensor_name?: boolean
    value_type?: boolean
    value?: boolean
    host?: boolean
    min?: boolean
    max?: boolean
  }, ExtArgs["result"]["system_metrics"]>

  export type system_metricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    sensor_name?: boolean
    value_type?: boolean
    value?: boolean
    host?: boolean
    min?: boolean
    max?: boolean
  }, ExtArgs["result"]["system_metrics"]>

  export type system_metricsSelectScalar = {
    id?: boolean
    timestamp?: boolean
    sensor_name?: boolean
    value_type?: boolean
    value?: boolean
    host?: boolean
    min?: boolean
    max?: boolean
  }

  export type system_metricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "sensor_name" | "value_type" | "value" | "host" | "min" | "max", ExtArgs["result"]["system_metrics"]>

  export type $system_metricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "system_metrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      sensor_name: string
      value_type: string
      value: number
      host: string
      min: string | null
      max: string | null
    }, ExtArgs["result"]["system_metrics"]>
    composites: {}
  }

  type system_metricsGetPayload<S extends boolean | null | undefined | system_metricsDefaultArgs> = $Result.GetResult<Prisma.$system_metricsPayload, S>

  type system_metricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<system_metricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: System_metricsCountAggregateInputType | true
    }

  export interface system_metricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['system_metrics'], meta: { name: 'system_metrics' } }
    /**
     * Find zero or one System_metrics that matches the filter.
     * @param {system_metricsFindUniqueArgs} args - Arguments to find a System_metrics
     * @example
     * // Get one System_metrics
     * const system_metrics = await prisma.system_metrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends system_metricsFindUniqueArgs>(args: SelectSubset<T, system_metricsFindUniqueArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one System_metrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {system_metricsFindUniqueOrThrowArgs} args - Arguments to find a System_metrics
     * @example
     * // Get one System_metrics
     * const system_metrics = await prisma.system_metrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends system_metricsFindUniqueOrThrowArgs>(args: SelectSubset<T, system_metricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first System_metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_metricsFindFirstArgs} args - Arguments to find a System_metrics
     * @example
     * // Get one System_metrics
     * const system_metrics = await prisma.system_metrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends system_metricsFindFirstArgs>(args?: SelectSubset<T, system_metricsFindFirstArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first System_metrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_metricsFindFirstOrThrowArgs} args - Arguments to find a System_metrics
     * @example
     * // Get one System_metrics
     * const system_metrics = await prisma.system_metrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends system_metricsFindFirstOrThrowArgs>(args?: SelectSubset<T, system_metricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more System_metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_metricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all System_metrics
     * const system_metrics = await prisma.system_metrics.findMany()
     * 
     * // Get first 10 System_metrics
     * const system_metrics = await prisma.system_metrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const system_metricsWithIdOnly = await prisma.system_metrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends system_metricsFindManyArgs>(args?: SelectSubset<T, system_metricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a System_metrics.
     * @param {system_metricsCreateArgs} args - Arguments to create a System_metrics.
     * @example
     * // Create one System_metrics
     * const System_metrics = await prisma.system_metrics.create({
     *   data: {
     *     // ... data to create a System_metrics
     *   }
     * })
     * 
     */
    create<T extends system_metricsCreateArgs>(args: SelectSubset<T, system_metricsCreateArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many System_metrics.
     * @param {system_metricsCreateManyArgs} args - Arguments to create many System_metrics.
     * @example
     * // Create many System_metrics
     * const system_metrics = await prisma.system_metrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends system_metricsCreateManyArgs>(args?: SelectSubset<T, system_metricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many System_metrics and returns the data saved in the database.
     * @param {system_metricsCreateManyAndReturnArgs} args - Arguments to create many System_metrics.
     * @example
     * // Create many System_metrics
     * const system_metrics = await prisma.system_metrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many System_metrics and only return the `id`
     * const system_metricsWithIdOnly = await prisma.system_metrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends system_metricsCreateManyAndReturnArgs>(args?: SelectSubset<T, system_metricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a System_metrics.
     * @param {system_metricsDeleteArgs} args - Arguments to delete one System_metrics.
     * @example
     * // Delete one System_metrics
     * const System_metrics = await prisma.system_metrics.delete({
     *   where: {
     *     // ... filter to delete one System_metrics
     *   }
     * })
     * 
     */
    delete<T extends system_metricsDeleteArgs>(args: SelectSubset<T, system_metricsDeleteArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one System_metrics.
     * @param {system_metricsUpdateArgs} args - Arguments to update one System_metrics.
     * @example
     * // Update one System_metrics
     * const system_metrics = await prisma.system_metrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends system_metricsUpdateArgs>(args: SelectSubset<T, system_metricsUpdateArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more System_metrics.
     * @param {system_metricsDeleteManyArgs} args - Arguments to filter System_metrics to delete.
     * @example
     * // Delete a few System_metrics
     * const { count } = await prisma.system_metrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends system_metricsDeleteManyArgs>(args?: SelectSubset<T, system_metricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_metricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many System_metrics
     * const system_metrics = await prisma.system_metrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends system_metricsUpdateManyArgs>(args: SelectSubset<T, system_metricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_metrics and returns the data updated in the database.
     * @param {system_metricsUpdateManyAndReturnArgs} args - Arguments to update many System_metrics.
     * @example
     * // Update many System_metrics
     * const system_metrics = await prisma.system_metrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more System_metrics and only return the `id`
     * const system_metricsWithIdOnly = await prisma.system_metrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends system_metricsUpdateManyAndReturnArgs>(args: SelectSubset<T, system_metricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one System_metrics.
     * @param {system_metricsUpsertArgs} args - Arguments to update or create a System_metrics.
     * @example
     * // Update or create a System_metrics
     * const system_metrics = await prisma.system_metrics.upsert({
     *   create: {
     *     // ... data to create a System_metrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the System_metrics we want to update
     *   }
     * })
     */
    upsert<T extends system_metricsUpsertArgs>(args: SelectSubset<T, system_metricsUpsertArgs<ExtArgs>>): Prisma__system_metricsClient<$Result.GetResult<Prisma.$system_metricsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of System_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_metricsCountArgs} args - Arguments to filter System_metrics to count.
     * @example
     * // Count the number of System_metrics
     * const count = await prisma.system_metrics.count({
     *   where: {
     *     // ... the filter for the System_metrics we want to count
     *   }
     * })
    **/
    count<T extends system_metricsCountArgs>(
      args?: Subset<T, system_metricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], System_metricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a System_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_metricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends System_metricsAggregateArgs>(args: Subset<T, System_metricsAggregateArgs>): Prisma.PrismaPromise<GetSystem_metricsAggregateType<T>>

    /**
     * Group by System_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_metricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends system_metricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: system_metricsGroupByArgs['orderBy'] }
        : { orderBy?: system_metricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, system_metricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystem_metricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the system_metrics model
   */
  readonly fields: system_metricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for system_metrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__system_metricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the system_metrics model
   */ 
  interface system_metricsFieldRefs {
    readonly id: FieldRef<"system_metrics", 'Int'>
    readonly timestamp: FieldRef<"system_metrics", 'DateTime'>
    readonly sensor_name: FieldRef<"system_metrics", 'String'>
    readonly value_type: FieldRef<"system_metrics", 'String'>
    readonly value: FieldRef<"system_metrics", 'Float'>
    readonly host: FieldRef<"system_metrics", 'String'>
    readonly min: FieldRef<"system_metrics", 'String'>
    readonly max: FieldRef<"system_metrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * system_metrics findUnique
   */
  export type system_metricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * Filter, which system_metrics to fetch.
     */
    where: system_metricsWhereUniqueInput
  }

  /**
   * system_metrics findUniqueOrThrow
   */
  export type system_metricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * Filter, which system_metrics to fetch.
     */
    where: system_metricsWhereUniqueInput
  }

  /**
   * system_metrics findFirst
   */
  export type system_metricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * Filter, which system_metrics to fetch.
     */
    where?: system_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_metrics to fetch.
     */
    orderBy?: system_metricsOrderByWithRelationInput | system_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_metrics.
     */
    cursor?: system_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_metrics.
     */
    distinct?: System_metricsScalarFieldEnum | System_metricsScalarFieldEnum[]
  }

  /**
   * system_metrics findFirstOrThrow
   */
  export type system_metricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * Filter, which system_metrics to fetch.
     */
    where?: system_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_metrics to fetch.
     */
    orderBy?: system_metricsOrderByWithRelationInput | system_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_metrics.
     */
    cursor?: system_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_metrics.
     */
    distinct?: System_metricsScalarFieldEnum | System_metricsScalarFieldEnum[]
  }

  /**
   * system_metrics findMany
   */
  export type system_metricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * Filter, which system_metrics to fetch.
     */
    where?: system_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_metrics to fetch.
     */
    orderBy?: system_metricsOrderByWithRelationInput | system_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing system_metrics.
     */
    cursor?: system_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_metrics.
     */
    skip?: number
    distinct?: System_metricsScalarFieldEnum | System_metricsScalarFieldEnum[]
  }

  /**
   * system_metrics create
   */
  export type system_metricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * The data needed to create a system_metrics.
     */
    data: XOR<system_metricsCreateInput, system_metricsUncheckedCreateInput>
  }

  /**
   * system_metrics createMany
   */
  export type system_metricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many system_metrics.
     */
    data: system_metricsCreateManyInput | system_metricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * system_metrics createManyAndReturn
   */
  export type system_metricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * The data used to create many system_metrics.
     */
    data: system_metricsCreateManyInput | system_metricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * system_metrics update
   */
  export type system_metricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * The data needed to update a system_metrics.
     */
    data: XOR<system_metricsUpdateInput, system_metricsUncheckedUpdateInput>
    /**
     * Choose, which system_metrics to update.
     */
    where: system_metricsWhereUniqueInput
  }

  /**
   * system_metrics updateMany
   */
  export type system_metricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update system_metrics.
     */
    data: XOR<system_metricsUpdateManyMutationInput, system_metricsUncheckedUpdateManyInput>
    /**
     * Filter which system_metrics to update
     */
    where?: system_metricsWhereInput
    /**
     * Limit how many system_metrics to update.
     */
    limit?: number
  }

  /**
   * system_metrics updateManyAndReturn
   */
  export type system_metricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * The data used to update system_metrics.
     */
    data: XOR<system_metricsUpdateManyMutationInput, system_metricsUncheckedUpdateManyInput>
    /**
     * Filter which system_metrics to update
     */
    where?: system_metricsWhereInput
    /**
     * Limit how many system_metrics to update.
     */
    limit?: number
  }

  /**
   * system_metrics upsert
   */
  export type system_metricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * The filter to search for the system_metrics to update in case it exists.
     */
    where: system_metricsWhereUniqueInput
    /**
     * In case the system_metrics found by the `where` argument doesn't exist, create a new system_metrics with this data.
     */
    create: XOR<system_metricsCreateInput, system_metricsUncheckedCreateInput>
    /**
     * In case the system_metrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<system_metricsUpdateInput, system_metricsUncheckedUpdateInput>
  }

  /**
   * system_metrics delete
   */
  export type system_metricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
    /**
     * Filter which system_metrics to delete.
     */
    where: system_metricsWhereUniqueInput
  }

  /**
   * system_metrics deleteMany
   */
  export type system_metricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_metrics to delete
     */
    where?: system_metricsWhereInput
    /**
     * Limit how many system_metrics to delete.
     */
    limit?: number
  }

  /**
   * system_metrics without action
   */
  export type system_metricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_metrics
     */
    select?: system_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_metrics
     */
    omit?: system_metricsOmit<ExtArgs> | null
  }


  /**
   * Model diskmetric
   */

  export type AggregateDiskmetric = {
    _count: DiskmetricCountAggregateOutputType | null
    _avg: DiskmetricAvgAggregateOutputType | null
    _sum: DiskmetricSumAggregateOutputType | null
    _min: DiskmetricMinAggregateOutputType | null
    _max: DiskmetricMaxAggregateOutputType | null
  }

  export type DiskmetricAvgAggregateOutputType = {
    id: number | null
    totalgb: number | null
    usedgb: number | null
    freegb: number | null
  }

  export type DiskmetricSumAggregateOutputType = {
    id: number | null
    totalgb: number | null
    usedgb: number | null
    freegb: number | null
  }

  export type DiskmetricMinAggregateOutputType = {
    id: number | null
    host: string | null
    name: string | null
    label: string | null
    totalgb: number | null
    usedgb: number | null
    freegb: number | null
    timestamp: Date | null
  }

  export type DiskmetricMaxAggregateOutputType = {
    id: number | null
    host: string | null
    name: string | null
    label: string | null
    totalgb: number | null
    usedgb: number | null
    freegb: number | null
    timestamp: Date | null
  }

  export type DiskmetricCountAggregateOutputType = {
    id: number
    host: number
    name: number
    label: number
    totalgb: number
    usedgb: number
    freegb: number
    timestamp: number
    _all: number
  }


  export type DiskmetricAvgAggregateInputType = {
    id?: true
    totalgb?: true
    usedgb?: true
    freegb?: true
  }

  export type DiskmetricSumAggregateInputType = {
    id?: true
    totalgb?: true
    usedgb?: true
    freegb?: true
  }

  export type DiskmetricMinAggregateInputType = {
    id?: true
    host?: true
    name?: true
    label?: true
    totalgb?: true
    usedgb?: true
    freegb?: true
    timestamp?: true
  }

  export type DiskmetricMaxAggregateInputType = {
    id?: true
    host?: true
    name?: true
    label?: true
    totalgb?: true
    usedgb?: true
    freegb?: true
    timestamp?: true
  }

  export type DiskmetricCountAggregateInputType = {
    id?: true
    host?: true
    name?: true
    label?: true
    totalgb?: true
    usedgb?: true
    freegb?: true
    timestamp?: true
    _all?: true
  }

  export type DiskmetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diskmetric to aggregate.
     */
    where?: diskmetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskmetrics to fetch.
     */
    orderBy?: diskmetricOrderByWithRelationInput | diskmetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diskmetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskmetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskmetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diskmetrics
    **/
    _count?: true | DiskmetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiskmetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiskmetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiskmetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiskmetricMaxAggregateInputType
  }

  export type GetDiskmetricAggregateType<T extends DiskmetricAggregateArgs> = {
        [P in keyof T & keyof AggregateDiskmetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiskmetric[P]>
      : GetScalarType<T[P], AggregateDiskmetric[P]>
  }




  export type diskmetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diskmetricWhereInput
    orderBy?: diskmetricOrderByWithAggregationInput | diskmetricOrderByWithAggregationInput[]
    by: DiskmetricScalarFieldEnum[] | DiskmetricScalarFieldEnum
    having?: diskmetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiskmetricCountAggregateInputType | true
    _avg?: DiskmetricAvgAggregateInputType
    _sum?: DiskmetricSumAggregateInputType
    _min?: DiskmetricMinAggregateInputType
    _max?: DiskmetricMaxAggregateInputType
  }

  export type DiskmetricGroupByOutputType = {
    id: number
    host: string
    name: string
    label: string | null
    totalgb: number
    usedgb: number
    freegb: number
    timestamp: Date
    _count: DiskmetricCountAggregateOutputType | null
    _avg: DiskmetricAvgAggregateOutputType | null
    _sum: DiskmetricSumAggregateOutputType | null
    _min: DiskmetricMinAggregateOutputType | null
    _max: DiskmetricMaxAggregateOutputType | null
  }

  type GetDiskmetricGroupByPayload<T extends diskmetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiskmetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiskmetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiskmetricGroupByOutputType[P]>
            : GetScalarType<T[P], DiskmetricGroupByOutputType[P]>
        }
      >
    >


  export type diskmetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    host?: boolean
    name?: boolean
    label?: boolean
    totalgb?: boolean
    usedgb?: boolean
    freegb?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["diskmetric"]>

  export type diskmetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    host?: boolean
    name?: boolean
    label?: boolean
    totalgb?: boolean
    usedgb?: boolean
    freegb?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["diskmetric"]>

  export type diskmetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    host?: boolean
    name?: boolean
    label?: boolean
    totalgb?: boolean
    usedgb?: boolean
    freegb?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["diskmetric"]>

  export type diskmetricSelectScalar = {
    id?: boolean
    host?: boolean
    name?: boolean
    label?: boolean
    totalgb?: boolean
    usedgb?: boolean
    freegb?: boolean
    timestamp?: boolean
  }

  export type diskmetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "host" | "name" | "label" | "totalgb" | "usedgb" | "freegb" | "timestamp", ExtArgs["result"]["diskmetric"]>

  export type $diskmetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diskmetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      host: string
      name: string
      label: string | null
      totalgb: number
      usedgb: number
      freegb: number
      timestamp: Date
    }, ExtArgs["result"]["diskmetric"]>
    composites: {}
  }

  type diskmetricGetPayload<S extends boolean | null | undefined | diskmetricDefaultArgs> = $Result.GetResult<Prisma.$diskmetricPayload, S>

  type diskmetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<diskmetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiskmetricCountAggregateInputType | true
    }

  export interface diskmetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diskmetric'], meta: { name: 'diskmetric' } }
    /**
     * Find zero or one Diskmetric that matches the filter.
     * @param {diskmetricFindUniqueArgs} args - Arguments to find a Diskmetric
     * @example
     * // Get one Diskmetric
     * const diskmetric = await prisma.diskmetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends diskmetricFindUniqueArgs>(args: SelectSubset<T, diskmetricFindUniqueArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Diskmetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {diskmetricFindUniqueOrThrowArgs} args - Arguments to find a Diskmetric
     * @example
     * // Get one Diskmetric
     * const diskmetric = await prisma.diskmetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends diskmetricFindUniqueOrThrowArgs>(args: SelectSubset<T, diskmetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Diskmetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskmetricFindFirstArgs} args - Arguments to find a Diskmetric
     * @example
     * // Get one Diskmetric
     * const diskmetric = await prisma.diskmetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends diskmetricFindFirstArgs>(args?: SelectSubset<T, diskmetricFindFirstArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Diskmetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskmetricFindFirstOrThrowArgs} args - Arguments to find a Diskmetric
     * @example
     * // Get one Diskmetric
     * const diskmetric = await prisma.diskmetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends diskmetricFindFirstOrThrowArgs>(args?: SelectSubset<T, diskmetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Diskmetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskmetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diskmetrics
     * const diskmetrics = await prisma.diskmetric.findMany()
     * 
     * // Get first 10 Diskmetrics
     * const diskmetrics = await prisma.diskmetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diskmetricWithIdOnly = await prisma.diskmetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends diskmetricFindManyArgs>(args?: SelectSubset<T, diskmetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Diskmetric.
     * @param {diskmetricCreateArgs} args - Arguments to create a Diskmetric.
     * @example
     * // Create one Diskmetric
     * const Diskmetric = await prisma.diskmetric.create({
     *   data: {
     *     // ... data to create a Diskmetric
     *   }
     * })
     * 
     */
    create<T extends diskmetricCreateArgs>(args: SelectSubset<T, diskmetricCreateArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Diskmetrics.
     * @param {diskmetricCreateManyArgs} args - Arguments to create many Diskmetrics.
     * @example
     * // Create many Diskmetrics
     * const diskmetric = await prisma.diskmetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends diskmetricCreateManyArgs>(args?: SelectSubset<T, diskmetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diskmetrics and returns the data saved in the database.
     * @param {diskmetricCreateManyAndReturnArgs} args - Arguments to create many Diskmetrics.
     * @example
     * // Create many Diskmetrics
     * const diskmetric = await prisma.diskmetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diskmetrics and only return the `id`
     * const diskmetricWithIdOnly = await prisma.diskmetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends diskmetricCreateManyAndReturnArgs>(args?: SelectSubset<T, diskmetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Diskmetric.
     * @param {diskmetricDeleteArgs} args - Arguments to delete one Diskmetric.
     * @example
     * // Delete one Diskmetric
     * const Diskmetric = await prisma.diskmetric.delete({
     *   where: {
     *     // ... filter to delete one Diskmetric
     *   }
     * })
     * 
     */
    delete<T extends diskmetricDeleteArgs>(args: SelectSubset<T, diskmetricDeleteArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Diskmetric.
     * @param {diskmetricUpdateArgs} args - Arguments to update one Diskmetric.
     * @example
     * // Update one Diskmetric
     * const diskmetric = await prisma.diskmetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends diskmetricUpdateArgs>(args: SelectSubset<T, diskmetricUpdateArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Diskmetrics.
     * @param {diskmetricDeleteManyArgs} args - Arguments to filter Diskmetrics to delete.
     * @example
     * // Delete a few Diskmetrics
     * const { count } = await prisma.diskmetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends diskmetricDeleteManyArgs>(args?: SelectSubset<T, diskmetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diskmetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskmetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diskmetrics
     * const diskmetric = await prisma.diskmetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends diskmetricUpdateManyArgs>(args: SelectSubset<T, diskmetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diskmetrics and returns the data updated in the database.
     * @param {diskmetricUpdateManyAndReturnArgs} args - Arguments to update many Diskmetrics.
     * @example
     * // Update many Diskmetrics
     * const diskmetric = await prisma.diskmetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diskmetrics and only return the `id`
     * const diskmetricWithIdOnly = await prisma.diskmetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends diskmetricUpdateManyAndReturnArgs>(args: SelectSubset<T, diskmetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Diskmetric.
     * @param {diskmetricUpsertArgs} args - Arguments to update or create a Diskmetric.
     * @example
     * // Update or create a Diskmetric
     * const diskmetric = await prisma.diskmetric.upsert({
     *   create: {
     *     // ... data to create a Diskmetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diskmetric we want to update
     *   }
     * })
     */
    upsert<T extends diskmetricUpsertArgs>(args: SelectSubset<T, diskmetricUpsertArgs<ExtArgs>>): Prisma__diskmetricClient<$Result.GetResult<Prisma.$diskmetricPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Diskmetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskmetricCountArgs} args - Arguments to filter Diskmetrics to count.
     * @example
     * // Count the number of Diskmetrics
     * const count = await prisma.diskmetric.count({
     *   where: {
     *     // ... the filter for the Diskmetrics we want to count
     *   }
     * })
    **/
    count<T extends diskmetricCountArgs>(
      args?: Subset<T, diskmetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiskmetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diskmetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiskmetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiskmetricAggregateArgs>(args: Subset<T, DiskmetricAggregateArgs>): Prisma.PrismaPromise<GetDiskmetricAggregateType<T>>

    /**
     * Group by Diskmetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diskmetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diskmetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diskmetricGroupByArgs['orderBy'] }
        : { orderBy?: diskmetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diskmetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiskmetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diskmetric model
   */
  readonly fields: diskmetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diskmetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diskmetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the diskmetric model
   */ 
  interface diskmetricFieldRefs {
    readonly id: FieldRef<"diskmetric", 'Int'>
    readonly host: FieldRef<"diskmetric", 'String'>
    readonly name: FieldRef<"diskmetric", 'String'>
    readonly label: FieldRef<"diskmetric", 'String'>
    readonly totalgb: FieldRef<"diskmetric", 'Float'>
    readonly usedgb: FieldRef<"diskmetric", 'Float'>
    readonly freegb: FieldRef<"diskmetric", 'Float'>
    readonly timestamp: FieldRef<"diskmetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * diskmetric findUnique
   */
  export type diskmetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * Filter, which diskmetric to fetch.
     */
    where: diskmetricWhereUniqueInput
  }

  /**
   * diskmetric findUniqueOrThrow
   */
  export type diskmetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * Filter, which diskmetric to fetch.
     */
    where: diskmetricWhereUniqueInput
  }

  /**
   * diskmetric findFirst
   */
  export type diskmetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * Filter, which diskmetric to fetch.
     */
    where?: diskmetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskmetrics to fetch.
     */
    orderBy?: diskmetricOrderByWithRelationInput | diskmetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diskmetrics.
     */
    cursor?: diskmetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskmetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskmetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diskmetrics.
     */
    distinct?: DiskmetricScalarFieldEnum | DiskmetricScalarFieldEnum[]
  }

  /**
   * diskmetric findFirstOrThrow
   */
  export type diskmetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * Filter, which diskmetric to fetch.
     */
    where?: diskmetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskmetrics to fetch.
     */
    orderBy?: diskmetricOrderByWithRelationInput | diskmetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diskmetrics.
     */
    cursor?: diskmetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskmetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskmetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diskmetrics.
     */
    distinct?: DiskmetricScalarFieldEnum | DiskmetricScalarFieldEnum[]
  }

  /**
   * diskmetric findMany
   */
  export type diskmetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * Filter, which diskmetrics to fetch.
     */
    where?: diskmetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diskmetrics to fetch.
     */
    orderBy?: diskmetricOrderByWithRelationInput | diskmetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diskmetrics.
     */
    cursor?: diskmetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diskmetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diskmetrics.
     */
    skip?: number
    distinct?: DiskmetricScalarFieldEnum | DiskmetricScalarFieldEnum[]
  }

  /**
   * diskmetric create
   */
  export type diskmetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * The data needed to create a diskmetric.
     */
    data: XOR<diskmetricCreateInput, diskmetricUncheckedCreateInput>
  }

  /**
   * diskmetric createMany
   */
  export type diskmetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diskmetrics.
     */
    data: diskmetricCreateManyInput | diskmetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diskmetric createManyAndReturn
   */
  export type diskmetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * The data used to create many diskmetrics.
     */
    data: diskmetricCreateManyInput | diskmetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diskmetric update
   */
  export type diskmetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * The data needed to update a diskmetric.
     */
    data: XOR<diskmetricUpdateInput, diskmetricUncheckedUpdateInput>
    /**
     * Choose, which diskmetric to update.
     */
    where: diskmetricWhereUniqueInput
  }

  /**
   * diskmetric updateMany
   */
  export type diskmetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diskmetrics.
     */
    data: XOR<diskmetricUpdateManyMutationInput, diskmetricUncheckedUpdateManyInput>
    /**
     * Filter which diskmetrics to update
     */
    where?: diskmetricWhereInput
    /**
     * Limit how many diskmetrics to update.
     */
    limit?: number
  }

  /**
   * diskmetric updateManyAndReturn
   */
  export type diskmetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * The data used to update diskmetrics.
     */
    data: XOR<diskmetricUpdateManyMutationInput, diskmetricUncheckedUpdateManyInput>
    /**
     * Filter which diskmetrics to update
     */
    where?: diskmetricWhereInput
    /**
     * Limit how many diskmetrics to update.
     */
    limit?: number
  }

  /**
   * diskmetric upsert
   */
  export type diskmetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * The filter to search for the diskmetric to update in case it exists.
     */
    where: diskmetricWhereUniqueInput
    /**
     * In case the diskmetric found by the `where` argument doesn't exist, create a new diskmetric with this data.
     */
    create: XOR<diskmetricCreateInput, diskmetricUncheckedCreateInput>
    /**
     * In case the diskmetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diskmetricUpdateInput, diskmetricUncheckedUpdateInput>
  }

  /**
   * diskmetric delete
   */
  export type diskmetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
    /**
     * Filter which diskmetric to delete.
     */
    where: diskmetricWhereUniqueInput
  }

  /**
   * diskmetric deleteMany
   */
  export type diskmetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diskmetrics to delete
     */
    where?: diskmetricWhereInput
    /**
     * Limit how many diskmetrics to delete.
     */
    limit?: number
  }

  /**
   * diskmetric without action
   */
  export type diskmetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diskmetric
     */
    select?: diskmetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diskmetric
     */
    omit?: diskmetricOmit<ExtArgs> | null
  }


  /**
   * Model notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    title: string | null
    time: Date | null
    description: string | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    time: Date | null
    description: string | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    title: number
    time: number
    description: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    title?: true
    time?: true
    description?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    title?: true
    time?: true
    description?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    title?: true
    time?: true
    description?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to aggregate.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notesWhereInput
    orderBy?: notesOrderByWithAggregationInput | notesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    title: string
    time: Date
    description: string
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    time?: boolean
    description?: boolean
  }, ExtArgs["result"]["notes"]>

  export type notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    time?: boolean
    description?: boolean
  }, ExtArgs["result"]["notes"]>

  export type notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    time?: boolean
    description?: boolean
  }, ExtArgs["result"]["notes"]>

  export type notesSelectScalar = {
    id?: boolean
    title?: boolean
    time?: boolean
    description?: boolean
  }

  export type notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "time" | "description", ExtArgs["result"]["notes"]>

  export type $notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      time: Date
      description: string
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type notesGetPayload<S extends boolean | null | undefined | notesDefaultArgs> = $Result.GetResult<Prisma.$notesPayload, S>

  type notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notes'], meta: { name: 'notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {notesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notesFindUniqueArgs>(args: SelectSubset<T, notesFindUniqueArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notesFindUniqueOrThrowArgs>(args: SelectSubset<T, notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notesFindFirstArgs>(args?: SelectSubset<T, notesFindFirstArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notesFindFirstOrThrowArgs>(args?: SelectSubset<T, notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notesFindManyArgs>(args?: SelectSubset<T, notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notes.
     * @param {notesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends notesCreateArgs>(args: SelectSubset<T, notesCreateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notes.
     * @param {notesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notesCreateManyArgs>(args?: SelectSubset<T, notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {notesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notesCreateManyAndReturnArgs>(args?: SelectSubset<T, notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notes.
     * @param {notesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends notesDeleteArgs>(args: SelectSubset<T, notesDeleteArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notes.
     * @param {notesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notesUpdateArgs>(args: SelectSubset<T, notesUpdateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notes.
     * @param {notesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notesDeleteManyArgs>(args?: SelectSubset<T, notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notesUpdateManyArgs>(args: SelectSubset<T, notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {notesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notesUpdateManyAndReturnArgs>(args: SelectSubset<T, notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notes.
     * @param {notesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends notesUpsertArgs>(args: SelectSubset<T, notesUpsertArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends notesCountArgs>(
      args?: Subset<T, notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notesGroupByArgs['orderBy'] }
        : { orderBy?: notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notes model
   */
  readonly fields: notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notes model
   */ 
  interface notesFieldRefs {
    readonly id: FieldRef<"notes", 'Int'>
    readonly title: FieldRef<"notes", 'String'>
    readonly time: FieldRef<"notes", 'DateTime'>
    readonly description: FieldRef<"notes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notes findUnique
   */
  export type notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findUniqueOrThrow
   */
  export type notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findFirst
   */
  export type notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findFirstOrThrow
   */
  export type notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findMany
   */
  export type notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes create
   */
  export type notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data needed to create a notes.
     */
    data: XOR<notesCreateInput, notesUncheckedCreateInput>
  }

  /**
   * notes createMany
   */
  export type notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notes createManyAndReturn
   */
  export type notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notes update
   */
  export type notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data needed to update a notes.
     */
    data: XOR<notesUpdateInput, notesUncheckedUpdateInput>
    /**
     * Choose, which notes to update.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes updateMany
   */
  export type notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * notes updateManyAndReturn
   */
  export type notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * notes upsert
   */
  export type notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The filter to search for the notes to update in case it exists.
     */
    where: notesWhereUniqueInput
    /**
     * In case the notes found by the `where` argument doesn't exist, create a new notes with this data.
     */
    create: XOR<notesCreateInput, notesUncheckedCreateInput>
    /**
     * In case the notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notesUpdateInput, notesUncheckedUpdateInput>
  }

  /**
   * notes delete
   */
  export type notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter which notes to delete.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes deleteMany
   */
  export type notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to delete
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to delete.
     */
    limit?: number
  }

  /**
   * notes without action
   */
  export type notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
  }


  /**
   * Model devices
   */

  export type AggregateDevices = {
    _count: DevicesCountAggregateOutputType | null
    _avg: DevicesAvgAggregateOutputType | null
    _sum: DevicesSumAggregateOutputType | null
    _min: DevicesMinAggregateOutputType | null
    _max: DevicesMaxAggregateOutputType | null
  }

  export type DevicesAvgAggregateOutputType = {
    id: number | null
  }

  export type DevicesSumAggregateOutputType = {
    id: number | null
  }

  export type DevicesMinAggregateOutputType = {
    id: number | null
    name: string | null
    ip_address: string | null
    mac_address: string | null
    password: string | null
    time: Date | null
    notes: string | null
    status: string | null
  }

  export type DevicesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ip_address: string | null
    mac_address: string | null
    password: string | null
    time: Date | null
    notes: string | null
    status: string | null
  }

  export type DevicesCountAggregateOutputType = {
    id: number
    name: number
    ip_address: number
    mac_address: number
    password: number
    time: number
    notes: number
    status: number
    _all: number
  }


  export type DevicesAvgAggregateInputType = {
    id?: true
  }

  export type DevicesSumAggregateInputType = {
    id?: true
  }

  export type DevicesMinAggregateInputType = {
    id?: true
    name?: true
    ip_address?: true
    mac_address?: true
    password?: true
    time?: true
    notes?: true
    status?: true
  }

  export type DevicesMaxAggregateInputType = {
    id?: true
    name?: true
    ip_address?: true
    mac_address?: true
    password?: true
    time?: true
    notes?: true
    status?: true
  }

  export type DevicesCountAggregateInputType = {
    id?: true
    name?: true
    ip_address?: true
    mac_address?: true
    password?: true
    time?: true
    notes?: true
    status?: true
    _all?: true
  }

  export type DevicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which devices to aggregate.
     */
    where?: devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: devicesOrderByWithRelationInput | devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned devices
    **/
    _count?: true | DevicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DevicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DevicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevicesMaxAggregateInputType
  }

  export type GetDevicesAggregateType<T extends DevicesAggregateArgs> = {
        [P in keyof T & keyof AggregateDevices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevices[P]>
      : GetScalarType<T[P], AggregateDevices[P]>
  }




  export type devicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: devicesWhereInput
    orderBy?: devicesOrderByWithAggregationInput | devicesOrderByWithAggregationInput[]
    by: DevicesScalarFieldEnum[] | DevicesScalarFieldEnum
    having?: devicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevicesCountAggregateInputType | true
    _avg?: DevicesAvgAggregateInputType
    _sum?: DevicesSumAggregateInputType
    _min?: DevicesMinAggregateInputType
    _max?: DevicesMaxAggregateInputType
  }

  export type DevicesGroupByOutputType = {
    id: number
    name: string
    ip_address: string | null
    mac_address: string | null
    password: string | null
    time: Date
    notes: string
    status: string
    _count: DevicesCountAggregateOutputType | null
    _avg: DevicesAvgAggregateOutputType | null
    _sum: DevicesSumAggregateOutputType | null
    _min: DevicesMinAggregateOutputType | null
    _max: DevicesMaxAggregateOutputType | null
  }

  type GetDevicesGroupByPayload<T extends devicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DevicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevicesGroupByOutputType[P]>
            : GetScalarType<T[P], DevicesGroupByOutputType[P]>
        }
      >
    >


  export type devicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ip_address?: boolean
    mac_address?: boolean
    password?: boolean
    time?: boolean
    notes?: boolean
    status?: boolean
    users?: boolean | devices$usersArgs<ExtArgs>
    SupportTicket?: boolean | devices$SupportTicketArgs<ExtArgs>
    _count?: boolean | DevicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devices"]>

  export type devicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ip_address?: boolean
    mac_address?: boolean
    password?: boolean
    time?: boolean
    notes?: boolean
    status?: boolean
  }, ExtArgs["result"]["devices"]>

  export type devicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ip_address?: boolean
    mac_address?: boolean
    password?: boolean
    time?: boolean
    notes?: boolean
    status?: boolean
  }, ExtArgs["result"]["devices"]>

  export type devicesSelectScalar = {
    id?: boolean
    name?: boolean
    ip_address?: boolean
    mac_address?: boolean
    password?: boolean
    time?: boolean
    notes?: boolean
    status?: boolean
  }

  export type devicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ip_address" | "mac_address" | "password" | "time" | "notes" | "status", ExtArgs["result"]["devices"]>
  export type devicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | devices$usersArgs<ExtArgs>
    SupportTicket?: boolean | devices$SupportTicketArgs<ExtArgs>
    _count?: boolean | DevicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type devicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type devicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $devicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "devices"
    objects: {
      users: Prisma.$DeviceUserPayload<ExtArgs>[]
      SupportTicket: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      ip_address: string | null
      mac_address: string | null
      password: string | null
      time: Date
      notes: string
      status: string
    }, ExtArgs["result"]["devices"]>
    composites: {}
  }

  type devicesGetPayload<S extends boolean | null | undefined | devicesDefaultArgs> = $Result.GetResult<Prisma.$devicesPayload, S>

  type devicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<devicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DevicesCountAggregateInputType | true
    }

  export interface devicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['devices'], meta: { name: 'devices' } }
    /**
     * Find zero or one Devices that matches the filter.
     * @param {devicesFindUniqueArgs} args - Arguments to find a Devices
     * @example
     * // Get one Devices
     * const devices = await prisma.devices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends devicesFindUniqueArgs>(args: SelectSubset<T, devicesFindUniqueArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Devices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {devicesFindUniqueOrThrowArgs} args - Arguments to find a Devices
     * @example
     * // Get one Devices
     * const devices = await prisma.devices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends devicesFindUniqueOrThrowArgs>(args: SelectSubset<T, devicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {devicesFindFirstArgs} args - Arguments to find a Devices
     * @example
     * // Get one Devices
     * const devices = await prisma.devices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends devicesFindFirstArgs>(args?: SelectSubset<T, devicesFindFirstArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Devices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {devicesFindFirstOrThrowArgs} args - Arguments to find a Devices
     * @example
     * // Get one Devices
     * const devices = await prisma.devices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends devicesFindFirstOrThrowArgs>(args?: SelectSubset<T, devicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {devicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.devices.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.devices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const devicesWithIdOnly = await prisma.devices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends devicesFindManyArgs>(args?: SelectSubset<T, devicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Devices.
     * @param {devicesCreateArgs} args - Arguments to create a Devices.
     * @example
     * // Create one Devices
     * const Devices = await prisma.devices.create({
     *   data: {
     *     // ... data to create a Devices
     *   }
     * })
     * 
     */
    create<T extends devicesCreateArgs>(args: SelectSubset<T, devicesCreateArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Devices.
     * @param {devicesCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const devices = await prisma.devices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends devicesCreateManyArgs>(args?: SelectSubset<T, devicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {devicesCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const devices = await prisma.devices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const devicesWithIdOnly = await prisma.devices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends devicesCreateManyAndReturnArgs>(args?: SelectSubset<T, devicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Devices.
     * @param {devicesDeleteArgs} args - Arguments to delete one Devices.
     * @example
     * // Delete one Devices
     * const Devices = await prisma.devices.delete({
     *   where: {
     *     // ... filter to delete one Devices
     *   }
     * })
     * 
     */
    delete<T extends devicesDeleteArgs>(args: SelectSubset<T, devicesDeleteArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Devices.
     * @param {devicesUpdateArgs} args - Arguments to update one Devices.
     * @example
     * // Update one Devices
     * const devices = await prisma.devices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends devicesUpdateArgs>(args: SelectSubset<T, devicesUpdateArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Devices.
     * @param {devicesDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.devices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends devicesDeleteManyArgs>(args?: SelectSubset<T, devicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {devicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const devices = await prisma.devices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends devicesUpdateManyArgs>(args: SelectSubset<T, devicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {devicesUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const devices = await prisma.devices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const devicesWithIdOnly = await prisma.devices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends devicesUpdateManyAndReturnArgs>(args: SelectSubset<T, devicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Devices.
     * @param {devicesUpsertArgs} args - Arguments to update or create a Devices.
     * @example
     * // Update or create a Devices
     * const devices = await prisma.devices.upsert({
     *   create: {
     *     // ... data to create a Devices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Devices we want to update
     *   }
     * })
     */
    upsert<T extends devicesUpsertArgs>(args: SelectSubset<T, devicesUpsertArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {devicesCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.devices.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends devicesCountArgs>(
      args?: Subset<T, devicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevicesAggregateArgs>(args: Subset<T, DevicesAggregateArgs>): Prisma.PrismaPromise<GetDevicesAggregateType<T>>

    /**
     * Group by Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {devicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends devicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: devicesGroupByArgs['orderBy'] }
        : { orderBy?: devicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, devicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the devices model
   */
  readonly fields: devicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for devices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__devicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends devices$usersArgs<ExtArgs> = {}>(args?: Subset<T, devices$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    SupportTicket<T extends devices$SupportTicketArgs<ExtArgs> = {}>(args?: Subset<T, devices$SupportTicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the devices model
   */ 
  interface devicesFieldRefs {
    readonly id: FieldRef<"devices", 'Int'>
    readonly name: FieldRef<"devices", 'String'>
    readonly ip_address: FieldRef<"devices", 'String'>
    readonly mac_address: FieldRef<"devices", 'String'>
    readonly password: FieldRef<"devices", 'String'>
    readonly time: FieldRef<"devices", 'DateTime'>
    readonly notes: FieldRef<"devices", 'String'>
    readonly status: FieldRef<"devices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * devices findUnique
   */
  export type devicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where: devicesWhereUniqueInput
  }

  /**
   * devices findUniqueOrThrow
   */
  export type devicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where: devicesWhereUniqueInput
  }

  /**
   * devices findFirst
   */
  export type devicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where?: devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: devicesOrderByWithRelationInput | devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for devices.
     */
    cursor?: devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of devices.
     */
    distinct?: DevicesScalarFieldEnum | DevicesScalarFieldEnum[]
  }

  /**
   * devices findFirstOrThrow
   */
  export type devicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where?: devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: devicesOrderByWithRelationInput | devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for devices.
     */
    cursor?: devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of devices.
     */
    distinct?: DevicesScalarFieldEnum | DevicesScalarFieldEnum[]
  }

  /**
   * devices findMany
   */
  export type devicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where?: devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: devicesOrderByWithRelationInput | devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing devices.
     */
    cursor?: devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    distinct?: DevicesScalarFieldEnum | DevicesScalarFieldEnum[]
  }

  /**
   * devices create
   */
  export type devicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * The data needed to create a devices.
     */
    data: XOR<devicesCreateInput, devicesUncheckedCreateInput>
  }

  /**
   * devices createMany
   */
  export type devicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many devices.
     */
    data: devicesCreateManyInput | devicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * devices createManyAndReturn
   */
  export type devicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * The data used to create many devices.
     */
    data: devicesCreateManyInput | devicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * devices update
   */
  export type devicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * The data needed to update a devices.
     */
    data: XOR<devicesUpdateInput, devicesUncheckedUpdateInput>
    /**
     * Choose, which devices to update.
     */
    where: devicesWhereUniqueInput
  }

  /**
   * devices updateMany
   */
  export type devicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update devices.
     */
    data: XOR<devicesUpdateManyMutationInput, devicesUncheckedUpdateManyInput>
    /**
     * Filter which devices to update
     */
    where?: devicesWhereInput
    /**
     * Limit how many devices to update.
     */
    limit?: number
  }

  /**
   * devices updateManyAndReturn
   */
  export type devicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * The data used to update devices.
     */
    data: XOR<devicesUpdateManyMutationInput, devicesUncheckedUpdateManyInput>
    /**
     * Filter which devices to update
     */
    where?: devicesWhereInput
    /**
     * Limit how many devices to update.
     */
    limit?: number
  }

  /**
   * devices upsert
   */
  export type devicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * The filter to search for the devices to update in case it exists.
     */
    where: devicesWhereUniqueInput
    /**
     * In case the devices found by the `where` argument doesn't exist, create a new devices with this data.
     */
    create: XOR<devicesCreateInput, devicesUncheckedCreateInput>
    /**
     * In case the devices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<devicesUpdateInput, devicesUncheckedUpdateInput>
  }

  /**
   * devices delete
   */
  export type devicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    /**
     * Filter which devices to delete.
     */
    where: devicesWhereUniqueInput
  }

  /**
   * devices deleteMany
   */
  export type devicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which devices to delete
     */
    where?: devicesWhereInput
    /**
     * Limit how many devices to delete.
     */
    limit?: number
  }

  /**
   * devices.users
   */
  export type devices$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    where?: DeviceUserWhereInput
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    cursor?: DeviceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * devices.SupportTicket
   */
  export type devices$SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * devices without action
   */
  export type devicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
  }


  /**
   * Model DeviceUser
   */

  export type AggregateDeviceUser = {
    _count: DeviceUserCountAggregateOutputType | null
    _avg: DeviceUserAvgAggregateOutputType | null
    _sum: DeviceUserSumAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  export type DeviceUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    deviceId: number | null
  }

  export type DeviceUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
    deviceId: number | null
  }

  export type DeviceUserMinAggregateOutputType = {
    id: number | null
    userId: number | null
    deviceId: number | null
    role: string | null
  }

  export type DeviceUserMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    deviceId: number | null
    role: string | null
  }

  export type DeviceUserCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    role: number
    _all: number
  }


  export type DeviceUserAvgAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
  }

  export type DeviceUserSumAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
  }

  export type DeviceUserMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    role?: true
  }

  export type DeviceUserMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    role?: true
  }

  export type DeviceUserCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    role?: true
    _all?: true
  }

  export type DeviceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceUser to aggregate.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceUsers
    **/
    _count?: true | DeviceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceUserMaxAggregateInputType
  }

  export type GetDeviceUserAggregateType<T extends DeviceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceUser[P]>
      : GetScalarType<T[P], AggregateDeviceUser[P]>
  }




  export type DeviceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceUserWhereInput
    orderBy?: DeviceUserOrderByWithAggregationInput | DeviceUserOrderByWithAggregationInput[]
    by: DeviceUserScalarFieldEnum[] | DeviceUserScalarFieldEnum
    having?: DeviceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceUserCountAggregateInputType | true
    _avg?: DeviceUserAvgAggregateInputType
    _sum?: DeviceUserSumAggregateInputType
    _min?: DeviceUserMinAggregateInputType
    _max?: DeviceUserMaxAggregateInputType
  }

  export type DeviceUserGroupByOutputType = {
    id: number
    userId: number
    deviceId: number
    role: string
    _count: DeviceUserCountAggregateOutputType | null
    _avg: DeviceUserAvgAggregateOutputType | null
    _sum: DeviceUserSumAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  type GetDeviceUserGroupByPayload<T extends DeviceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
        }
      >
    >


  export type DeviceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    role?: boolean
    device?: boolean | devicesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceUser"]>

  export type DeviceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    role?: boolean
    device?: boolean | devicesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceUser"]>

  export type DeviceUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    role?: boolean
    device?: boolean | devicesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceUser"]>

  export type DeviceUserSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    role?: boolean
  }

  export type DeviceUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceId" | "role", ExtArgs["result"]["deviceUser"]>
  export type DeviceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | devicesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | devicesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | devicesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceUser"
    objects: {
      device: Prisma.$devicesPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      deviceId: number
      role: string
    }, ExtArgs["result"]["deviceUser"]>
    composites: {}
  }

  type DeviceUserGetPayload<S extends boolean | null | undefined | DeviceUserDefaultArgs> = $Result.GetResult<Prisma.$DeviceUserPayload, S>

  type DeviceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceUserCountAggregateInputType | true
    }

  export interface DeviceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceUser'], meta: { name: 'DeviceUser' } }
    /**
     * Find zero or one DeviceUser that matches the filter.
     * @param {DeviceUserFindUniqueArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceUserFindUniqueArgs>(args: SelectSubset<T, DeviceUserFindUniqueArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DeviceUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceUserFindUniqueOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DeviceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceUserFindFirstArgs>(args?: SelectSubset<T, DeviceUserFindFirstArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DeviceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DeviceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany()
     * 
     * // Get first 10 DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceUserWithIdOnly = await prisma.deviceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceUserFindManyArgs>(args?: SelectSubset<T, DeviceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DeviceUser.
     * @param {DeviceUserCreateArgs} args - Arguments to create a DeviceUser.
     * @example
     * // Create one DeviceUser
     * const DeviceUser = await prisma.deviceUser.create({
     *   data: {
     *     // ... data to create a DeviceUser
     *   }
     * })
     * 
     */
    create<T extends DeviceUserCreateArgs>(args: SelectSubset<T, DeviceUserCreateArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DeviceUsers.
     * @param {DeviceUserCreateManyArgs} args - Arguments to create many DeviceUsers.
     * @example
     * // Create many DeviceUsers
     * const deviceUser = await prisma.deviceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceUserCreateManyArgs>(args?: SelectSubset<T, DeviceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceUsers and returns the data saved in the database.
     * @param {DeviceUserCreateManyAndReturnArgs} args - Arguments to create many DeviceUsers.
     * @example
     * // Create many DeviceUsers
     * const deviceUser = await prisma.deviceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceUsers and only return the `id`
     * const deviceUserWithIdOnly = await prisma.deviceUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DeviceUser.
     * @param {DeviceUserDeleteArgs} args - Arguments to delete one DeviceUser.
     * @example
     * // Delete one DeviceUser
     * const DeviceUser = await prisma.deviceUser.delete({
     *   where: {
     *     // ... filter to delete one DeviceUser
     *   }
     * })
     * 
     */
    delete<T extends DeviceUserDeleteArgs>(args: SelectSubset<T, DeviceUserDeleteArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DeviceUser.
     * @param {DeviceUserUpdateArgs} args - Arguments to update one DeviceUser.
     * @example
     * // Update one DeviceUser
     * const deviceUser = await prisma.deviceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUserUpdateArgs>(args: SelectSubset<T, DeviceUserUpdateArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DeviceUsers.
     * @param {DeviceUserDeleteManyArgs} args - Arguments to filter DeviceUsers to delete.
     * @example
     * // Delete a few DeviceUsers
     * const { count } = await prisma.deviceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceUserDeleteManyArgs>(args?: SelectSubset<T, DeviceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceUsers
     * const deviceUser = await prisma.deviceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUserUpdateManyArgs>(args: SelectSubset<T, DeviceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceUsers and returns the data updated in the database.
     * @param {DeviceUserUpdateManyAndReturnArgs} args - Arguments to update many DeviceUsers.
     * @example
     * // Update many DeviceUsers
     * const deviceUser = await prisma.deviceUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceUsers and only return the `id`
     * const deviceUserWithIdOnly = await prisma.deviceUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUserUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DeviceUser.
     * @param {DeviceUserUpsertArgs} args - Arguments to update or create a DeviceUser.
     * @example
     * // Update or create a DeviceUser
     * const deviceUser = await prisma.deviceUser.upsert({
     *   create: {
     *     // ... data to create a DeviceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceUser we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUserUpsertArgs>(args: SelectSubset<T, DeviceUserUpsertArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserCountArgs} args - Arguments to filter DeviceUsers to count.
     * @example
     * // Count the number of DeviceUsers
     * const count = await prisma.deviceUser.count({
     *   where: {
     *     // ... the filter for the DeviceUsers we want to count
     *   }
     * })
    **/
    count<T extends DeviceUserCountArgs>(
      args?: Subset<T, DeviceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceUserAggregateArgs>(args: Subset<T, DeviceUserAggregateArgs>): Prisma.PrismaPromise<GetDeviceUserAggregateType<T>>

    /**
     * Group by DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceUserGroupByArgs['orderBy'] }
        : { orderBy?: DeviceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceUser model
   */
  readonly fields: DeviceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends devicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, devicesDefaultArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceUser model
   */ 
  interface DeviceUserFieldRefs {
    readonly id: FieldRef<"DeviceUser", 'Int'>
    readonly userId: FieldRef<"DeviceUser", 'Int'>
    readonly deviceId: FieldRef<"DeviceUser", 'Int'>
    readonly role: FieldRef<"DeviceUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceUser findUnique
   */
  export type DeviceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser findUniqueOrThrow
   */
  export type DeviceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser findFirst
   */
  export type DeviceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceUsers.
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceUsers.
     */
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * DeviceUser findFirstOrThrow
   */
  export type DeviceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceUsers.
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceUsers.
     */
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * DeviceUser findMany
   */
  export type DeviceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUsers to fetch.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceUsers.
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * DeviceUser create
   */
  export type DeviceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceUser.
     */
    data: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
  }

  /**
   * DeviceUser createMany
   */
  export type DeviceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceUsers.
     */
    data: DeviceUserCreateManyInput | DeviceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceUser createManyAndReturn
   */
  export type DeviceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceUsers.
     */
    data: DeviceUserCreateManyInput | DeviceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceUser update
   */
  export type DeviceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceUser.
     */
    data: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
    /**
     * Choose, which DeviceUser to update.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser updateMany
   */
  export type DeviceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceUsers.
     */
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyInput>
    /**
     * Filter which DeviceUsers to update
     */
    where?: DeviceUserWhereInput
    /**
     * Limit how many DeviceUsers to update.
     */
    limit?: number
  }

  /**
   * DeviceUser updateManyAndReturn
   */
  export type DeviceUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * The data used to update DeviceUsers.
     */
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyInput>
    /**
     * Filter which DeviceUsers to update
     */
    where?: DeviceUserWhereInput
    /**
     * Limit how many DeviceUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceUser upsert
   */
  export type DeviceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceUser to update in case it exists.
     */
    where: DeviceUserWhereUniqueInput
    /**
     * In case the DeviceUser found by the `where` argument doesn't exist, create a new DeviceUser with this data.
     */
    create: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
    /**
     * In case the DeviceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
  }

  /**
   * DeviceUser delete
   */
  export type DeviceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter which DeviceUser to delete.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser deleteMany
   */
  export type DeviceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceUsers to delete
     */
    where?: DeviceUserWhereInput
    /**
     * Limit how many DeviceUsers to delete.
     */
    limit?: number
  }

  /**
   * DeviceUser without action
   */
  export type DeviceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
  }


  /**
   * Model Command
   */

  export type AggregateCommand = {
    _count: CommandCountAggregateOutputType | null
    _avg: CommandAvgAggregateOutputType | null
    _sum: CommandSumAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  export type CommandAvgAggregateOutputType = {
    id: number | null
    ruleId: number | null
    emailTemplateId: number | null
  }

  export type CommandSumAggregateOutputType = {
    id: number | null
    ruleId: number | null
    emailTemplateId: number | null
  }

  export type CommandMinAggregateOutputType = {
    id: number | null
    ruleId: number | null
    command: string | null
    emailTemplateId: number | null
  }

  export type CommandMaxAggregateOutputType = {
    id: number | null
    ruleId: number | null
    command: string | null
    emailTemplateId: number | null
  }

  export type CommandCountAggregateOutputType = {
    id: number
    ruleId: number
    command: number
    emailTemplateId: number
    _all: number
  }


  export type CommandAvgAggregateInputType = {
    id?: true
    ruleId?: true
    emailTemplateId?: true
  }

  export type CommandSumAggregateInputType = {
    id?: true
    ruleId?: true
    emailTemplateId?: true
  }

  export type CommandMinAggregateInputType = {
    id?: true
    ruleId?: true
    command?: true
    emailTemplateId?: true
  }

  export type CommandMaxAggregateInputType = {
    id?: true
    ruleId?: true
    command?: true
    emailTemplateId?: true
  }

  export type CommandCountAggregateInputType = {
    id?: true
    ruleId?: true
    command?: true
    emailTemplateId?: true
    _all?: true
  }

  export type CommandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Command to aggregate.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commands
    **/
    _count?: true | CommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandMaxAggregateInputType
  }

  export type GetCommandAggregateType<T extends CommandAggregateArgs> = {
        [P in keyof T & keyof AggregateCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommand[P]>
      : GetScalarType<T[P], AggregateCommand[P]>
  }




  export type CommandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithAggregationInput | CommandOrderByWithAggregationInput[]
    by: CommandScalarFieldEnum[] | CommandScalarFieldEnum
    having?: CommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandCountAggregateInputType | true
    _avg?: CommandAvgAggregateInputType
    _sum?: CommandSumAggregateInputType
    _min?: CommandMinAggregateInputType
    _max?: CommandMaxAggregateInputType
  }

  export type CommandGroupByOutputType = {
    id: number
    ruleId: number
    command: string
    emailTemplateId: number | null
    _count: CommandCountAggregateOutputType | null
    _avg: CommandAvgAggregateOutputType | null
    _sum: CommandSumAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  type GetCommandGroupByPayload<T extends CommandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandGroupByOutputType[P]>
            : GetScalarType<T[P], CommandGroupByOutputType[P]>
        }
      >
    >


  export type CommandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    command?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | Command$emailTemplateArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
    matches?: boolean | Command$matchesArgs<ExtArgs>
    _count?: boolean | CommandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    command?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | Command$emailTemplateArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    command?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | Command$emailTemplateArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectScalar = {
    id?: boolean
    ruleId?: boolean
    command?: boolean
    emailTemplateId?: boolean
  }

  export type CommandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ruleId" | "command" | "emailTemplateId", ExtArgs["result"]["command"]>
  export type CommandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | Command$emailTemplateArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
    matches?: boolean | Command$matchesArgs<ExtArgs>
    _count?: boolean | CommandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | Command$emailTemplateArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }
  export type CommandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | Command$emailTemplateArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }

  export type $CommandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Command"
    objects: {
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
      rule: Prisma.$RulePayload<ExtArgs>
      matches: Prisma.$CommandMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ruleId: number
      command: string
      emailTemplateId: number | null
    }, ExtArgs["result"]["command"]>
    composites: {}
  }

  type CommandGetPayload<S extends boolean | null | undefined | CommandDefaultArgs> = $Result.GetResult<Prisma.$CommandPayload, S>

  type CommandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandCountAggregateInputType | true
    }

  export interface CommandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Command'], meta: { name: 'Command' } }
    /**
     * Find zero or one Command that matches the filter.
     * @param {CommandFindUniqueArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandFindUniqueArgs>(args: SelectSubset<T, CommandFindUniqueArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Command that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandFindUniqueOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Command that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandFindFirstArgs>(args?: SelectSubset<T, CommandFindFirstArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Command that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commands
     * const commands = await prisma.command.findMany()
     * 
     * // Get first 10 Commands
     * const commands = await prisma.command.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandWithIdOnly = await prisma.command.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandFindManyArgs>(args?: SelectSubset<T, CommandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Command.
     * @param {CommandCreateArgs} args - Arguments to create a Command.
     * @example
     * // Create one Command
     * const Command = await prisma.command.create({
     *   data: {
     *     // ... data to create a Command
     *   }
     * })
     * 
     */
    create<T extends CommandCreateArgs>(args: SelectSubset<T, CommandCreateArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Commands.
     * @param {CommandCreateManyArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandCreateManyArgs>(args?: SelectSubset<T, CommandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commands and returns the data saved in the database.
     * @param {CommandCreateManyAndReturnArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commands and only return the `id`
     * const commandWithIdOnly = await prisma.command.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommandCreateManyAndReturnArgs>(args?: SelectSubset<T, CommandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Command.
     * @param {CommandDeleteArgs} args - Arguments to delete one Command.
     * @example
     * // Delete one Command
     * const Command = await prisma.command.delete({
     *   where: {
     *     // ... filter to delete one Command
     *   }
     * })
     * 
     */
    delete<T extends CommandDeleteArgs>(args: SelectSubset<T, CommandDeleteArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Command.
     * @param {CommandUpdateArgs} args - Arguments to update one Command.
     * @example
     * // Update one Command
     * const command = await prisma.command.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandUpdateArgs>(args: SelectSubset<T, CommandUpdateArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Commands.
     * @param {CommandDeleteManyArgs} args - Arguments to filter Commands to delete.
     * @example
     * // Delete a few Commands
     * const { count } = await prisma.command.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandDeleteManyArgs>(args?: SelectSubset<T, CommandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandUpdateManyArgs>(args: SelectSubset<T, CommandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commands and returns the data updated in the database.
     * @param {CommandUpdateManyAndReturnArgs} args - Arguments to update many Commands.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Commands and only return the `id`
     * const commandWithIdOnly = await prisma.command.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommandUpdateManyAndReturnArgs>(args: SelectSubset<T, CommandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Command.
     * @param {CommandUpsertArgs} args - Arguments to update or create a Command.
     * @example
     * // Update or create a Command
     * const command = await prisma.command.upsert({
     *   create: {
     *     // ... data to create a Command
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Command we want to update
     *   }
     * })
     */
    upsert<T extends CommandUpsertArgs>(args: SelectSubset<T, CommandUpsertArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandCountArgs} args - Arguments to filter Commands to count.
     * @example
     * // Count the number of Commands
     * const count = await prisma.command.count({
     *   where: {
     *     // ... the filter for the Commands we want to count
     *   }
     * })
    **/
    count<T extends CommandCountArgs>(
      args?: Subset<T, CommandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandAggregateArgs>(args: Subset<T, CommandAggregateArgs>): Prisma.PrismaPromise<GetCommandAggregateType<T>>

    /**
     * Group by Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandGroupByArgs['orderBy'] }
        : { orderBy?: CommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Command model
   */
  readonly fields: CommandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Command.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailTemplate<T extends Command$emailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Command$emailTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    rule<T extends RuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RuleDefaultArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    matches<T extends Command$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Command$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Command model
   */ 
  interface CommandFieldRefs {
    readonly id: FieldRef<"Command", 'Int'>
    readonly ruleId: FieldRef<"Command", 'Int'>
    readonly command: FieldRef<"Command", 'String'>
    readonly emailTemplateId: FieldRef<"Command", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Command findUnique
   */
  export type CommandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findUniqueOrThrow
   */
  export type CommandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findFirst
   */
  export type CommandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findFirstOrThrow
   */
  export type CommandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findMany
   */
  export type CommandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Commands to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command create
   */
  export type CommandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to create a Command.
     */
    data: XOR<CommandCreateInput, CommandUncheckedCreateInput>
  }

  /**
   * Command createMany
   */
  export type CommandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Command createManyAndReturn
   */
  export type CommandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Command update
   */
  export type CommandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to update a Command.
     */
    data: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
    /**
     * Choose, which Command to update.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command updateMany
   */
  export type CommandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commands.
     */
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyInput>
    /**
     * Filter which Commands to update
     */
    where?: CommandWhereInput
    /**
     * Limit how many Commands to update.
     */
    limit?: number
  }

  /**
   * Command updateManyAndReturn
   */
  export type CommandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * The data used to update Commands.
     */
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyInput>
    /**
     * Filter which Commands to update
     */
    where?: CommandWhereInput
    /**
     * Limit how many Commands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Command upsert
   */
  export type CommandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The filter to search for the Command to update in case it exists.
     */
    where: CommandWhereUniqueInput
    /**
     * In case the Command found by the `where` argument doesn't exist, create a new Command with this data.
     */
    create: XOR<CommandCreateInput, CommandUncheckedCreateInput>
    /**
     * In case the Command was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
  }

  /**
   * Command delete
   */
  export type CommandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter which Command to delete.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command deleteMany
   */
  export type CommandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commands to delete
     */
    where?: CommandWhereInput
    /**
     * Limit how many Commands to delete.
     */
    limit?: number
  }

  /**
   * Command.emailTemplate
   */
  export type Command$emailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * Command.matches
   */
  export type Command$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    where?: CommandMatchWhereInput
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    cursor?: CommandMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * Command without action
   */
  export type CommandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
  }


  /**
   * Model Rule
   */

  export type AggregateRule = {
    _count: RuleCountAggregateOutputType | null
    _avg: RuleAvgAggregateOutputType | null
    _sum: RuleSumAggregateOutputType | null
    _min: RuleMinAggregateOutputType | null
    _max: RuleMaxAggregateOutputType | null
  }

  export type RuleAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    emailTemplateId: number | null
  }

  export type RuleSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    emailTemplateId: number | null
  }

  export type RuleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    groupId: number | null
    emailTemplateId: number | null
  }

  export type RuleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    groupId: number | null
    emailTemplateId: number | null
  }

  export type RuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    groupId: number
    emailTemplateId: number
    _all: number
  }


  export type RuleAvgAggregateInputType = {
    id?: true
    groupId?: true
    emailTemplateId?: true
  }

  export type RuleSumAggregateInputType = {
    id?: true
    groupId?: true
    emailTemplateId?: true
  }

  export type RuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    groupId?: true
    emailTemplateId?: true
  }

  export type RuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    groupId?: true
    emailTemplateId?: true
  }

  export type RuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    groupId?: true
    emailTemplateId?: true
    _all?: true
  }

  export type RuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rule to aggregate.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: RuleOrderByWithRelationInput | RuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rules
    **/
    _count?: true | RuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RuleMaxAggregateInputType
  }

  export type GetRuleAggregateType<T extends RuleAggregateArgs> = {
        [P in keyof T & keyof AggregateRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRule[P]>
      : GetScalarType<T[P], AggregateRule[P]>
  }




  export type RuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RuleWhereInput
    orderBy?: RuleOrderByWithAggregationInput | RuleOrderByWithAggregationInput[]
    by: RuleScalarFieldEnum[] | RuleScalarFieldEnum
    having?: RuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RuleCountAggregateInputType | true
    _avg?: RuleAvgAggregateInputType
    _sum?: RuleSumAggregateInputType
    _min?: RuleMinAggregateInputType
    _max?: RuleMaxAggregateInputType
  }

  export type RuleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    groupId: number | null
    emailTemplateId: number | null
    _count: RuleCountAggregateOutputType | null
    _avg: RuleAvgAggregateOutputType | null
    _sum: RuleSumAggregateOutputType | null
    _min: RuleMinAggregateOutputType | null
    _max: RuleMaxAggregateOutputType | null
  }

  type GetRuleGroupByPayload<T extends RuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RuleGroupByOutputType[P]>
            : GetScalarType<T[P], RuleGroupByOutputType[P]>
        }
      >
    >


  export type RuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupId?: boolean
    emailTemplateId?: boolean
    commands?: boolean | Rule$commandsArgs<ExtArgs>
    matches?: boolean | Rule$matchesArgs<ExtArgs>
    emailTemplate?: boolean | Rule$emailTemplateArgs<ExtArgs>
    group?: boolean | Rule$groupArgs<ExtArgs>
    _count?: boolean | RuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rule"]>

  export type RuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupId?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | Rule$emailTemplateArgs<ExtArgs>
    group?: boolean | Rule$groupArgs<ExtArgs>
  }, ExtArgs["result"]["rule"]>

  export type RuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupId?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | Rule$emailTemplateArgs<ExtArgs>
    group?: boolean | Rule$groupArgs<ExtArgs>
  }, ExtArgs["result"]["rule"]>

  export type RuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupId?: boolean
    emailTemplateId?: boolean
  }

  export type RuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "groupId" | "emailTemplateId", ExtArgs["result"]["rule"]>
  export type RuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commands?: boolean | Rule$commandsArgs<ExtArgs>
    matches?: boolean | Rule$matchesArgs<ExtArgs>
    emailTemplate?: boolean | Rule$emailTemplateArgs<ExtArgs>
    group?: boolean | Rule$groupArgs<ExtArgs>
    _count?: boolean | RuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | Rule$emailTemplateArgs<ExtArgs>
    group?: boolean | Rule$groupArgs<ExtArgs>
  }
  export type RuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | Rule$emailTemplateArgs<ExtArgs>
    group?: boolean | Rule$groupArgs<ExtArgs>
  }

  export type $RulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rule"
    objects: {
      commands: Prisma.$CommandPayload<ExtArgs>[]
      matches: Prisma.$CommandMatchPayload<ExtArgs>[]
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
      group: Prisma.$RuleGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      groupId: number | null
      emailTemplateId: number | null
    }, ExtArgs["result"]["rule"]>
    composites: {}
  }

  type RuleGetPayload<S extends boolean | null | undefined | RuleDefaultArgs> = $Result.GetResult<Prisma.$RulePayload, S>

  type RuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RuleCountAggregateInputType | true
    }

  export interface RuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rule'], meta: { name: 'Rule' } }
    /**
     * Find zero or one Rule that matches the filter.
     * @param {RuleFindUniqueArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RuleFindUniqueArgs>(args: SelectSubset<T, RuleFindUniqueArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Rule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RuleFindUniqueOrThrowArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RuleFindUniqueOrThrowArgs>(args: SelectSubset<T, RuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Rule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleFindFirstArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RuleFindFirstArgs>(args?: SelectSubset<T, RuleFindFirstArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Rule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleFindFirstOrThrowArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RuleFindFirstOrThrowArgs>(args?: SelectSubset<T, RuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rules
     * const rules = await prisma.rule.findMany()
     * 
     * // Get first 10 Rules
     * const rules = await prisma.rule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ruleWithIdOnly = await prisma.rule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RuleFindManyArgs>(args?: SelectSubset<T, RuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Rule.
     * @param {RuleCreateArgs} args - Arguments to create a Rule.
     * @example
     * // Create one Rule
     * const Rule = await prisma.rule.create({
     *   data: {
     *     // ... data to create a Rule
     *   }
     * })
     * 
     */
    create<T extends RuleCreateArgs>(args: SelectSubset<T, RuleCreateArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rules.
     * @param {RuleCreateManyArgs} args - Arguments to create many Rules.
     * @example
     * // Create many Rules
     * const rule = await prisma.rule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RuleCreateManyArgs>(args?: SelectSubset<T, RuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rules and returns the data saved in the database.
     * @param {RuleCreateManyAndReturnArgs} args - Arguments to create many Rules.
     * @example
     * // Create many Rules
     * const rule = await prisma.rule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rules and only return the `id`
     * const ruleWithIdOnly = await prisma.rule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RuleCreateManyAndReturnArgs>(args?: SelectSubset<T, RuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Rule.
     * @param {RuleDeleteArgs} args - Arguments to delete one Rule.
     * @example
     * // Delete one Rule
     * const Rule = await prisma.rule.delete({
     *   where: {
     *     // ... filter to delete one Rule
     *   }
     * })
     * 
     */
    delete<T extends RuleDeleteArgs>(args: SelectSubset<T, RuleDeleteArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Rule.
     * @param {RuleUpdateArgs} args - Arguments to update one Rule.
     * @example
     * // Update one Rule
     * const rule = await prisma.rule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RuleUpdateArgs>(args: SelectSubset<T, RuleUpdateArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rules.
     * @param {RuleDeleteManyArgs} args - Arguments to filter Rules to delete.
     * @example
     * // Delete a few Rules
     * const { count } = await prisma.rule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RuleDeleteManyArgs>(args?: SelectSubset<T, RuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rules
     * const rule = await prisma.rule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RuleUpdateManyArgs>(args: SelectSubset<T, RuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rules and returns the data updated in the database.
     * @param {RuleUpdateManyAndReturnArgs} args - Arguments to update many Rules.
     * @example
     * // Update many Rules
     * const rule = await prisma.rule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rules and only return the `id`
     * const ruleWithIdOnly = await prisma.rule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RuleUpdateManyAndReturnArgs>(args: SelectSubset<T, RuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Rule.
     * @param {RuleUpsertArgs} args - Arguments to update or create a Rule.
     * @example
     * // Update or create a Rule
     * const rule = await prisma.rule.upsert({
     *   create: {
     *     // ... data to create a Rule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rule we want to update
     *   }
     * })
     */
    upsert<T extends RuleUpsertArgs>(args: SelectSubset<T, RuleUpsertArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleCountArgs} args - Arguments to filter Rules to count.
     * @example
     * // Count the number of Rules
     * const count = await prisma.rule.count({
     *   where: {
     *     // ... the filter for the Rules we want to count
     *   }
     * })
    **/
    count<T extends RuleCountArgs>(
      args?: Subset<T, RuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RuleAggregateArgs>(args: Subset<T, RuleAggregateArgs>): Prisma.PrismaPromise<GetRuleAggregateType<T>>

    /**
     * Group by Rule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RuleGroupByArgs['orderBy'] }
        : { orderBy?: RuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rule model
   */
  readonly fields: RuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commands<T extends Rule$commandsArgs<ExtArgs> = {}>(args?: Subset<T, Rule$commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    matches<T extends Rule$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Rule$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    emailTemplate<T extends Rule$emailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Rule$emailTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    group<T extends Rule$groupArgs<ExtArgs> = {}>(args?: Subset<T, Rule$groupArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rule model
   */ 
  interface RuleFieldRefs {
    readonly id: FieldRef<"Rule", 'Int'>
    readonly name: FieldRef<"Rule", 'String'>
    readonly description: FieldRef<"Rule", 'String'>
    readonly createdAt: FieldRef<"Rule", 'DateTime'>
    readonly updatedAt: FieldRef<"Rule", 'DateTime'>
    readonly groupId: FieldRef<"Rule", 'Int'>
    readonly emailTemplateId: FieldRef<"Rule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Rule findUnique
   */
  export type RuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * Filter, which Rule to fetch.
     */
    where: RuleWhereUniqueInput
  }

  /**
   * Rule findUniqueOrThrow
   */
  export type RuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * Filter, which Rule to fetch.
     */
    where: RuleWhereUniqueInput
  }

  /**
   * Rule findFirst
   */
  export type RuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * Filter, which Rule to fetch.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: RuleOrderByWithRelationInput | RuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rules.
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rules.
     */
    distinct?: RuleScalarFieldEnum | RuleScalarFieldEnum[]
  }

  /**
   * Rule findFirstOrThrow
   */
  export type RuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * Filter, which Rule to fetch.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: RuleOrderByWithRelationInput | RuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rules.
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rules.
     */
    distinct?: RuleScalarFieldEnum | RuleScalarFieldEnum[]
  }

  /**
   * Rule findMany
   */
  export type RuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * Filter, which Rules to fetch.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: RuleOrderByWithRelationInput | RuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rules.
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    distinct?: RuleScalarFieldEnum | RuleScalarFieldEnum[]
  }

  /**
   * Rule create
   */
  export type RuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Rule.
     */
    data: XOR<RuleCreateInput, RuleUncheckedCreateInput>
  }

  /**
   * Rule createMany
   */
  export type RuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rules.
     */
    data: RuleCreateManyInput | RuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rule createManyAndReturn
   */
  export type RuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * The data used to create many Rules.
     */
    data: RuleCreateManyInput | RuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rule update
   */
  export type RuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Rule.
     */
    data: XOR<RuleUpdateInput, RuleUncheckedUpdateInput>
    /**
     * Choose, which Rule to update.
     */
    where: RuleWhereUniqueInput
  }

  /**
   * Rule updateMany
   */
  export type RuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rules.
     */
    data: XOR<RuleUpdateManyMutationInput, RuleUncheckedUpdateManyInput>
    /**
     * Filter which Rules to update
     */
    where?: RuleWhereInput
    /**
     * Limit how many Rules to update.
     */
    limit?: number
  }

  /**
   * Rule updateManyAndReturn
   */
  export type RuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * The data used to update Rules.
     */
    data: XOR<RuleUpdateManyMutationInput, RuleUncheckedUpdateManyInput>
    /**
     * Filter which Rules to update
     */
    where?: RuleWhereInput
    /**
     * Limit how many Rules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rule upsert
   */
  export type RuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Rule to update in case it exists.
     */
    where: RuleWhereUniqueInput
    /**
     * In case the Rule found by the `where` argument doesn't exist, create a new Rule with this data.
     */
    create: XOR<RuleCreateInput, RuleUncheckedCreateInput>
    /**
     * In case the Rule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RuleUpdateInput, RuleUncheckedUpdateInput>
  }

  /**
   * Rule delete
   */
  export type RuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    /**
     * Filter which Rule to delete.
     */
    where: RuleWhereUniqueInput
  }

  /**
   * Rule deleteMany
   */
  export type RuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rules to delete
     */
    where?: RuleWhereInput
    /**
     * Limit how many Rules to delete.
     */
    limit?: number
  }

  /**
   * Rule.commands
   */
  export type Rule$commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Rule.matches
   */
  export type Rule$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    where?: CommandMatchWhereInput
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    cursor?: CommandMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * Rule.emailTemplate
   */
  export type Rule$emailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * Rule.group
   */
  export type Rule$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    where?: RuleGroupWhereInput
  }

  /**
   * Rule without action
   */
  export type RuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
  }


  /**
   * Model RuleGroup
   */

  export type AggregateRuleGroup = {
    _count: RuleGroupCountAggregateOutputType | null
    _avg: RuleGroupAvgAggregateOutputType | null
    _sum: RuleGroupSumAggregateOutputType | null
    _min: RuleGroupMinAggregateOutputType | null
    _max: RuleGroupMaxAggregateOutputType | null
  }

  export type RuleGroupAvgAggregateOutputType = {
    id: number | null
    emailTemplateId: number | null
  }

  export type RuleGroupSumAggregateOutputType = {
    id: number | null
    emailTemplateId: number | null
  }

  export type RuleGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailTemplateId: number | null
  }

  export type RuleGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailTemplateId: number | null
  }

  export type RuleGroupCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    emailTemplateId: number
    _all: number
  }


  export type RuleGroupAvgAggregateInputType = {
    id?: true
    emailTemplateId?: true
  }

  export type RuleGroupSumAggregateInputType = {
    id?: true
    emailTemplateId?: true
  }

  export type RuleGroupMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    emailTemplateId?: true
  }

  export type RuleGroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    emailTemplateId?: true
  }

  export type RuleGroupCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    emailTemplateId?: true
    _all?: true
  }

  export type RuleGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RuleGroup to aggregate.
     */
    where?: RuleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuleGroups to fetch.
     */
    orderBy?: RuleGroupOrderByWithRelationInput | RuleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RuleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RuleGroups
    **/
    _count?: true | RuleGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RuleGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RuleGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RuleGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RuleGroupMaxAggregateInputType
  }

  export type GetRuleGroupAggregateType<T extends RuleGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateRuleGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRuleGroup[P]>
      : GetScalarType<T[P], AggregateRuleGroup[P]>
  }




  export type RuleGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RuleGroupWhereInput
    orderBy?: RuleGroupOrderByWithAggregationInput | RuleGroupOrderByWithAggregationInput[]
    by: RuleGroupScalarFieldEnum[] | RuleGroupScalarFieldEnum
    having?: RuleGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RuleGroupCountAggregateInputType | true
    _avg?: RuleGroupAvgAggregateInputType
    _sum?: RuleGroupSumAggregateInputType
    _min?: RuleGroupMinAggregateInputType
    _max?: RuleGroupMaxAggregateInputType
  }

  export type RuleGroupGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    emailTemplateId: number | null
    _count: RuleGroupCountAggregateOutputType | null
    _avg: RuleGroupAvgAggregateOutputType | null
    _sum: RuleGroupSumAggregateOutputType | null
    _min: RuleGroupMinAggregateOutputType | null
    _max: RuleGroupMaxAggregateOutputType | null
  }

  type GetRuleGroupGroupByPayload<T extends RuleGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RuleGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RuleGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RuleGroupGroupByOutputType[P]>
            : GetScalarType<T[P], RuleGroupGroupByOutputType[P]>
        }
      >
    >


  export type RuleGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
    rules?: boolean | RuleGroup$rulesArgs<ExtArgs>
    emailTemplate?: boolean | RuleGroup$emailTemplateArgs<ExtArgs>
    _count?: boolean | RuleGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ruleGroup"]>

  export type RuleGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | RuleGroup$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["ruleGroup"]>

  export type RuleGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | RuleGroup$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["ruleGroup"]>

  export type RuleGroupSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplateId?: boolean
  }

  export type RuleGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "emailTemplateId", ExtArgs["result"]["ruleGroup"]>
  export type RuleGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | RuleGroup$rulesArgs<ExtArgs>
    emailTemplate?: boolean | RuleGroup$emailTemplateArgs<ExtArgs>
    _count?: boolean | RuleGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RuleGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | RuleGroup$emailTemplateArgs<ExtArgs>
  }
  export type RuleGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | RuleGroup$emailTemplateArgs<ExtArgs>
  }

  export type $RuleGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RuleGroup"
    objects: {
      rules: Prisma.$RulePayload<ExtArgs>[]
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
      emailTemplateId: number | null
    }, ExtArgs["result"]["ruleGroup"]>
    composites: {}
  }

  type RuleGroupGetPayload<S extends boolean | null | undefined | RuleGroupDefaultArgs> = $Result.GetResult<Prisma.$RuleGroupPayload, S>

  type RuleGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RuleGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RuleGroupCountAggregateInputType | true
    }

  export interface RuleGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RuleGroup'], meta: { name: 'RuleGroup' } }
    /**
     * Find zero or one RuleGroup that matches the filter.
     * @param {RuleGroupFindUniqueArgs} args - Arguments to find a RuleGroup
     * @example
     * // Get one RuleGroup
     * const ruleGroup = await prisma.ruleGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RuleGroupFindUniqueArgs>(args: SelectSubset<T, RuleGroupFindUniqueArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RuleGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RuleGroupFindUniqueOrThrowArgs} args - Arguments to find a RuleGroup
     * @example
     * // Get one RuleGroup
     * const ruleGroup = await prisma.ruleGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RuleGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, RuleGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RuleGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupFindFirstArgs} args - Arguments to find a RuleGroup
     * @example
     * // Get one RuleGroup
     * const ruleGroup = await prisma.ruleGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RuleGroupFindFirstArgs>(args?: SelectSubset<T, RuleGroupFindFirstArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RuleGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupFindFirstOrThrowArgs} args - Arguments to find a RuleGroup
     * @example
     * // Get one RuleGroup
     * const ruleGroup = await prisma.ruleGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RuleGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, RuleGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RuleGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RuleGroups
     * const ruleGroups = await prisma.ruleGroup.findMany()
     * 
     * // Get first 10 RuleGroups
     * const ruleGroups = await prisma.ruleGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ruleGroupWithIdOnly = await prisma.ruleGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RuleGroupFindManyArgs>(args?: SelectSubset<T, RuleGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RuleGroup.
     * @param {RuleGroupCreateArgs} args - Arguments to create a RuleGroup.
     * @example
     * // Create one RuleGroup
     * const RuleGroup = await prisma.ruleGroup.create({
     *   data: {
     *     // ... data to create a RuleGroup
     *   }
     * })
     * 
     */
    create<T extends RuleGroupCreateArgs>(args: SelectSubset<T, RuleGroupCreateArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RuleGroups.
     * @param {RuleGroupCreateManyArgs} args - Arguments to create many RuleGroups.
     * @example
     * // Create many RuleGroups
     * const ruleGroup = await prisma.ruleGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RuleGroupCreateManyArgs>(args?: SelectSubset<T, RuleGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RuleGroups and returns the data saved in the database.
     * @param {RuleGroupCreateManyAndReturnArgs} args - Arguments to create many RuleGroups.
     * @example
     * // Create many RuleGroups
     * const ruleGroup = await prisma.ruleGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RuleGroups and only return the `id`
     * const ruleGroupWithIdOnly = await prisma.ruleGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RuleGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, RuleGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RuleGroup.
     * @param {RuleGroupDeleteArgs} args - Arguments to delete one RuleGroup.
     * @example
     * // Delete one RuleGroup
     * const RuleGroup = await prisma.ruleGroup.delete({
     *   where: {
     *     // ... filter to delete one RuleGroup
     *   }
     * })
     * 
     */
    delete<T extends RuleGroupDeleteArgs>(args: SelectSubset<T, RuleGroupDeleteArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RuleGroup.
     * @param {RuleGroupUpdateArgs} args - Arguments to update one RuleGroup.
     * @example
     * // Update one RuleGroup
     * const ruleGroup = await prisma.ruleGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RuleGroupUpdateArgs>(args: SelectSubset<T, RuleGroupUpdateArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RuleGroups.
     * @param {RuleGroupDeleteManyArgs} args - Arguments to filter RuleGroups to delete.
     * @example
     * // Delete a few RuleGroups
     * const { count } = await prisma.ruleGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RuleGroupDeleteManyArgs>(args?: SelectSubset<T, RuleGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RuleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RuleGroups
     * const ruleGroup = await prisma.ruleGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RuleGroupUpdateManyArgs>(args: SelectSubset<T, RuleGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RuleGroups and returns the data updated in the database.
     * @param {RuleGroupUpdateManyAndReturnArgs} args - Arguments to update many RuleGroups.
     * @example
     * // Update many RuleGroups
     * const ruleGroup = await prisma.ruleGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RuleGroups and only return the `id`
     * const ruleGroupWithIdOnly = await prisma.ruleGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RuleGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, RuleGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RuleGroup.
     * @param {RuleGroupUpsertArgs} args - Arguments to update or create a RuleGroup.
     * @example
     * // Update or create a RuleGroup
     * const ruleGroup = await prisma.ruleGroup.upsert({
     *   create: {
     *     // ... data to create a RuleGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RuleGroup we want to update
     *   }
     * })
     */
    upsert<T extends RuleGroupUpsertArgs>(args: SelectSubset<T, RuleGroupUpsertArgs<ExtArgs>>): Prisma__RuleGroupClient<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RuleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupCountArgs} args - Arguments to filter RuleGroups to count.
     * @example
     * // Count the number of RuleGroups
     * const count = await prisma.ruleGroup.count({
     *   where: {
     *     // ... the filter for the RuleGroups we want to count
     *   }
     * })
    **/
    count<T extends RuleGroupCountArgs>(
      args?: Subset<T, RuleGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RuleGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RuleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RuleGroupAggregateArgs>(args: Subset<T, RuleGroupAggregateArgs>): Prisma.PrismaPromise<GetRuleGroupAggregateType<T>>

    /**
     * Group by RuleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RuleGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RuleGroupGroupByArgs['orderBy'] }
        : { orderBy?: RuleGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RuleGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRuleGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RuleGroup model
   */
  readonly fields: RuleGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RuleGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RuleGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rules<T extends RuleGroup$rulesArgs<ExtArgs> = {}>(args?: Subset<T, RuleGroup$rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    emailTemplate<T extends RuleGroup$emailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, RuleGroup$emailTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RuleGroup model
   */ 
  interface RuleGroupFieldRefs {
    readonly id: FieldRef<"RuleGroup", 'Int'>
    readonly name: FieldRef<"RuleGroup", 'String'>
    readonly createdAt: FieldRef<"RuleGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"RuleGroup", 'DateTime'>
    readonly emailTemplateId: FieldRef<"RuleGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RuleGroup findUnique
   */
  export type RuleGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * Filter, which RuleGroup to fetch.
     */
    where: RuleGroupWhereUniqueInput
  }

  /**
   * RuleGroup findUniqueOrThrow
   */
  export type RuleGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * Filter, which RuleGroup to fetch.
     */
    where: RuleGroupWhereUniqueInput
  }

  /**
   * RuleGroup findFirst
   */
  export type RuleGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * Filter, which RuleGroup to fetch.
     */
    where?: RuleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuleGroups to fetch.
     */
    orderBy?: RuleGroupOrderByWithRelationInput | RuleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RuleGroups.
     */
    cursor?: RuleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RuleGroups.
     */
    distinct?: RuleGroupScalarFieldEnum | RuleGroupScalarFieldEnum[]
  }

  /**
   * RuleGroup findFirstOrThrow
   */
  export type RuleGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * Filter, which RuleGroup to fetch.
     */
    where?: RuleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuleGroups to fetch.
     */
    orderBy?: RuleGroupOrderByWithRelationInput | RuleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RuleGroups.
     */
    cursor?: RuleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RuleGroups.
     */
    distinct?: RuleGroupScalarFieldEnum | RuleGroupScalarFieldEnum[]
  }

  /**
   * RuleGroup findMany
   */
  export type RuleGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * Filter, which RuleGroups to fetch.
     */
    where?: RuleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuleGroups to fetch.
     */
    orderBy?: RuleGroupOrderByWithRelationInput | RuleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RuleGroups.
     */
    cursor?: RuleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuleGroups.
     */
    skip?: number
    distinct?: RuleGroupScalarFieldEnum | RuleGroupScalarFieldEnum[]
  }

  /**
   * RuleGroup create
   */
  export type RuleGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a RuleGroup.
     */
    data: XOR<RuleGroupCreateInput, RuleGroupUncheckedCreateInput>
  }

  /**
   * RuleGroup createMany
   */
  export type RuleGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RuleGroups.
     */
    data: RuleGroupCreateManyInput | RuleGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RuleGroup createManyAndReturn
   */
  export type RuleGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * The data used to create many RuleGroups.
     */
    data: RuleGroupCreateManyInput | RuleGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RuleGroup update
   */
  export type RuleGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a RuleGroup.
     */
    data: XOR<RuleGroupUpdateInput, RuleGroupUncheckedUpdateInput>
    /**
     * Choose, which RuleGroup to update.
     */
    where: RuleGroupWhereUniqueInput
  }

  /**
   * RuleGroup updateMany
   */
  export type RuleGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RuleGroups.
     */
    data: XOR<RuleGroupUpdateManyMutationInput, RuleGroupUncheckedUpdateManyInput>
    /**
     * Filter which RuleGroups to update
     */
    where?: RuleGroupWhereInput
    /**
     * Limit how many RuleGroups to update.
     */
    limit?: number
  }

  /**
   * RuleGroup updateManyAndReturn
   */
  export type RuleGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * The data used to update RuleGroups.
     */
    data: XOR<RuleGroupUpdateManyMutationInput, RuleGroupUncheckedUpdateManyInput>
    /**
     * Filter which RuleGroups to update
     */
    where?: RuleGroupWhereInput
    /**
     * Limit how many RuleGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RuleGroup upsert
   */
  export type RuleGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the RuleGroup to update in case it exists.
     */
    where: RuleGroupWhereUniqueInput
    /**
     * In case the RuleGroup found by the `where` argument doesn't exist, create a new RuleGroup with this data.
     */
    create: XOR<RuleGroupCreateInput, RuleGroupUncheckedCreateInput>
    /**
     * In case the RuleGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RuleGroupUpdateInput, RuleGroupUncheckedUpdateInput>
  }

  /**
   * RuleGroup delete
   */
  export type RuleGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    /**
     * Filter which RuleGroup to delete.
     */
    where: RuleGroupWhereUniqueInput
  }

  /**
   * RuleGroup deleteMany
   */
  export type RuleGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RuleGroups to delete
     */
    where?: RuleGroupWhereInput
    /**
     * Limit how many RuleGroups to delete.
     */
    limit?: number
  }

  /**
   * RuleGroup.rules
   */
  export type RuleGroup$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    where?: RuleWhereInput
    orderBy?: RuleOrderByWithRelationInput | RuleOrderByWithRelationInput[]
    cursor?: RuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RuleScalarFieldEnum | RuleScalarFieldEnum[]
  }

  /**
   * RuleGroup.emailTemplate
   */
  export type RuleGroup$emailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * RuleGroup without action
   */
  export type RuleGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
  }


  /**
   * Model CommandMatch
   */

  export type AggregateCommandMatch = {
    _count: CommandMatchCountAggregateOutputType | null
    _avg: CommandMatchAvgAggregateOutputType | null
    _sum: CommandMatchSumAggregateOutputType | null
    _min: CommandMatchMinAggregateOutputType | null
    _max: CommandMatchMaxAggregateOutputType | null
  }

  export type CommandMatchAvgAggregateOutputType = {
    id: number | null
    logId: number | null
    commandId: number | null
    ruleId: number | null
    addressedBy: number | null
  }

  export type CommandMatchSumAggregateOutputType = {
    id: number | null
    logId: number | null
    commandId: number | null
    ruleId: number | null
    addressedBy: number | null
  }

  export type CommandMatchMinAggregateOutputType = {
    id: number | null
    logId: number | null
    logType: string | null
    commandId: number | null
    ruleId: number | null
    commandText: string | null
    logEntry: string | null
    timestamp: Date | null
    addressed: boolean | null
    addressedBy: number | null
    addressedAt: Date | null
    notes: string | null
    emailSent: boolean | null
  }

  export type CommandMatchMaxAggregateOutputType = {
    id: number | null
    logId: number | null
    logType: string | null
    commandId: number | null
    ruleId: number | null
    commandText: string | null
    logEntry: string | null
    timestamp: Date | null
    addressed: boolean | null
    addressedBy: number | null
    addressedAt: Date | null
    notes: string | null
    emailSent: boolean | null
  }

  export type CommandMatchCountAggregateOutputType = {
    id: number
    logId: number
    logType: number
    commandId: number
    ruleId: number
    commandText: number
    logEntry: number
    timestamp: number
    addressed: number
    addressedBy: number
    addressedAt: number
    notes: number
    emailSent: number
    _all: number
  }


  export type CommandMatchAvgAggregateInputType = {
    id?: true
    logId?: true
    commandId?: true
    ruleId?: true
    addressedBy?: true
  }

  export type CommandMatchSumAggregateInputType = {
    id?: true
    logId?: true
    commandId?: true
    ruleId?: true
    addressedBy?: true
  }

  export type CommandMatchMinAggregateInputType = {
    id?: true
    logId?: true
    logType?: true
    commandId?: true
    ruleId?: true
    commandText?: true
    logEntry?: true
    timestamp?: true
    addressed?: true
    addressedBy?: true
    addressedAt?: true
    notes?: true
    emailSent?: true
  }

  export type CommandMatchMaxAggregateInputType = {
    id?: true
    logId?: true
    logType?: true
    commandId?: true
    ruleId?: true
    commandText?: true
    logEntry?: true
    timestamp?: true
    addressed?: true
    addressedBy?: true
    addressedAt?: true
    notes?: true
    emailSent?: true
  }

  export type CommandMatchCountAggregateInputType = {
    id?: true
    logId?: true
    logType?: true
    commandId?: true
    ruleId?: true
    commandText?: true
    logEntry?: true
    timestamp?: true
    addressed?: true
    addressedBy?: true
    addressedAt?: true
    notes?: true
    emailSent?: true
    _all?: true
  }

  export type CommandMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandMatch to aggregate.
     */
    where?: CommandMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandMatches to fetch.
     */
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandMatches
    **/
    _count?: true | CommandMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandMatchMaxAggregateInputType
  }

  export type GetCommandMatchAggregateType<T extends CommandMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandMatch[P]>
      : GetScalarType<T[P], AggregateCommandMatch[P]>
  }




  export type CommandMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandMatchWhereInput
    orderBy?: CommandMatchOrderByWithAggregationInput | CommandMatchOrderByWithAggregationInput[]
    by: CommandMatchScalarFieldEnum[] | CommandMatchScalarFieldEnum
    having?: CommandMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandMatchCountAggregateInputType | true
    _avg?: CommandMatchAvgAggregateInputType
    _sum?: CommandMatchSumAggregateInputType
    _min?: CommandMatchMinAggregateInputType
    _max?: CommandMatchMaxAggregateInputType
  }

  export type CommandMatchGroupByOutputType = {
    id: number
    logId: number
    logType: string
    commandId: number
    ruleId: number
    commandText: string
    logEntry: string
    timestamp: Date
    addressed: boolean
    addressedBy: number | null
    addressedAt: Date
    notes: string | null
    emailSent: boolean
    _count: CommandMatchCountAggregateOutputType | null
    _avg: CommandMatchAvgAggregateOutputType | null
    _sum: CommandMatchSumAggregateOutputType | null
    _min: CommandMatchMinAggregateOutputType | null
    _max: CommandMatchMaxAggregateOutputType | null
  }

  type GetCommandMatchGroupByPayload<T extends CommandMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandMatchGroupByOutputType[P]>
            : GetScalarType<T[P], CommandMatchGroupByOutputType[P]>
        }
      >
    >


  export type CommandMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logId?: boolean
    logType?: boolean
    commandId?: boolean
    ruleId?: boolean
    commandText?: boolean
    logEntry?: boolean
    timestamp?: boolean
    addressed?: boolean
    addressedBy?: boolean
    addressedAt?: boolean
    notes?: boolean
    emailSent?: boolean
    addressedByUser?: boolean | CommandMatch$addressedByUserArgs<ExtArgs>
    command?: boolean | CommandDefaultArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
    User?: boolean | CommandMatch$UserArgs<ExtArgs>
    _count?: boolean | CommandMatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandMatch"]>

  export type CommandMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logId?: boolean
    logType?: boolean
    commandId?: boolean
    ruleId?: boolean
    commandText?: boolean
    logEntry?: boolean
    timestamp?: boolean
    addressed?: boolean
    addressedBy?: boolean
    addressedAt?: boolean
    notes?: boolean
    emailSent?: boolean
    addressedByUser?: boolean | CommandMatch$addressedByUserArgs<ExtArgs>
    command?: boolean | CommandDefaultArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandMatch"]>

  export type CommandMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logId?: boolean
    logType?: boolean
    commandId?: boolean
    ruleId?: boolean
    commandText?: boolean
    logEntry?: boolean
    timestamp?: boolean
    addressed?: boolean
    addressedBy?: boolean
    addressedAt?: boolean
    notes?: boolean
    emailSent?: boolean
    addressedByUser?: boolean | CommandMatch$addressedByUserArgs<ExtArgs>
    command?: boolean | CommandDefaultArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandMatch"]>

  export type CommandMatchSelectScalar = {
    id?: boolean
    logId?: boolean
    logType?: boolean
    commandId?: boolean
    ruleId?: boolean
    commandText?: boolean
    logEntry?: boolean
    timestamp?: boolean
    addressed?: boolean
    addressedBy?: boolean
    addressedAt?: boolean
    notes?: boolean
    emailSent?: boolean
  }

  export type CommandMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logId" | "logType" | "commandId" | "ruleId" | "commandText" | "logEntry" | "timestamp" | "addressed" | "addressedBy" | "addressedAt" | "notes" | "emailSent", ExtArgs["result"]["commandMatch"]>
  export type CommandMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addressedByUser?: boolean | CommandMatch$addressedByUserArgs<ExtArgs>
    command?: boolean | CommandDefaultArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
    User?: boolean | CommandMatch$UserArgs<ExtArgs>
    _count?: boolean | CommandMatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommandMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addressedByUser?: boolean | CommandMatch$addressedByUserArgs<ExtArgs>
    command?: boolean | CommandDefaultArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }
  export type CommandMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addressedByUser?: boolean | CommandMatch$addressedByUserArgs<ExtArgs>
    command?: boolean | CommandDefaultArgs<ExtArgs>
    rule?: boolean | RuleDefaultArgs<ExtArgs>
  }

  export type $CommandMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommandMatch"
    objects: {
      addressedByUser: Prisma.$UserPayload<ExtArgs> | null
      command: Prisma.$CommandPayload<ExtArgs>
      rule: Prisma.$RulePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logId: number
      logType: string
      commandId: number
      ruleId: number
      commandText: string
      logEntry: string
      timestamp: Date
      addressed: boolean
      addressedBy: number | null
      addressedAt: Date
      notes: string | null
      emailSent: boolean
    }, ExtArgs["result"]["commandMatch"]>
    composites: {}
  }

  type CommandMatchGetPayload<S extends boolean | null | undefined | CommandMatchDefaultArgs> = $Result.GetResult<Prisma.$CommandMatchPayload, S>

  type CommandMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandMatchCountAggregateInputType | true
    }

  export interface CommandMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommandMatch'], meta: { name: 'CommandMatch' } }
    /**
     * Find zero or one CommandMatch that matches the filter.
     * @param {CommandMatchFindUniqueArgs} args - Arguments to find a CommandMatch
     * @example
     * // Get one CommandMatch
     * const commandMatch = await prisma.commandMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandMatchFindUniqueArgs>(args: SelectSubset<T, CommandMatchFindUniqueArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CommandMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandMatchFindUniqueOrThrowArgs} args - Arguments to find a CommandMatch
     * @example
     * // Get one CommandMatch
     * const commandMatch = await prisma.commandMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CommandMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchFindFirstArgs} args - Arguments to find a CommandMatch
     * @example
     * // Get one CommandMatch
     * const commandMatch = await prisma.commandMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandMatchFindFirstArgs>(args?: SelectSubset<T, CommandMatchFindFirstArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CommandMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchFindFirstOrThrowArgs} args - Arguments to find a CommandMatch
     * @example
     * // Get one CommandMatch
     * const commandMatch = await prisma.commandMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CommandMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandMatches
     * const commandMatches = await prisma.commandMatch.findMany()
     * 
     * // Get first 10 CommandMatches
     * const commandMatches = await prisma.commandMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandMatchWithIdOnly = await prisma.commandMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandMatchFindManyArgs>(args?: SelectSubset<T, CommandMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CommandMatch.
     * @param {CommandMatchCreateArgs} args - Arguments to create a CommandMatch.
     * @example
     * // Create one CommandMatch
     * const CommandMatch = await prisma.commandMatch.create({
     *   data: {
     *     // ... data to create a CommandMatch
     *   }
     * })
     * 
     */
    create<T extends CommandMatchCreateArgs>(args: SelectSubset<T, CommandMatchCreateArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CommandMatches.
     * @param {CommandMatchCreateManyArgs} args - Arguments to create many CommandMatches.
     * @example
     * // Create many CommandMatches
     * const commandMatch = await prisma.commandMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandMatchCreateManyArgs>(args?: SelectSubset<T, CommandMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommandMatches and returns the data saved in the database.
     * @param {CommandMatchCreateManyAndReturnArgs} args - Arguments to create many CommandMatches.
     * @example
     * // Create many CommandMatches
     * const commandMatch = await prisma.commandMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommandMatches and only return the `id`
     * const commandMatchWithIdOnly = await prisma.commandMatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommandMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, CommandMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CommandMatch.
     * @param {CommandMatchDeleteArgs} args - Arguments to delete one CommandMatch.
     * @example
     * // Delete one CommandMatch
     * const CommandMatch = await prisma.commandMatch.delete({
     *   where: {
     *     // ... filter to delete one CommandMatch
     *   }
     * })
     * 
     */
    delete<T extends CommandMatchDeleteArgs>(args: SelectSubset<T, CommandMatchDeleteArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CommandMatch.
     * @param {CommandMatchUpdateArgs} args - Arguments to update one CommandMatch.
     * @example
     * // Update one CommandMatch
     * const commandMatch = await prisma.commandMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandMatchUpdateArgs>(args: SelectSubset<T, CommandMatchUpdateArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CommandMatches.
     * @param {CommandMatchDeleteManyArgs} args - Arguments to filter CommandMatches to delete.
     * @example
     * // Delete a few CommandMatches
     * const { count } = await prisma.commandMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandMatchDeleteManyArgs>(args?: SelectSubset<T, CommandMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandMatches
     * const commandMatch = await prisma.commandMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandMatchUpdateManyArgs>(args: SelectSubset<T, CommandMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandMatches and returns the data updated in the database.
     * @param {CommandMatchUpdateManyAndReturnArgs} args - Arguments to update many CommandMatches.
     * @example
     * // Update many CommandMatches
     * const commandMatch = await prisma.commandMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommandMatches and only return the `id`
     * const commandMatchWithIdOnly = await prisma.commandMatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommandMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, CommandMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CommandMatch.
     * @param {CommandMatchUpsertArgs} args - Arguments to update or create a CommandMatch.
     * @example
     * // Update or create a CommandMatch
     * const commandMatch = await prisma.commandMatch.upsert({
     *   create: {
     *     // ... data to create a CommandMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandMatch we want to update
     *   }
     * })
     */
    upsert<T extends CommandMatchUpsertArgs>(args: SelectSubset<T, CommandMatchUpsertArgs<ExtArgs>>): Prisma__CommandMatchClient<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CommandMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchCountArgs} args - Arguments to filter CommandMatches to count.
     * @example
     * // Count the number of CommandMatches
     * const count = await prisma.commandMatch.count({
     *   where: {
     *     // ... the filter for the CommandMatches we want to count
     *   }
     * })
    **/
    count<T extends CommandMatchCountArgs>(
      args?: Subset<T, CommandMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandMatchAggregateArgs>(args: Subset<T, CommandMatchAggregateArgs>): Prisma.PrismaPromise<GetCommandMatchAggregateType<T>>

    /**
     * Group by CommandMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandMatchGroupByArgs['orderBy'] }
        : { orderBy?: CommandMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommandMatch model
   */
  readonly fields: CommandMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addressedByUser<T extends CommandMatch$addressedByUserArgs<ExtArgs> = {}>(args?: Subset<T, CommandMatch$addressedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    command<T extends CommandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandDefaultArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    rule<T extends RuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RuleDefaultArgs<ExtArgs>>): Prisma__RuleClient<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends CommandMatch$UserArgs<ExtArgs> = {}>(args?: Subset<T, CommandMatch$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommandMatch model
   */ 
  interface CommandMatchFieldRefs {
    readonly id: FieldRef<"CommandMatch", 'Int'>
    readonly logId: FieldRef<"CommandMatch", 'Int'>
    readonly logType: FieldRef<"CommandMatch", 'String'>
    readonly commandId: FieldRef<"CommandMatch", 'Int'>
    readonly ruleId: FieldRef<"CommandMatch", 'Int'>
    readonly commandText: FieldRef<"CommandMatch", 'String'>
    readonly logEntry: FieldRef<"CommandMatch", 'String'>
    readonly timestamp: FieldRef<"CommandMatch", 'DateTime'>
    readonly addressed: FieldRef<"CommandMatch", 'Boolean'>
    readonly addressedBy: FieldRef<"CommandMatch", 'Int'>
    readonly addressedAt: FieldRef<"CommandMatch", 'DateTime'>
    readonly notes: FieldRef<"CommandMatch", 'String'>
    readonly emailSent: FieldRef<"CommandMatch", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CommandMatch findUnique
   */
  export type CommandMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * Filter, which CommandMatch to fetch.
     */
    where: CommandMatchWhereUniqueInput
  }

  /**
   * CommandMatch findUniqueOrThrow
   */
  export type CommandMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * Filter, which CommandMatch to fetch.
     */
    where: CommandMatchWhereUniqueInput
  }

  /**
   * CommandMatch findFirst
   */
  export type CommandMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * Filter, which CommandMatch to fetch.
     */
    where?: CommandMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandMatches to fetch.
     */
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandMatches.
     */
    cursor?: CommandMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandMatches.
     */
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * CommandMatch findFirstOrThrow
   */
  export type CommandMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * Filter, which CommandMatch to fetch.
     */
    where?: CommandMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandMatches to fetch.
     */
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandMatches.
     */
    cursor?: CommandMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandMatches.
     */
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * CommandMatch findMany
   */
  export type CommandMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * Filter, which CommandMatches to fetch.
     */
    where?: CommandMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandMatches to fetch.
     */
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandMatches.
     */
    cursor?: CommandMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandMatches.
     */
    skip?: number
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * CommandMatch create
   */
  export type CommandMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a CommandMatch.
     */
    data: XOR<CommandMatchCreateInput, CommandMatchUncheckedCreateInput>
  }

  /**
   * CommandMatch createMany
   */
  export type CommandMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommandMatches.
     */
    data: CommandMatchCreateManyInput | CommandMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommandMatch createManyAndReturn
   */
  export type CommandMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * The data used to create many CommandMatches.
     */
    data: CommandMatchCreateManyInput | CommandMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommandMatch update
   */
  export type CommandMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a CommandMatch.
     */
    data: XOR<CommandMatchUpdateInput, CommandMatchUncheckedUpdateInput>
    /**
     * Choose, which CommandMatch to update.
     */
    where: CommandMatchWhereUniqueInput
  }

  /**
   * CommandMatch updateMany
   */
  export type CommandMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommandMatches.
     */
    data: XOR<CommandMatchUpdateManyMutationInput, CommandMatchUncheckedUpdateManyInput>
    /**
     * Filter which CommandMatches to update
     */
    where?: CommandMatchWhereInput
    /**
     * Limit how many CommandMatches to update.
     */
    limit?: number
  }

  /**
   * CommandMatch updateManyAndReturn
   */
  export type CommandMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * The data used to update CommandMatches.
     */
    data: XOR<CommandMatchUpdateManyMutationInput, CommandMatchUncheckedUpdateManyInput>
    /**
     * Filter which CommandMatches to update
     */
    where?: CommandMatchWhereInput
    /**
     * Limit how many CommandMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommandMatch upsert
   */
  export type CommandMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the CommandMatch to update in case it exists.
     */
    where: CommandMatchWhereUniqueInput
    /**
     * In case the CommandMatch found by the `where` argument doesn't exist, create a new CommandMatch with this data.
     */
    create: XOR<CommandMatchCreateInput, CommandMatchUncheckedCreateInput>
    /**
     * In case the CommandMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandMatchUpdateInput, CommandMatchUncheckedUpdateInput>
  }

  /**
   * CommandMatch delete
   */
  export type CommandMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    /**
     * Filter which CommandMatch to delete.
     */
    where: CommandMatchWhereUniqueInput
  }

  /**
   * CommandMatch deleteMany
   */
  export type CommandMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandMatches to delete
     */
    where?: CommandMatchWhereInput
    /**
     * Limit how many CommandMatches to delete.
     */
    limit?: number
  }

  /**
   * CommandMatch.addressedByUser
   */
  export type CommandMatch$addressedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CommandMatch.User
   */
  export type CommandMatch$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * CommandMatch without action
   */
  export type CommandMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    targetId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    targetId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    actionType: string | null
    targetType: string | null
    targetId: number | null
    details: string | null
    timestamp: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    actionType: string | null
    targetType: string | null
    targetId: number | null
    details: string | null
    timestamp: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    actionType: number
    targetType: number
    targetId: number
    details: number
    timestamp: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    userId?: true
    targetId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    userId?: true
    targetId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    targetType?: true
    targetId?: true
    details?: true
    timestamp?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    targetType?: true
    targetId?: true
    details?: true
    timestamp?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    targetType?: true
    targetId?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    userId: number
    actionType: string
    targetType: string
    targetId: number | null
    details: string | null
    timestamp: Date
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    targetType?: boolean
    targetId?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    targetType?: boolean
    targetId?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    targetType?: boolean
    targetId?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    actionType?: boolean
    targetType?: boolean
    targetId?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "actionType" | "targetType" | "targetId" | "details" | "timestamp", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      actionType: string
      targetType: string
      targetId: number | null
      details: string | null
      timestamp: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly userId: FieldRef<"ActivityLog", 'Int'>
    readonly actionType: FieldRef<"ActivityLog", 'String'>
    readonly targetType: FieldRef<"ActivityLog", 'String'>
    readonly targetId: FieldRef<"ActivityLog", 'Int'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly timestamp: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _avg: EmailTemplateAvgAggregateOutputType | null
    _sum: EmailTemplateSumAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type EmailTemplateSumAggregateOutputType = {
    id: number | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    subject: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    subject: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateAvgAggregateInputType = {
    id?: true
  }

  export type EmailTemplateSumAggregateInputType = {
    id?: true
  }

  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _avg?: EmailTemplateAvgAggregateInputType
    _sum?: EmailTemplateSumAggregateInputType
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: number
    name: string
    subject: string
    body: string
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _avg: EmailTemplateAvgAggregateOutputType | null
    _sum: EmailTemplateSumAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AlertCondition?: boolean | EmailTemplate$AlertConditionArgs<ExtArgs>
    Command?: boolean | EmailTemplate$CommandArgs<ExtArgs>
    Rule?: boolean | EmailTemplate$RuleArgs<ExtArgs>
    RuleGroup?: boolean | EmailTemplate$RuleGroupArgs<ExtArgs>
    SavedQuery?: boolean | EmailTemplate$SavedQueryArgs<ExtArgs>
    assignedUsers?: boolean | EmailTemplate$assignedUsersArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "body" | "createdAt" | "updatedAt", ExtArgs["result"]["emailTemplate"]>
  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AlertCondition?: boolean | EmailTemplate$AlertConditionArgs<ExtArgs>
    Command?: boolean | EmailTemplate$CommandArgs<ExtArgs>
    Rule?: boolean | EmailTemplate$RuleArgs<ExtArgs>
    RuleGroup?: boolean | EmailTemplate$RuleGroupArgs<ExtArgs>
    SavedQuery?: boolean | EmailTemplate$SavedQueryArgs<ExtArgs>
    assignedUsers?: boolean | EmailTemplate$assignedUsersArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      AlertCondition: Prisma.$AlertConditionPayload<ExtArgs>[]
      Command: Prisma.$CommandPayload<ExtArgs>[]
      Rule: Prisma.$RulePayload<ExtArgs>[]
      RuleGroup: Prisma.$RuleGroupPayload<ExtArgs>[]
      SavedQuery: Prisma.$SavedQueryPayload<ExtArgs>[]
      assignedUsers: Prisma.$UserEmailTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      subject: string
      body: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AlertCondition<T extends EmailTemplate$AlertConditionArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$AlertConditionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Command<T extends EmailTemplate$CommandArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$CommandArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Rule<T extends EmailTemplate$RuleArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$RuleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RuleGroup<T extends EmailTemplate$RuleGroupArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$RuleGroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RuleGroupPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    SavedQuery<T extends EmailTemplate$SavedQueryArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$SavedQueryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    assignedUsers<T extends EmailTemplate$assignedUsersArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$assignedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'Int'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly body: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate.AlertCondition
   */
  export type EmailTemplate$AlertConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    where?: AlertConditionWhereInput
    orderBy?: AlertConditionOrderByWithRelationInput | AlertConditionOrderByWithRelationInput[]
    cursor?: AlertConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertConditionScalarFieldEnum | AlertConditionScalarFieldEnum[]
  }

  /**
   * EmailTemplate.Command
   */
  export type EmailTemplate$CommandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * EmailTemplate.Rule
   */
  export type EmailTemplate$RuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rule
     */
    omit?: RuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleInclude<ExtArgs> | null
    where?: RuleWhereInput
    orderBy?: RuleOrderByWithRelationInput | RuleOrderByWithRelationInput[]
    cursor?: RuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RuleScalarFieldEnum | RuleScalarFieldEnum[]
  }

  /**
   * EmailTemplate.RuleGroup
   */
  export type EmailTemplate$RuleGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RuleGroup
     */
    select?: RuleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RuleGroup
     */
    omit?: RuleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RuleGroupInclude<ExtArgs> | null
    where?: RuleGroupWhereInput
    orderBy?: RuleGroupOrderByWithRelationInput | RuleGroupOrderByWithRelationInput[]
    cursor?: RuleGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RuleGroupScalarFieldEnum | RuleGroupScalarFieldEnum[]
  }

  /**
   * EmailTemplate.SavedQuery
   */
  export type EmailTemplate$SavedQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    where?: SavedQueryWhereInput
    orderBy?: SavedQueryOrderByWithRelationInput | SavedQueryOrderByWithRelationInput[]
    cursor?: SavedQueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedQueryScalarFieldEnum | SavedQueryScalarFieldEnum[]
  }

  /**
   * EmailTemplate.assignedUsers
   */
  export type EmailTemplate$assignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    where?: UserEmailTemplateWhereInput
    orderBy?: UserEmailTemplateOrderByWithRelationInput | UserEmailTemplateOrderByWithRelationInput[]
    cursor?: UserEmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEmailTemplateScalarFieldEnum | UserEmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    Mobile: number | null
    MobileContact: number | null
    SecondMobile: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    Mobile: number | null
    MobileContact: number | null
    SecondMobile: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    Mobile: number | null
    PrimaryContact: string | null
    MobileContact: number | null
    Relationship: string | null
    SecondContact: string | null
    SecondMobile: number | null
    SecondRelationship: string | null
    Remarks: string | null
    ndafile: string | null
    ndasubmissiondate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    Mobile: number | null
    PrimaryContact: string | null
    MobileContact: number | null
    Relationship: string | null
    SecondContact: string | null
    SecondMobile: number | null
    SecondRelationship: string | null
    Remarks: string | null
    ndafile: string | null
    ndasubmissiondate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    role: number
    Mobile: number
    PrimaryContact: number
    MobileContact: number
    Relationship: number
    SecondContact: number
    SecondMobile: number
    SecondRelationship: number
    Remarks: number
    ndafile: number
    ndasubmissiondate: number
    createdAt: number
    updatedAt: number
    location: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    Mobile?: true
    MobileContact?: true
    SecondMobile?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    Mobile?: true
    MobileContact?: true
    SecondMobile?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    Mobile?: true
    PrimaryContact?: true
    MobileContact?: true
    Relationship?: true
    SecondContact?: true
    SecondMobile?: true
    SecondRelationship?: true
    Remarks?: true
    ndafile?: true
    ndasubmissiondate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    Mobile?: true
    PrimaryContact?: true
    MobileContact?: true
    Relationship?: true
    SecondContact?: true
    SecondMobile?: true
    SecondRelationship?: true
    Remarks?: true
    ndafile?: true
    ndasubmissiondate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    role?: true
    Mobile?: true
    PrimaryContact?: true
    MobileContact?: true
    Relationship?: true
    SecondContact?: true
    SecondMobile?: true
    SecondRelationship?: true
    Remarks?: true
    ndafile?: true
    ndasubmissiondate?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string | null
    password: string
    email: string | null
    role: string[]
    Mobile: number | null
    PrimaryContact: string | null
    MobileContact: number | null
    Relationship: string | null
    SecondContact: string | null
    SecondMobile: number | null
    SecondRelationship: string | null
    Remarks: string | null
    ndafile: string | null
    ndasubmissiondate: Date
    createdAt: Date
    updatedAt: Date
    location: string[]
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    Mobile?: boolean
    PrimaryContact?: boolean
    MobileContact?: boolean
    Relationship?: boolean
    SecondContact?: boolean
    SecondMobile?: boolean
    SecondRelationship?: boolean
    Remarks?: boolean
    ndafile?: boolean
    ndasubmissiondate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
    ActivityLog?: boolean | User$ActivityLogArgs<ExtArgs>
    CommandMatch?: boolean | User$CommandMatchArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    DriveFile?: boolean | User$DriveFileArgs<ExtArgs>
    grantedPermissions?: boolean | User$grantedPermissionsArgs<ExtArgs>
    DriveFilePermission?: boolean | User$DriveFilePermissionArgs<ExtArgs>
    DriveFolder?: boolean | User$DriveFolderArgs<ExtArgs>
    Feedback?: boolean | User$FeedbackArgs<ExtArgs>
    FeedbackRecipient?: boolean | User$FeedbackRecipientArgs<ExtArgs>
    GroupMember?: boolean | User$GroupMemberArgs<ExtArgs>
    Message?: boolean | User$MessageArgs<ExtArgs>
    NotificationRead?: boolean | User$NotificationReadArgs<ExtArgs>
    ProjectAssignment?: boolean | User$ProjectAssignmentArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    createdTickets?: boolean | User$createdTicketsArgs<ExtArgs>
    TeamLeader?: boolean | User$TeamLeaderArgs<ExtArgs>
    TeamMember?: boolean | User$TeamMemberArgs<ExtArgs>
    TicketAttachment?: boolean | User$TicketAttachmentArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    emailTemplates?: boolean | User$emailTemplatesArgs<ExtArgs>
    UserPermission?: boolean | User$UserPermissionArgs<ExtArgs>
    audit_steps?: boolean | User$audit_stepsArgs<ExtArgs>
    receivedPermissions?: boolean | User$receivedPermissionsArgs<ExtArgs>
    addressedMatches?: boolean | User$addressedMatchesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    Mobile?: boolean
    PrimaryContact?: boolean
    MobileContact?: boolean
    Relationship?: boolean
    SecondContact?: boolean
    SecondMobile?: boolean
    SecondRelationship?: boolean
    Remarks?: boolean
    ndafile?: boolean
    ndasubmissiondate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    Mobile?: boolean
    PrimaryContact?: boolean
    MobileContact?: boolean
    Relationship?: boolean
    SecondContact?: boolean
    SecondMobile?: boolean
    SecondRelationship?: boolean
    Remarks?: boolean
    ndafile?: boolean
    ndasubmissiondate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    Mobile?: boolean
    PrimaryContact?: boolean
    MobileContact?: boolean
    Relationship?: boolean
    SecondContact?: boolean
    SecondMobile?: boolean
    SecondRelationship?: boolean
    Remarks?: boolean
    ndafile?: boolean
    ndasubmissiondate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "email" | "role" | "Mobile" | "PrimaryContact" | "MobileContact" | "Relationship" | "SecondContact" | "SecondMobile" | "SecondRelationship" | "Remarks" | "ndafile" | "ndasubmissiondate" | "createdAt" | "updatedAt" | "location", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | User$ActivityLogArgs<ExtArgs>
    CommandMatch?: boolean | User$CommandMatchArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    DriveFile?: boolean | User$DriveFileArgs<ExtArgs>
    grantedPermissions?: boolean | User$grantedPermissionsArgs<ExtArgs>
    DriveFilePermission?: boolean | User$DriveFilePermissionArgs<ExtArgs>
    DriveFolder?: boolean | User$DriveFolderArgs<ExtArgs>
    Feedback?: boolean | User$FeedbackArgs<ExtArgs>
    FeedbackRecipient?: boolean | User$FeedbackRecipientArgs<ExtArgs>
    GroupMember?: boolean | User$GroupMemberArgs<ExtArgs>
    Message?: boolean | User$MessageArgs<ExtArgs>
    NotificationRead?: boolean | User$NotificationReadArgs<ExtArgs>
    ProjectAssignment?: boolean | User$ProjectAssignmentArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    createdTickets?: boolean | User$createdTicketsArgs<ExtArgs>
    TeamLeader?: boolean | User$TeamLeaderArgs<ExtArgs>
    TeamMember?: boolean | User$TeamMemberArgs<ExtArgs>
    TicketAttachment?: boolean | User$TicketAttachmentArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    emailTemplates?: boolean | User$emailTemplatesArgs<ExtArgs>
    UserPermission?: boolean | User$UserPermissionArgs<ExtArgs>
    audit_steps?: boolean | User$audit_stepsArgs<ExtArgs>
    receivedPermissions?: boolean | User$receivedPermissionsArgs<ExtArgs>
    addressedMatches?: boolean | User$addressedMatchesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ActivityLog: Prisma.$ActivityLogPayload<ExtArgs>[]
      CommandMatch: Prisma.$CommandMatchPayload<ExtArgs>[]
      devices: Prisma.$DeviceUserPayload<ExtArgs>[]
      DriveFile: Prisma.$DriveFilePayload<ExtArgs>[]
      grantedPermissions: Prisma.$DriveFilePermissionPayload<ExtArgs>[]
      DriveFilePermission: Prisma.$DriveFilePermissionPayload<ExtArgs>[]
      DriveFolder: Prisma.$DriveFolderPayload<ExtArgs>[]
      Feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      FeedbackRecipient: Prisma.$FeedbackRecipientPayload<ExtArgs>[]
      GroupMember: Prisma.$GroupMemberPayload<ExtArgs>[]
      Message: Prisma.$MessagePayload<ExtArgs>[]
      NotificationRead: Prisma.$NotificationReadPayload<ExtArgs>[]
      ProjectAssignment: Prisma.$ProjectAssignmentPayload<ExtArgs>[]
      assignedTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      createdTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      TeamLeader: Prisma.$TeamLeaderPayload<ExtArgs>[]
      TeamMember: Prisma.$TeamMemberPayload<ExtArgs>[]
      TicketAttachment: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
      emailTemplates: Prisma.$UserEmailTemplatePayload<ExtArgs>[]
      UserPermission: Prisma.$UserPermissionPayload<ExtArgs>[]
      audit_steps: Prisma.$AuditStepPayload<ExtArgs>[]
      receivedPermissions: Prisma.$DriveFilePermissionPayload<ExtArgs>[]
      addressedMatches: Prisma.$CommandMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      password: string
      email: string | null
      role: string[]
      Mobile: number | null
      PrimaryContact: string | null
      MobileContact: number | null
      Relationship: string | null
      SecondContact: string | null
      SecondMobile: number | null
      SecondRelationship: string | null
      Remarks: string | null
      ndafile: string | null
      ndasubmissiondate: Date
      createdAt: Date
      updatedAt: Date
      location: string[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ActivityLog<T extends User$ActivityLogArgs<ExtArgs> = {}>(args?: Subset<T, User$ActivityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    CommandMatch<T extends User$CommandMatchArgs<ExtArgs> = {}>(args?: Subset<T, User$CommandMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    devices<T extends User$devicesArgs<ExtArgs> = {}>(args?: Subset<T, User$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DriveFile<T extends User$DriveFileArgs<ExtArgs> = {}>(args?: Subset<T, User$DriveFileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    grantedPermissions<T extends User$grantedPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$grantedPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DriveFilePermission<T extends User$DriveFilePermissionArgs<ExtArgs> = {}>(args?: Subset<T, User$DriveFilePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DriveFolder<T extends User$DriveFolderArgs<ExtArgs> = {}>(args?: Subset<T, User$DriveFolderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Feedback<T extends User$FeedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$FeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FeedbackRecipient<T extends User$FeedbackRecipientArgs<ExtArgs> = {}>(args?: Subset<T, User$FeedbackRecipientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    GroupMember<T extends User$GroupMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$GroupMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Message<T extends User$MessageArgs<ExtArgs> = {}>(args?: Subset<T, User$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    NotificationRead<T extends User$NotificationReadArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationReadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ProjectAssignment<T extends User$ProjectAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdTickets<T extends User$createdTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TeamLeader<T extends User$TeamLeaderArgs<ExtArgs> = {}>(args?: Subset<T, User$TeamLeaderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TeamMember<T extends User$TeamMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$TeamMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TicketAttachment<T extends User$TicketAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ticketComments<T extends User$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    emailTemplates<T extends User$emailTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$emailTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserPermission<T extends User$UserPermissionArgs<ExtArgs> = {}>(args?: Subset<T, User$UserPermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    audit_steps<T extends User$audit_stepsArgs<ExtArgs> = {}>(args?: Subset<T, User$audit_stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    receivedPermissions<T extends User$receivedPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addressedMatches<T extends User$addressedMatchesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressedMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandMatchPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String[]'>
    readonly Mobile: FieldRef<"User", 'Int'>
    readonly PrimaryContact: FieldRef<"User", 'String'>
    readonly MobileContact: FieldRef<"User", 'Int'>
    readonly Relationship: FieldRef<"User", 'String'>
    readonly SecondContact: FieldRef<"User", 'String'>
    readonly SecondMobile: FieldRef<"User", 'Int'>
    readonly SecondRelationship: FieldRef<"User", 'String'>
    readonly Remarks: FieldRef<"User", 'String'>
    readonly ndafile: FieldRef<"User", 'String'>
    readonly ndasubmissiondate: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly location: FieldRef<"User", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ActivityLog
   */
  export type User$ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.CommandMatch
   */
  export type User$CommandMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    where?: CommandMatchWhereInput
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    cursor?: CommandMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * User.devices
   */
  export type User$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceUser
     */
    omit?: DeviceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    where?: DeviceUserWhereInput
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    cursor?: DeviceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * User.DriveFile
   */
  export type User$DriveFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    where?: DriveFileWhereInput
    orderBy?: DriveFileOrderByWithRelationInput | DriveFileOrderByWithRelationInput[]
    cursor?: DriveFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFileScalarFieldEnum | DriveFileScalarFieldEnum[]
  }

  /**
   * User.grantedPermissions
   */
  export type User$grantedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    where?: DriveFilePermissionWhereInput
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    cursor?: DriveFilePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * User.DriveFilePermission
   */
  export type User$DriveFilePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    where?: DriveFilePermissionWhereInput
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    cursor?: DriveFilePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * User.DriveFolder
   */
  export type User$DriveFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    where?: DriveFolderWhereInput
    orderBy?: DriveFolderOrderByWithRelationInput | DriveFolderOrderByWithRelationInput[]
    cursor?: DriveFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFolderScalarFieldEnum | DriveFolderScalarFieldEnum[]
  }

  /**
   * User.Feedback
   */
  export type User$FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.FeedbackRecipient
   */
  export type User$FeedbackRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    where?: FeedbackRecipientWhereInput
    orderBy?: FeedbackRecipientOrderByWithRelationInput | FeedbackRecipientOrderByWithRelationInput[]
    cursor?: FeedbackRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackRecipientScalarFieldEnum | FeedbackRecipientScalarFieldEnum[]
  }

  /**
   * User.GroupMember
   */
  export type User$GroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.Message
   */
  export type User$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.NotificationRead
   */
  export type User$NotificationReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    where?: NotificationReadWhereInput
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    cursor?: NotificationReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * User.ProjectAssignment
   */
  export type User$ProjectAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    where?: ProjectAssignmentWhereInput
    orderBy?: ProjectAssignmentOrderByWithRelationInput | ProjectAssignmentOrderByWithRelationInput[]
    cursor?: ProjectAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectAssignmentScalarFieldEnum | ProjectAssignmentScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.createdTickets
   */
  export type User$createdTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.TeamLeader
   */
  export type User$TeamLeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    where?: TeamLeaderWhereInput
    orderBy?: TeamLeaderOrderByWithRelationInput | TeamLeaderOrderByWithRelationInput[]
    cursor?: TeamLeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamLeaderScalarFieldEnum | TeamLeaderScalarFieldEnum[]
  }

  /**
   * User.TeamMember
   */
  export type User$TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.TicketAttachment
   */
  export type User$TicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * User.ticketComments
   */
  export type User$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.emailTemplates
   */
  export type User$emailTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    where?: UserEmailTemplateWhereInput
    orderBy?: UserEmailTemplateOrderByWithRelationInput | UserEmailTemplateOrderByWithRelationInput[]
    cursor?: UserEmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEmailTemplateScalarFieldEnum | UserEmailTemplateScalarFieldEnum[]
  }

  /**
   * User.UserPermission
   */
  export type User$UserPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    cursor?: UserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * User.audit_steps
   */
  export type User$audit_stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    where?: AuditStepWhereInput
    orderBy?: AuditStepOrderByWithRelationInput | AuditStepOrderByWithRelationInput[]
    cursor?: AuditStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditStepScalarFieldEnum | AuditStepScalarFieldEnum[]
  }

  /**
   * User.receivedPermissions
   */
  export type User$receivedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    where?: DriveFilePermissionWhereInput
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    cursor?: DriveFilePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * User.addressedMatches
   */
  export type User$addressedMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandMatch
     */
    select?: CommandMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandMatch
     */
    omit?: CommandMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandMatchInclude<ExtArgs> | null
    where?: CommandMatchWhereInput
    orderBy?: CommandMatchOrderByWithRelationInput | CommandMatchOrderByWithRelationInput[]
    cursor?: CommandMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandMatchScalarFieldEnum | CommandMatchScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    name: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Group$membersArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Group$membersArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    messages<T extends Group$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Group$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly name: FieldRef<"Group", 'String'>
    readonly createdBy: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.messages
   */
  export type Group$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _avg: GroupMemberAvgAggregateOutputType | null
    _sum: GroupMemberSumAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type GroupMemberSumAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    joinedAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    joinedAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    userId: number
    groupId: number
    joinedAt: number
    _all: number
  }


  export type GroupMemberAvgAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type GroupMemberSumAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type GroupMemberMinAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    joinedAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    joinedAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    joinedAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _avg?: GroupMemberAvgAggregateInputType
    _sum?: GroupMemberSumAggregateInputType
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: number
    userId: number
    groupId: number
    joinedAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _avg: GroupMemberAvgAggregateOutputType | null
    _sum: GroupMemberSumAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    groupId?: boolean
    joinedAt?: boolean
  }

  export type GroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "groupId" | "joinedAt", ExtArgs["result"]["groupMember"]>
  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      groupId: number
      joinedAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMemberUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */ 
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'Int'>
    readonly userId: FieldRef<"GroupMember", 'Int'>
    readonly groupId: FieldRef<"GroupMember", 'Int'>
    readonly joinedAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMember updateManyAndReturn
   */
  export type GroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    groupId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    groupId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    content: string | null
    senderId: number | null
    groupId: number | null
    edited: boolean | null
    createdAt: Date | null
    fileAttachment: string | null
    fileOriginalName: string | null
    fileType: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    content: string | null
    senderId: number | null
    groupId: number | null
    edited: boolean | null
    createdAt: Date | null
    fileAttachment: string | null
    fileOriginalName: string | null
    fileType: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    senderId: number
    groupId: number
    edited: number
    createdAt: number
    fileAttachment: number
    fileOriginalName: number
    fileType: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    groupId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    senderId?: true
    groupId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    groupId?: true
    edited?: true
    createdAt?: true
    fileAttachment?: true
    fileOriginalName?: true
    fileType?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    groupId?: true
    edited?: true
    createdAt?: true
    fileAttachment?: true
    fileOriginalName?: true
    fileType?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    groupId?: true
    edited?: true
    createdAt?: true
    fileAttachment?: true
    fileOriginalName?: true
    fileType?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    content: string
    senderId: number
    groupId: number
    edited: boolean
    createdAt: Date
    fileAttachment: string | null
    fileOriginalName: string | null
    fileType: string | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    edited?: boolean
    createdAt?: boolean
    fileAttachment?: boolean
    fileOriginalName?: boolean
    fileType?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    edited?: boolean
    createdAt?: boolean
    fileAttachment?: boolean
    fileOriginalName?: boolean
    fileType?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    edited?: boolean
    createdAt?: boolean
    fileAttachment?: boolean
    fileOriginalName?: boolean
    fileType?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    edited?: boolean
    createdAt?: boolean
    fileAttachment?: boolean
    fileOriginalName?: boolean
    fileType?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "senderId" | "groupId" | "edited" | "createdAt" | "fileAttachment" | "fileOriginalName" | "fileType", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      senderId: number
      groupId: number
      edited: boolean
      createdAt: Date
      fileAttachment: string | null
      fileOriginalName: string | null
      fileType: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly content: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'Int'>
    readonly groupId: FieldRef<"Message", 'Int'>
    readonly edited: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly fileAttachment: FieldRef<"Message", 'String'>
    readonly fileOriginalName: FieldRef<"Message", 'String'>
    readonly fileType: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model UserEmailTemplate
   */

  export type AggregateUserEmailTemplate = {
    _count: UserEmailTemplateCountAggregateOutputType | null
    _avg: UserEmailTemplateAvgAggregateOutputType | null
    _sum: UserEmailTemplateSumAggregateOutputType | null
    _min: UserEmailTemplateMinAggregateOutputType | null
    _max: UserEmailTemplateMaxAggregateOutputType | null
  }

  export type UserEmailTemplateAvgAggregateOutputType = {
    userId: number | null
    emailTemplateId: number | null
  }

  export type UserEmailTemplateSumAggregateOutputType = {
    userId: number | null
    emailTemplateId: number | null
  }

  export type UserEmailTemplateMinAggregateOutputType = {
    userId: number | null
    emailTemplateId: number | null
    assignedAt: Date | null
  }

  export type UserEmailTemplateMaxAggregateOutputType = {
    userId: number | null
    emailTemplateId: number | null
    assignedAt: Date | null
  }

  export type UserEmailTemplateCountAggregateOutputType = {
    userId: number
    emailTemplateId: number
    assignedAt: number
    _all: number
  }


  export type UserEmailTemplateAvgAggregateInputType = {
    userId?: true
    emailTemplateId?: true
  }

  export type UserEmailTemplateSumAggregateInputType = {
    userId?: true
    emailTemplateId?: true
  }

  export type UserEmailTemplateMinAggregateInputType = {
    userId?: true
    emailTemplateId?: true
    assignedAt?: true
  }

  export type UserEmailTemplateMaxAggregateInputType = {
    userId?: true
    emailTemplateId?: true
    assignedAt?: true
  }

  export type UserEmailTemplateCountAggregateInputType = {
    userId?: true
    emailTemplateId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserEmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmailTemplate to aggregate.
     */
    where?: UserEmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmailTemplates to fetch.
     */
    orderBy?: UserEmailTemplateOrderByWithRelationInput | UserEmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEmailTemplates
    **/
    _count?: true | UserEmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserEmailTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserEmailTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEmailTemplateMaxAggregateInputType
  }

  export type GetUserEmailTemplateAggregateType<T extends UserEmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEmailTemplate[P]>
      : GetScalarType<T[P], AggregateUserEmailTemplate[P]>
  }




  export type UserEmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailTemplateWhereInput
    orderBy?: UserEmailTemplateOrderByWithAggregationInput | UserEmailTemplateOrderByWithAggregationInput[]
    by: UserEmailTemplateScalarFieldEnum[] | UserEmailTemplateScalarFieldEnum
    having?: UserEmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEmailTemplateCountAggregateInputType | true
    _avg?: UserEmailTemplateAvgAggregateInputType
    _sum?: UserEmailTemplateSumAggregateInputType
    _min?: UserEmailTemplateMinAggregateInputType
    _max?: UserEmailTemplateMaxAggregateInputType
  }

  export type UserEmailTemplateGroupByOutputType = {
    userId: number
    emailTemplateId: number
    assignedAt: Date
    _count: UserEmailTemplateCountAggregateOutputType | null
    _avg: UserEmailTemplateAvgAggregateOutputType | null
    _sum: UserEmailTemplateSumAggregateOutputType | null
    _min: UserEmailTemplateMinAggregateOutputType | null
    _max: UserEmailTemplateMaxAggregateOutputType | null
  }

  type GetUserEmailTemplateGroupByPayload<T extends UserEmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], UserEmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type UserEmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    emailTemplateId?: boolean
    assignedAt?: boolean
    emailTemplate?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmailTemplate"]>

  export type UserEmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    emailTemplateId?: boolean
    assignedAt?: boolean
    emailTemplate?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmailTemplate"]>

  export type UserEmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    emailTemplateId?: boolean
    assignedAt?: boolean
    emailTemplate?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmailTemplate"]>

  export type UserEmailTemplateSelectScalar = {
    userId?: boolean
    emailTemplateId?: boolean
    assignedAt?: boolean
  }

  export type UserEmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "emailTemplateId" | "assignedAt", ExtArgs["result"]["userEmailTemplate"]>
  export type UserEmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | EmailTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserEmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEmailTemplate"
    objects: {
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      emailTemplateId: number
      assignedAt: Date
    }, ExtArgs["result"]["userEmailTemplate"]>
    composites: {}
  }

  type UserEmailTemplateGetPayload<S extends boolean | null | undefined | UserEmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$UserEmailTemplatePayload, S>

  type UserEmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserEmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserEmailTemplateCountAggregateInputType | true
    }

  export interface UserEmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEmailTemplate'], meta: { name: 'UserEmailTemplate' } }
    /**
     * Find zero or one UserEmailTemplate that matches the filter.
     * @param {UserEmailTemplateFindUniqueArgs} args - Arguments to find a UserEmailTemplate
     * @example
     * // Get one UserEmailTemplate
     * const userEmailTemplate = await prisma.userEmailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEmailTemplateFindUniqueArgs>(args: SelectSubset<T, UserEmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserEmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserEmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a UserEmailTemplate
     * @example
     * // Get one UserEmailTemplate
     * const userEmailTemplate = await prisma.userEmailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserEmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateFindFirstArgs} args - Arguments to find a UserEmailTemplate
     * @example
     * // Get one UserEmailTemplate
     * const userEmailTemplate = await prisma.userEmailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEmailTemplateFindFirstArgs>(args?: SelectSubset<T, UserEmailTemplateFindFirstArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserEmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateFindFirstOrThrowArgs} args - Arguments to find a UserEmailTemplate
     * @example
     * // Get one UserEmailTemplate
     * const userEmailTemplate = await prisma.userEmailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserEmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEmailTemplates
     * const userEmailTemplates = await prisma.userEmailTemplate.findMany()
     * 
     * // Get first 10 UserEmailTemplates
     * const userEmailTemplates = await prisma.userEmailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userEmailTemplateWithUserIdOnly = await prisma.userEmailTemplate.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserEmailTemplateFindManyArgs>(args?: SelectSubset<T, UserEmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserEmailTemplate.
     * @param {UserEmailTemplateCreateArgs} args - Arguments to create a UserEmailTemplate.
     * @example
     * // Create one UserEmailTemplate
     * const UserEmailTemplate = await prisma.userEmailTemplate.create({
     *   data: {
     *     // ... data to create a UserEmailTemplate
     *   }
     * })
     * 
     */
    create<T extends UserEmailTemplateCreateArgs>(args: SelectSubset<T, UserEmailTemplateCreateArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserEmailTemplates.
     * @param {UserEmailTemplateCreateManyArgs} args - Arguments to create many UserEmailTemplates.
     * @example
     * // Create many UserEmailTemplates
     * const userEmailTemplate = await prisma.userEmailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEmailTemplateCreateManyArgs>(args?: SelectSubset<T, UserEmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEmailTemplates and returns the data saved in the database.
     * @param {UserEmailTemplateCreateManyAndReturnArgs} args - Arguments to create many UserEmailTemplates.
     * @example
     * // Create many UserEmailTemplates
     * const userEmailTemplate = await prisma.userEmailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEmailTemplates and only return the `userId`
     * const userEmailTemplateWithUserIdOnly = await prisma.userEmailTemplate.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserEmailTemplate.
     * @param {UserEmailTemplateDeleteArgs} args - Arguments to delete one UserEmailTemplate.
     * @example
     * // Delete one UserEmailTemplate
     * const UserEmailTemplate = await prisma.userEmailTemplate.delete({
     *   where: {
     *     // ... filter to delete one UserEmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends UserEmailTemplateDeleteArgs>(args: SelectSubset<T, UserEmailTemplateDeleteArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserEmailTemplate.
     * @param {UserEmailTemplateUpdateArgs} args - Arguments to update one UserEmailTemplate.
     * @example
     * // Update one UserEmailTemplate
     * const userEmailTemplate = await prisma.userEmailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEmailTemplateUpdateArgs>(args: SelectSubset<T, UserEmailTemplateUpdateArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserEmailTemplates.
     * @param {UserEmailTemplateDeleteManyArgs} args - Arguments to filter UserEmailTemplates to delete.
     * @example
     * // Delete a few UserEmailTemplates
     * const { count } = await prisma.userEmailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEmailTemplateDeleteManyArgs>(args?: SelectSubset<T, UserEmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEmailTemplates
     * const userEmailTemplate = await prisma.userEmailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEmailTemplateUpdateManyArgs>(args: SelectSubset<T, UserEmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmailTemplates and returns the data updated in the database.
     * @param {UserEmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many UserEmailTemplates.
     * @example
     * // Update many UserEmailTemplates
     * const userEmailTemplate = await prisma.userEmailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserEmailTemplates and only return the `userId`
     * const userEmailTemplateWithUserIdOnly = await prisma.userEmailTemplate.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserEmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, UserEmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserEmailTemplate.
     * @param {UserEmailTemplateUpsertArgs} args - Arguments to update or create a UserEmailTemplate.
     * @example
     * // Update or create a UserEmailTemplate
     * const userEmailTemplate = await prisma.userEmailTemplate.upsert({
     *   create: {
     *     // ... data to create a UserEmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends UserEmailTemplateUpsertArgs>(args: SelectSubset<T, UserEmailTemplateUpsertArgs<ExtArgs>>): Prisma__UserEmailTemplateClient<$Result.GetResult<Prisma.$UserEmailTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserEmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateCountArgs} args - Arguments to filter UserEmailTemplates to count.
     * @example
     * // Count the number of UserEmailTemplates
     * const count = await prisma.userEmailTemplate.count({
     *   where: {
     *     // ... the filter for the UserEmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends UserEmailTemplateCountArgs>(
      args?: Subset<T, UserEmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEmailTemplateAggregateArgs>(args: Subset<T, UserEmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetUserEmailTemplateAggregateType<T>>

    /**
     * Group by UserEmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: UserEmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEmailTemplate model
   */
  readonly fields: UserEmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailTemplate<T extends EmailTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplateDefaultArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEmailTemplate model
   */ 
  interface UserEmailTemplateFieldRefs {
    readonly userId: FieldRef<"UserEmailTemplate", 'Int'>
    readonly emailTemplateId: FieldRef<"UserEmailTemplate", 'Int'>
    readonly assignedAt: FieldRef<"UserEmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEmailTemplate findUnique
   */
  export type UserEmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserEmailTemplate to fetch.
     */
    where: UserEmailTemplateWhereUniqueInput
  }

  /**
   * UserEmailTemplate findUniqueOrThrow
   */
  export type UserEmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserEmailTemplate to fetch.
     */
    where: UserEmailTemplateWhereUniqueInput
  }

  /**
   * UserEmailTemplate findFirst
   */
  export type UserEmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserEmailTemplate to fetch.
     */
    where?: UserEmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmailTemplates to fetch.
     */
    orderBy?: UserEmailTemplateOrderByWithRelationInput | UserEmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmailTemplates.
     */
    cursor?: UserEmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmailTemplates.
     */
    distinct?: UserEmailTemplateScalarFieldEnum | UserEmailTemplateScalarFieldEnum[]
  }

  /**
   * UserEmailTemplate findFirstOrThrow
   */
  export type UserEmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserEmailTemplate to fetch.
     */
    where?: UserEmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmailTemplates to fetch.
     */
    orderBy?: UserEmailTemplateOrderByWithRelationInput | UserEmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmailTemplates.
     */
    cursor?: UserEmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmailTemplates.
     */
    distinct?: UserEmailTemplateScalarFieldEnum | UserEmailTemplateScalarFieldEnum[]
  }

  /**
   * UserEmailTemplate findMany
   */
  export type UserEmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserEmailTemplates to fetch.
     */
    where?: UserEmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmailTemplates to fetch.
     */
    orderBy?: UserEmailTemplateOrderByWithRelationInput | UserEmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEmailTemplates.
     */
    cursor?: UserEmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmailTemplates.
     */
    skip?: number
    distinct?: UserEmailTemplateScalarFieldEnum | UserEmailTemplateScalarFieldEnum[]
  }

  /**
   * UserEmailTemplate create
   */
  export type UserEmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEmailTemplate.
     */
    data: XOR<UserEmailTemplateCreateInput, UserEmailTemplateUncheckedCreateInput>
  }

  /**
   * UserEmailTemplate createMany
   */
  export type UserEmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEmailTemplates.
     */
    data: UserEmailTemplateCreateManyInput | UserEmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEmailTemplate createManyAndReturn
   */
  export type UserEmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many UserEmailTemplates.
     */
    data: UserEmailTemplateCreateManyInput | UserEmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmailTemplate update
   */
  export type UserEmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEmailTemplate.
     */
    data: XOR<UserEmailTemplateUpdateInput, UserEmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which UserEmailTemplate to update.
     */
    where: UserEmailTemplateWhereUniqueInput
  }

  /**
   * UserEmailTemplate updateMany
   */
  export type UserEmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEmailTemplates.
     */
    data: XOR<UserEmailTemplateUpdateManyMutationInput, UserEmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which UserEmailTemplates to update
     */
    where?: UserEmailTemplateWhereInput
    /**
     * Limit how many UserEmailTemplates to update.
     */
    limit?: number
  }

  /**
   * UserEmailTemplate updateManyAndReturn
   */
  export type UserEmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update UserEmailTemplates.
     */
    data: XOR<UserEmailTemplateUpdateManyMutationInput, UserEmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which UserEmailTemplates to update
     */
    where?: UserEmailTemplateWhereInput
    /**
     * Limit how many UserEmailTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmailTemplate upsert
   */
  export type UserEmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEmailTemplate to update in case it exists.
     */
    where: UserEmailTemplateWhereUniqueInput
    /**
     * In case the UserEmailTemplate found by the `where` argument doesn't exist, create a new UserEmailTemplate with this data.
     */
    create: XOR<UserEmailTemplateCreateInput, UserEmailTemplateUncheckedCreateInput>
    /**
     * In case the UserEmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEmailTemplateUpdateInput, UserEmailTemplateUncheckedUpdateInput>
  }

  /**
   * UserEmailTemplate delete
   */
  export type UserEmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which UserEmailTemplate to delete.
     */
    where: UserEmailTemplateWhereUniqueInput
  }

  /**
   * UserEmailTemplate deleteMany
   */
  export type UserEmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmailTemplates to delete
     */
    where?: UserEmailTemplateWhereInput
    /**
     * Limit how many UserEmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * UserEmailTemplate without action
   */
  export type UserEmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmailTemplate
     */
    select?: UserEmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmailTemplate
     */
    omit?: UserEmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    description: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["roles"]>

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */ 
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly name: FieldRef<"Roles", 'String'>
    readonly description: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles updateManyAndReturn
   */
  export type RolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    postDate: Date | null
    expiryDate: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    important: boolean | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    postDate: Date | null
    expiryDate: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    important: boolean | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    content: number
    postDate: number
    expiryDate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    important: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    postDate?: true
    expiryDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    important?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    postDate?: true
    expiryDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    important?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    postDate?: true
    expiryDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    important?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    title: string
    content: string
    postDate: Date
    expiryDate: Date | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    important: boolean
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    postDate?: boolean
    expiryDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    important?: boolean
    reads?: boolean | Notification$readsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    postDate?: boolean
    expiryDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    important?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    postDate?: boolean
    expiryDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    important?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    postDate?: boolean
    expiryDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    important?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "postDate" | "expiryDate" | "createdBy" | "createdAt" | "updatedAt" | "important", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reads?: boolean | Notification$readsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      reads: Prisma.$NotificationReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      postDate: Date
      expiryDate: Date | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
      important: boolean
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reads<T extends Notification$readsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly postDate: FieldRef<"Notification", 'DateTime'>
    readonly expiryDate: FieldRef<"Notification", 'DateTime'>
    readonly createdBy: FieldRef<"Notification", 'Int'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly important: FieldRef<"Notification", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.reads
   */
  export type Notification$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    where?: NotificationReadWhereInput
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    cursor?: NotificationReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationRead
   */

  export type AggregateNotificationRead = {
    _count: NotificationReadCountAggregateOutputType | null
    _avg: NotificationReadAvgAggregateOutputType | null
    _sum: NotificationReadSumAggregateOutputType | null
    _min: NotificationReadMinAggregateOutputType | null
    _max: NotificationReadMaxAggregateOutputType | null
  }

  export type NotificationReadAvgAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: number | null
  }

  export type NotificationReadSumAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: number | null
  }

  export type NotificationReadMinAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: number | null
    readAt: Date | null
  }

  export type NotificationReadMaxAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: number | null
    readAt: Date | null
  }

  export type NotificationReadCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    readAt: number
    _all: number
  }


  export type NotificationReadAvgAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
  }

  export type NotificationReadSumAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
  }

  export type NotificationReadMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
  }

  export type NotificationReadMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
  }

  export type NotificationReadCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type NotificationReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRead to aggregate.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationReads
    **/
    _count?: true | NotificationReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationReadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationReadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationReadMaxAggregateInputType
  }

  export type GetNotificationReadAggregateType<T extends NotificationReadAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRead[P]>
      : GetScalarType<T[P], AggregateNotificationRead[P]>
  }




  export type NotificationReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReadWhereInput
    orderBy?: NotificationReadOrderByWithAggregationInput | NotificationReadOrderByWithAggregationInput[]
    by: NotificationReadScalarFieldEnum[] | NotificationReadScalarFieldEnum
    having?: NotificationReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationReadCountAggregateInputType | true
    _avg?: NotificationReadAvgAggregateInputType
    _sum?: NotificationReadSumAggregateInputType
    _min?: NotificationReadMinAggregateInputType
    _max?: NotificationReadMaxAggregateInputType
  }

  export type NotificationReadGroupByOutputType = {
    id: number
    notificationId: number
    userId: number
    readAt: Date
    _count: NotificationReadCountAggregateOutputType | null
    _avg: NotificationReadAvgAggregateOutputType | null
    _sum: NotificationReadSumAggregateOutputType | null
    _min: NotificationReadMinAggregateOutputType | null
    _max: NotificationReadMaxAggregateOutputType | null
  }

  type GetNotificationReadGroupByPayload<T extends NotificationReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationReadGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationReadGroupByOutputType[P]>
        }
      >
    >


  export type NotificationReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRead"]>

  export type NotificationReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRead"]>

  export type NotificationReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRead"]>

  export type NotificationReadSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type NotificationReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "userId" | "readAt", ExtArgs["result"]["notificationRead"]>
  export type NotificationReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRead"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notificationId: number
      userId: number
      readAt: Date
    }, ExtArgs["result"]["notificationRead"]>
    composites: {}
  }

  type NotificationReadGetPayload<S extends boolean | null | undefined | NotificationReadDefaultArgs> = $Result.GetResult<Prisma.$NotificationReadPayload, S>

  type NotificationReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationReadCountAggregateInputType | true
    }

  export interface NotificationReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRead'], meta: { name: 'NotificationRead' } }
    /**
     * Find zero or one NotificationRead that matches the filter.
     * @param {NotificationReadFindUniqueArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationReadFindUniqueArgs>(args: SelectSubset<T, NotificationReadFindUniqueArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NotificationRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationReadFindUniqueOrThrowArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationReadFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NotificationRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadFindFirstArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationReadFindFirstArgs>(args?: SelectSubset<T, NotificationReadFindFirstArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NotificationRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadFindFirstOrThrowArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationReadFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NotificationReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationReads
     * const notificationReads = await prisma.notificationRead.findMany()
     * 
     * // Get first 10 NotificationReads
     * const notificationReads = await prisma.notificationRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationReadWithIdOnly = await prisma.notificationRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationReadFindManyArgs>(args?: SelectSubset<T, NotificationReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NotificationRead.
     * @param {NotificationReadCreateArgs} args - Arguments to create a NotificationRead.
     * @example
     * // Create one NotificationRead
     * const NotificationRead = await prisma.notificationRead.create({
     *   data: {
     *     // ... data to create a NotificationRead
     *   }
     * })
     * 
     */
    create<T extends NotificationReadCreateArgs>(args: SelectSubset<T, NotificationReadCreateArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NotificationReads.
     * @param {NotificationReadCreateManyArgs} args - Arguments to create many NotificationReads.
     * @example
     * // Create many NotificationReads
     * const notificationRead = await prisma.notificationRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationReadCreateManyArgs>(args?: SelectSubset<T, NotificationReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationReads and returns the data saved in the database.
     * @param {NotificationReadCreateManyAndReturnArgs} args - Arguments to create many NotificationReads.
     * @example
     * // Create many NotificationReads
     * const notificationRead = await prisma.notificationRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationReads and only return the `id`
     * const notificationReadWithIdOnly = await prisma.notificationRead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationReadCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NotificationRead.
     * @param {NotificationReadDeleteArgs} args - Arguments to delete one NotificationRead.
     * @example
     * // Delete one NotificationRead
     * const NotificationRead = await prisma.notificationRead.delete({
     *   where: {
     *     // ... filter to delete one NotificationRead
     *   }
     * })
     * 
     */
    delete<T extends NotificationReadDeleteArgs>(args: SelectSubset<T, NotificationReadDeleteArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NotificationRead.
     * @param {NotificationReadUpdateArgs} args - Arguments to update one NotificationRead.
     * @example
     * // Update one NotificationRead
     * const notificationRead = await prisma.notificationRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationReadUpdateArgs>(args: SelectSubset<T, NotificationReadUpdateArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NotificationReads.
     * @param {NotificationReadDeleteManyArgs} args - Arguments to filter NotificationReads to delete.
     * @example
     * // Delete a few NotificationReads
     * const { count } = await prisma.notificationRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationReadDeleteManyArgs>(args?: SelectSubset<T, NotificationReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationReads
     * const notificationRead = await prisma.notificationRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationReadUpdateManyArgs>(args: SelectSubset<T, NotificationReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationReads and returns the data updated in the database.
     * @param {NotificationReadUpdateManyAndReturnArgs} args - Arguments to update many NotificationReads.
     * @example
     * // Update many NotificationReads
     * const notificationRead = await prisma.notificationRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationReads and only return the `id`
     * const notificationReadWithIdOnly = await prisma.notificationRead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationReadUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NotificationRead.
     * @param {NotificationReadUpsertArgs} args - Arguments to update or create a NotificationRead.
     * @example
     * // Update or create a NotificationRead
     * const notificationRead = await prisma.notificationRead.upsert({
     *   create: {
     *     // ... data to create a NotificationRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRead we want to update
     *   }
     * })
     */
    upsert<T extends NotificationReadUpsertArgs>(args: SelectSubset<T, NotificationReadUpsertArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NotificationReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadCountArgs} args - Arguments to filter NotificationReads to count.
     * @example
     * // Count the number of NotificationReads
     * const count = await prisma.notificationRead.count({
     *   where: {
     *     // ... the filter for the NotificationReads we want to count
     *   }
     * })
    **/
    count<T extends NotificationReadCountArgs>(
      args?: Subset<T, NotificationReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationReadAggregateArgs>(args: Subset<T, NotificationReadAggregateArgs>): Prisma.PrismaPromise<GetNotificationReadAggregateType<T>>

    /**
     * Group by NotificationRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationReadGroupByArgs['orderBy'] }
        : { orderBy?: NotificationReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRead model
   */
  readonly fields: NotificationReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRead model
   */ 
  interface NotificationReadFieldRefs {
    readonly id: FieldRef<"NotificationRead", 'Int'>
    readonly notificationId: FieldRef<"NotificationRead", 'Int'>
    readonly userId: FieldRef<"NotificationRead", 'Int'>
    readonly readAt: FieldRef<"NotificationRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRead findUnique
   */
  export type NotificationReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead findUniqueOrThrow
   */
  export type NotificationReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead findFirst
   */
  export type NotificationReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationReads.
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationReads.
     */
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * NotificationRead findFirstOrThrow
   */
  export type NotificationReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationReads.
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationReads.
     */
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * NotificationRead findMany
   */
  export type NotificationReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReads to fetch.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationReads.
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * NotificationRead create
   */
  export type NotificationReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationRead.
     */
    data: XOR<NotificationReadCreateInput, NotificationReadUncheckedCreateInput>
  }

  /**
   * NotificationRead createMany
   */
  export type NotificationReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationReads.
     */
    data: NotificationReadCreateManyInput | NotificationReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationRead createManyAndReturn
   */
  export type NotificationReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationReads.
     */
    data: NotificationReadCreateManyInput | NotificationReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRead update
   */
  export type NotificationReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationRead.
     */
    data: XOR<NotificationReadUpdateInput, NotificationReadUncheckedUpdateInput>
    /**
     * Choose, which NotificationRead to update.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead updateMany
   */
  export type NotificationReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationReads.
     */
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyInput>
    /**
     * Filter which NotificationReads to update
     */
    where?: NotificationReadWhereInput
    /**
     * Limit how many NotificationReads to update.
     */
    limit?: number
  }

  /**
   * NotificationRead updateManyAndReturn
   */
  export type NotificationReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * The data used to update NotificationReads.
     */
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyInput>
    /**
     * Filter which NotificationReads to update
     */
    where?: NotificationReadWhereInput
    /**
     * Limit how many NotificationReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRead upsert
   */
  export type NotificationReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationRead to update in case it exists.
     */
    where: NotificationReadWhereUniqueInput
    /**
     * In case the NotificationRead found by the `where` argument doesn't exist, create a new NotificationRead with this data.
     */
    create: XOR<NotificationReadCreateInput, NotificationReadUncheckedCreateInput>
    /**
     * In case the NotificationRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationReadUpdateInput, NotificationReadUncheckedUpdateInput>
  }

  /**
   * NotificationRead delete
   */
  export type NotificationReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter which NotificationRead to delete.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead deleteMany
   */
  export type NotificationReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationReads to delete
     */
    where?: NotificationReadWhereInput
    /**
     * Limit how many NotificationReads to delete.
     */
    limit?: number
  }

  /**
   * NotificationRead without action
   */
  export type NotificationReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
  }


  /**
   * Model SavedQuery
   */

  export type AggregateSavedQuery = {
    _count: SavedQueryCountAggregateOutputType | null
    _avg: SavedQueryAvgAggregateOutputType | null
    _sum: SavedQuerySumAggregateOutputType | null
    _min: SavedQueryMinAggregateOutputType | null
    _max: SavedQueryMaxAggregateOutputType | null
  }

  export type SavedQueryAvgAggregateOutputType = {
    id: number | null
    emailTemplateId: number | null
  }

  export type SavedQuerySumAggregateOutputType = {
    id: number | null
    emailTemplateId: number | null
  }

  export type SavedQueryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    tableName: string | null
    emailTemplateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedQueryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    tableName: string | null
    emailTemplateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedQueryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tableName: number
    columns: number
    conditions: number
    emailTemplateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SavedQueryAvgAggregateInputType = {
    id?: true
    emailTemplateId?: true
  }

  export type SavedQuerySumAggregateInputType = {
    id?: true
    emailTemplateId?: true
  }

  export type SavedQueryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tableName?: true
    emailTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedQueryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tableName?: true
    emailTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedQueryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tableName?: true
    columns?: true
    conditions?: true
    emailTemplateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SavedQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedQuery to aggregate.
     */
    where?: SavedQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedQueries to fetch.
     */
    orderBy?: SavedQueryOrderByWithRelationInput | SavedQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedQueries
    **/
    _count?: true | SavedQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedQueryMaxAggregateInputType
  }

  export type GetSavedQueryAggregateType<T extends SavedQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedQuery[P]>
      : GetScalarType<T[P], AggregateSavedQuery[P]>
  }




  export type SavedQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedQueryWhereInput
    orderBy?: SavedQueryOrderByWithAggregationInput | SavedQueryOrderByWithAggregationInput[]
    by: SavedQueryScalarFieldEnum[] | SavedQueryScalarFieldEnum
    having?: SavedQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedQueryCountAggregateInputType | true
    _avg?: SavedQueryAvgAggregateInputType
    _sum?: SavedQuerySumAggregateInputType
    _min?: SavedQueryMinAggregateInputType
    _max?: SavedQueryMaxAggregateInputType
  }

  export type SavedQueryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    tableName: string
    columns: string[]
    conditions: JsonValue | null
    emailTemplateId: number | null
    createdAt: Date
    updatedAt: Date
    _count: SavedQueryCountAggregateOutputType | null
    _avg: SavedQueryAvgAggregateOutputType | null
    _sum: SavedQuerySumAggregateOutputType | null
    _min: SavedQueryMinAggregateOutputType | null
    _max: SavedQueryMaxAggregateOutputType | null
  }

  type GetSavedQueryGroupByPayload<T extends SavedQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SavedQueryGroupByOutputType[P]>
        }
      >
    >


  export type SavedQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tableName?: boolean
    columns?: boolean
    conditions?: boolean
    emailTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplate?: boolean | SavedQuery$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["savedQuery"]>

  export type SavedQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tableName?: boolean
    columns?: boolean
    conditions?: boolean
    emailTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplate?: boolean | SavedQuery$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["savedQuery"]>

  export type SavedQuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tableName?: boolean
    columns?: boolean
    conditions?: boolean
    emailTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailTemplate?: boolean | SavedQuery$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["savedQuery"]>

  export type SavedQuerySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tableName?: boolean
    columns?: boolean
    conditions?: boolean
    emailTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SavedQueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tableName" | "columns" | "conditions" | "emailTemplateId" | "createdAt" | "updatedAt", ExtArgs["result"]["savedQuery"]>
  export type SavedQueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | SavedQuery$emailTemplateArgs<ExtArgs>
  }
  export type SavedQueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | SavedQuery$emailTemplateArgs<ExtArgs>
  }
  export type SavedQueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | SavedQuery$emailTemplateArgs<ExtArgs>
  }

  export type $SavedQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedQuery"
    objects: {
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      tableName: string
      columns: string[]
      conditions: Prisma.JsonValue | null
      emailTemplateId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["savedQuery"]>
    composites: {}
  }

  type SavedQueryGetPayload<S extends boolean | null | undefined | SavedQueryDefaultArgs> = $Result.GetResult<Prisma.$SavedQueryPayload, S>

  type SavedQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedQueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedQueryCountAggregateInputType | true
    }

  export interface SavedQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedQuery'], meta: { name: 'SavedQuery' } }
    /**
     * Find zero or one SavedQuery that matches the filter.
     * @param {SavedQueryFindUniqueArgs} args - Arguments to find a SavedQuery
     * @example
     * // Get one SavedQuery
     * const savedQuery = await prisma.savedQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedQueryFindUniqueArgs>(args: SelectSubset<T, SavedQueryFindUniqueArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SavedQuery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedQueryFindUniqueOrThrowArgs} args - Arguments to find a SavedQuery
     * @example
     * // Get one SavedQuery
     * const savedQuery = await prisma.savedQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SavedQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryFindFirstArgs} args - Arguments to find a SavedQuery
     * @example
     * // Get one SavedQuery
     * const savedQuery = await prisma.savedQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedQueryFindFirstArgs>(args?: SelectSubset<T, SavedQueryFindFirstArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SavedQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryFindFirstOrThrowArgs} args - Arguments to find a SavedQuery
     * @example
     * // Get one SavedQuery
     * const savedQuery = await prisma.savedQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SavedQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedQueries
     * const savedQueries = await prisma.savedQuery.findMany()
     * 
     * // Get first 10 SavedQueries
     * const savedQueries = await prisma.savedQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedQueryWithIdOnly = await prisma.savedQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedQueryFindManyArgs>(args?: SelectSubset<T, SavedQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SavedQuery.
     * @param {SavedQueryCreateArgs} args - Arguments to create a SavedQuery.
     * @example
     * // Create one SavedQuery
     * const SavedQuery = await prisma.savedQuery.create({
     *   data: {
     *     // ... data to create a SavedQuery
     *   }
     * })
     * 
     */
    create<T extends SavedQueryCreateArgs>(args: SelectSubset<T, SavedQueryCreateArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SavedQueries.
     * @param {SavedQueryCreateManyArgs} args - Arguments to create many SavedQueries.
     * @example
     * // Create many SavedQueries
     * const savedQuery = await prisma.savedQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedQueryCreateManyArgs>(args?: SelectSubset<T, SavedQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedQueries and returns the data saved in the database.
     * @param {SavedQueryCreateManyAndReturnArgs} args - Arguments to create many SavedQueries.
     * @example
     * // Create many SavedQueries
     * const savedQuery = await prisma.savedQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedQueries and only return the `id`
     * const savedQueryWithIdOnly = await prisma.savedQuery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SavedQuery.
     * @param {SavedQueryDeleteArgs} args - Arguments to delete one SavedQuery.
     * @example
     * // Delete one SavedQuery
     * const SavedQuery = await prisma.savedQuery.delete({
     *   where: {
     *     // ... filter to delete one SavedQuery
     *   }
     * })
     * 
     */
    delete<T extends SavedQueryDeleteArgs>(args: SelectSubset<T, SavedQueryDeleteArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SavedQuery.
     * @param {SavedQueryUpdateArgs} args - Arguments to update one SavedQuery.
     * @example
     * // Update one SavedQuery
     * const savedQuery = await prisma.savedQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedQueryUpdateArgs>(args: SelectSubset<T, SavedQueryUpdateArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SavedQueries.
     * @param {SavedQueryDeleteManyArgs} args - Arguments to filter SavedQueries to delete.
     * @example
     * // Delete a few SavedQueries
     * const { count } = await prisma.savedQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedQueryDeleteManyArgs>(args?: SelectSubset<T, SavedQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedQueries
     * const savedQuery = await prisma.savedQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedQueryUpdateManyArgs>(args: SelectSubset<T, SavedQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedQueries and returns the data updated in the database.
     * @param {SavedQueryUpdateManyAndReturnArgs} args - Arguments to update many SavedQueries.
     * @example
     * // Update many SavedQueries
     * const savedQuery = await prisma.savedQuery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedQueries and only return the `id`
     * const savedQueryWithIdOnly = await prisma.savedQuery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedQueryUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedQueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SavedQuery.
     * @param {SavedQueryUpsertArgs} args - Arguments to update or create a SavedQuery.
     * @example
     * // Update or create a SavedQuery
     * const savedQuery = await prisma.savedQuery.upsert({
     *   create: {
     *     // ... data to create a SavedQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedQuery we want to update
     *   }
     * })
     */
    upsert<T extends SavedQueryUpsertArgs>(args: SelectSubset<T, SavedQueryUpsertArgs<ExtArgs>>): Prisma__SavedQueryClient<$Result.GetResult<Prisma.$SavedQueryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SavedQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryCountArgs} args - Arguments to filter SavedQueries to count.
     * @example
     * // Count the number of SavedQueries
     * const count = await prisma.savedQuery.count({
     *   where: {
     *     // ... the filter for the SavedQueries we want to count
     *   }
     * })
    **/
    count<T extends SavedQueryCountArgs>(
      args?: Subset<T, SavedQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedQueryAggregateArgs>(args: Subset<T, SavedQueryAggregateArgs>): Prisma.PrismaPromise<GetSavedQueryAggregateType<T>>

    /**
     * Group by SavedQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedQueryGroupByArgs['orderBy'] }
        : { orderBy?: SavedQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedQuery model
   */
  readonly fields: SavedQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailTemplate<T extends SavedQuery$emailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, SavedQuery$emailTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedQuery model
   */ 
  interface SavedQueryFieldRefs {
    readonly id: FieldRef<"SavedQuery", 'Int'>
    readonly name: FieldRef<"SavedQuery", 'String'>
    readonly description: FieldRef<"SavedQuery", 'String'>
    readonly tableName: FieldRef<"SavedQuery", 'String'>
    readonly columns: FieldRef<"SavedQuery", 'String[]'>
    readonly conditions: FieldRef<"SavedQuery", 'Json'>
    readonly emailTemplateId: FieldRef<"SavedQuery", 'Int'>
    readonly createdAt: FieldRef<"SavedQuery", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedQuery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedQuery findUnique
   */
  export type SavedQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * Filter, which SavedQuery to fetch.
     */
    where: SavedQueryWhereUniqueInput
  }

  /**
   * SavedQuery findUniqueOrThrow
   */
  export type SavedQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * Filter, which SavedQuery to fetch.
     */
    where: SavedQueryWhereUniqueInput
  }

  /**
   * SavedQuery findFirst
   */
  export type SavedQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * Filter, which SavedQuery to fetch.
     */
    where?: SavedQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedQueries to fetch.
     */
    orderBy?: SavedQueryOrderByWithRelationInput | SavedQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedQueries.
     */
    cursor?: SavedQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedQueries.
     */
    distinct?: SavedQueryScalarFieldEnum | SavedQueryScalarFieldEnum[]
  }

  /**
   * SavedQuery findFirstOrThrow
   */
  export type SavedQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * Filter, which SavedQuery to fetch.
     */
    where?: SavedQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedQueries to fetch.
     */
    orderBy?: SavedQueryOrderByWithRelationInput | SavedQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedQueries.
     */
    cursor?: SavedQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedQueries.
     */
    distinct?: SavedQueryScalarFieldEnum | SavedQueryScalarFieldEnum[]
  }

  /**
   * SavedQuery findMany
   */
  export type SavedQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * Filter, which SavedQueries to fetch.
     */
    where?: SavedQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedQueries to fetch.
     */
    orderBy?: SavedQueryOrderByWithRelationInput | SavedQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedQueries.
     */
    cursor?: SavedQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedQueries.
     */
    skip?: number
    distinct?: SavedQueryScalarFieldEnum | SavedQueryScalarFieldEnum[]
  }

  /**
   * SavedQuery create
   */
  export type SavedQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedQuery.
     */
    data: XOR<SavedQueryCreateInput, SavedQueryUncheckedCreateInput>
  }

  /**
   * SavedQuery createMany
   */
  export type SavedQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedQueries.
     */
    data: SavedQueryCreateManyInput | SavedQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedQuery createManyAndReturn
   */
  export type SavedQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * The data used to create many SavedQueries.
     */
    data: SavedQueryCreateManyInput | SavedQueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedQuery update
   */
  export type SavedQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedQuery.
     */
    data: XOR<SavedQueryUpdateInput, SavedQueryUncheckedUpdateInput>
    /**
     * Choose, which SavedQuery to update.
     */
    where: SavedQueryWhereUniqueInput
  }

  /**
   * SavedQuery updateMany
   */
  export type SavedQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedQueries.
     */
    data: XOR<SavedQueryUpdateManyMutationInput, SavedQueryUncheckedUpdateManyInput>
    /**
     * Filter which SavedQueries to update
     */
    where?: SavedQueryWhereInput
    /**
     * Limit how many SavedQueries to update.
     */
    limit?: number
  }

  /**
   * SavedQuery updateManyAndReturn
   */
  export type SavedQueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * The data used to update SavedQueries.
     */
    data: XOR<SavedQueryUpdateManyMutationInput, SavedQueryUncheckedUpdateManyInput>
    /**
     * Filter which SavedQueries to update
     */
    where?: SavedQueryWhereInput
    /**
     * Limit how many SavedQueries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedQuery upsert
   */
  export type SavedQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedQuery to update in case it exists.
     */
    where: SavedQueryWhereUniqueInput
    /**
     * In case the SavedQuery found by the `where` argument doesn't exist, create a new SavedQuery with this data.
     */
    create: XOR<SavedQueryCreateInput, SavedQueryUncheckedCreateInput>
    /**
     * In case the SavedQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedQueryUpdateInput, SavedQueryUncheckedUpdateInput>
  }

  /**
   * SavedQuery delete
   */
  export type SavedQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
    /**
     * Filter which SavedQuery to delete.
     */
    where: SavedQueryWhereUniqueInput
  }

  /**
   * SavedQuery deleteMany
   */
  export type SavedQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedQueries to delete
     */
    where?: SavedQueryWhereInput
    /**
     * Limit how many SavedQueries to delete.
     */
    limit?: number
  }

  /**
   * SavedQuery.emailTemplate
   */
  export type SavedQuery$emailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * SavedQuery without action
   */
  export type SavedQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedQuery
     */
    select?: SavedQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedQuery
     */
    omit?: SavedQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedQueryInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _avg: TicketCommentAvgAggregateOutputType | null
    _sum: TicketCommentSumAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
  }

  export type TicketCommentSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type TicketCommentAvgAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
  }

  export type TicketCommentSumAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
  }

  export type TicketCommentMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _avg?: TicketCommentAvgAggregateInputType
    _sum?: TicketCommentSumAggregateInputType
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: number
    ticketId: number
    userId: number
    content: string
    createdAt: Date
    _count: TicketCommentCountAggregateOutputType | null
    _avg: TicketCommentAvgAggregateOutputType | null
    _sum: TicketCommentSumAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    TicketAttachment?: boolean | TicketComment$TicketAttachmentArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TicketCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type TicketCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "userId" | "content" | "createdAt", ExtArgs["result"]["ticketComment"]>
  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TicketAttachment?: boolean | TicketComment$TicketAttachmentArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TicketCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      TicketAttachment: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      userId: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketComments and returns the data saved in the database.
     * @param {TicketCommentCreateManyAndReturnArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments and returns the data updated in the database.
     * @param {TicketCommentUpdateManyAndReturnArgs} args - Arguments to update many TicketComments.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TicketAttachment<T extends TicketComment$TicketAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, TicketComment$TicketAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */ 
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'Int'>
    readonly ticketId: FieldRef<"TicketComment", 'Int'>
    readonly userId: FieldRef<"TicketComment", 'Int'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment createManyAndReturn
   */
  export type TicketCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
  }

  /**
   * TicketComment updateManyAndReturn
   */
  export type TicketCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to delete.
     */
    limit?: number
  }

  /**
   * TicketComment.TicketAttachment
   */
  export type TicketComment$TicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketAvgAggregateOutputType = {
    id: number | null
    assignedToId: number | null
    createdById: number | null
    relatedDeviceId: number | null
  }

  export type SupportTicketSumAggregateOutputType = {
    id: number | null
    assignedToId: number | null
    createdById: number | null
    relatedDeviceId: number | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: number | null
    createdById: number | null
    relatedDeviceId: number | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: number | null
    createdById: number | null
    relatedDeviceId: number | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    assignedToId: number
    createdById: number
    relatedDeviceId: number
    _all: number
  }


  export type SupportTicketAvgAggregateInputType = {
    id?: true
    assignedToId?: true
    createdById?: true
    relatedDeviceId?: true
  }

  export type SupportTicketSumAggregateInputType = {
    id?: true
    assignedToId?: true
    createdById?: true
    relatedDeviceId?: true
  }

  export type SupportTicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    relatedDeviceId?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    relatedDeviceId?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    relatedDeviceId?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _avg?: SupportTicketAvgAggregateInputType
    _sum?: SupportTicketSumAggregateInputType
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: number
    title: string
    description: string
    status: string
    priority: string
    createdAt: Date
    updatedAt: Date
    assignedToId: number | null
    createdById: number
    relatedDeviceId: number | null
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    relatedDeviceId?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    relatedDevice?: boolean | SupportTicket$relatedDeviceArgs<ExtArgs>
    attachments?: boolean | SupportTicket$attachmentsArgs<ExtArgs>
    comments?: boolean | SupportTicket$commentsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    relatedDeviceId?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    relatedDevice?: boolean | SupportTicket$relatedDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    relatedDeviceId?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    relatedDevice?: boolean | SupportTicket$relatedDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    relatedDeviceId?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "createdAt" | "updatedAt" | "assignedToId" | "createdById" | "relatedDeviceId", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    relatedDevice?: boolean | SupportTicket$relatedDeviceArgs<ExtArgs>
    attachments?: boolean | SupportTicket$attachmentsArgs<ExtArgs>
    comments?: boolean | SupportTicket$commentsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    relatedDevice?: boolean | SupportTicket$relatedDeviceArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    relatedDevice?: boolean | SupportTicket$relatedDeviceArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      relatedDevice: Prisma.$devicesPayload<ExtArgs> | null
      attachments: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      status: string
      priority: string
      createdAt: Date
      updatedAt: Date
      assignedToId: number | null
      createdById: number
      relatedDeviceId: number | null
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends SupportTicket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    relatedDevice<T extends SupportTicket$relatedDeviceArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$relatedDeviceArgs<ExtArgs>>): Prisma__devicesClient<$Result.GetResult<Prisma.$devicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attachments<T extends SupportTicket$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends SupportTicket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'Int'>
    readonly title: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly assignedToId: FieldRef<"SupportTicket", 'Int'>
    readonly createdById: FieldRef<"SupportTicket", 'Int'>
    readonly relatedDeviceId: FieldRef<"SupportTicket", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.assignedTo
   */
  export type SupportTicket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.relatedDevice
   */
  export type SupportTicket$relatedDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the devices
     */
    select?: devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the devices
     */
    omit?: devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: devicesInclude<ExtArgs> | null
    where?: devicesWhereInput
  }

  /**
   * SupportTicket.attachments
   */
  export type SupportTicket$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * SupportTicket.comments
   */
  export type SupportTicket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketAttachment
   */

  export type AggregateTicketAttachment = {
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  export type TicketAttachmentAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
    ticketId: number | null
    commentId: number | null
    uploaderId: number | null
  }

  export type TicketAttachmentSumAggregateOutputType = {
    id: number | null
    fileSize: number | null
    ticketId: number | null
    commentId: number | null
    uploaderId: number | null
  }

  export type TicketAttachmentMinAggregateOutputType = {
    id: number | null
    filename: string | null
    originalFilename: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    ticketId: number | null
    commentId: number | null
    uploaderId: number | null
  }

  export type TicketAttachmentMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    originalFilename: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    ticketId: number | null
    commentId: number | null
    uploaderId: number | null
  }

  export type TicketAttachmentCountAggregateOutputType = {
    id: number
    filename: number
    originalFilename: number
    fileSize: number
    mimeType: number
    createdAt: number
    ticketId: number
    commentId: number
    uploaderId: number
    _all: number
  }


  export type TicketAttachmentAvgAggregateInputType = {
    id?: true
    fileSize?: true
    ticketId?: true
    commentId?: true
    uploaderId?: true
  }

  export type TicketAttachmentSumAggregateInputType = {
    id?: true
    fileSize?: true
    ticketId?: true
    commentId?: true
    uploaderId?: true
  }

  export type TicketAttachmentMinAggregateInputType = {
    id?: true
    filename?: true
    originalFilename?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    ticketId?: true
    commentId?: true
    uploaderId?: true
  }

  export type TicketAttachmentMaxAggregateInputType = {
    id?: true
    filename?: true
    originalFilename?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    ticketId?: true
    commentId?: true
    uploaderId?: true
  }

  export type TicketAttachmentCountAggregateInputType = {
    id?: true
    filename?: true
    originalFilename?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    ticketId?: true
    commentId?: true
    uploaderId?: true
    _all?: true
  }

  export type TicketAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachment to aggregate.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAttachments
    **/
    _count?: true | TicketAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type GetTicketAttachmentAggregateType<T extends TicketAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAttachment[P]>
      : GetScalarType<T[P], AggregateTicketAttachment[P]>
  }




  export type TicketAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithAggregationInput | TicketAttachmentOrderByWithAggregationInput[]
    by: TicketAttachmentScalarFieldEnum[] | TicketAttachmentScalarFieldEnum
    having?: TicketAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAttachmentCountAggregateInputType | true
    _avg?: TicketAttachmentAvgAggregateInputType
    _sum?: TicketAttachmentSumAggregateInputType
    _min?: TicketAttachmentMinAggregateInputType
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type TicketAttachmentGroupByOutputType = {
    id: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt: Date
    ticketId: number | null
    commentId: number | null
    uploaderId: number
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  type GetTicketAttachmentGroupByPayload<T extends TicketAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    ticketId?: boolean
    commentId?: boolean
    uploaderId?: boolean
    comment?: boolean | TicketAttachment$commentArgs<ExtArgs>
    ticket?: boolean | TicketAttachment$ticketArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    ticketId?: boolean
    commentId?: boolean
    uploaderId?: boolean
    comment?: boolean | TicketAttachment$commentArgs<ExtArgs>
    ticket?: boolean | TicketAttachment$ticketArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    ticketId?: boolean
    commentId?: boolean
    uploaderId?: boolean
    comment?: boolean | TicketAttachment$commentArgs<ExtArgs>
    ticket?: boolean | TicketAttachment$ticketArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectScalar = {
    id?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    ticketId?: boolean
    commentId?: boolean
    uploaderId?: boolean
  }

  export type TicketAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalFilename" | "fileSize" | "mimeType" | "createdAt" | "ticketId" | "commentId" | "uploaderId", ExtArgs["result"]["ticketAttachment"]>
  export type TicketAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | TicketAttachment$commentArgs<ExtArgs>
    ticket?: boolean | TicketAttachment$ticketArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | TicketAttachment$commentArgs<ExtArgs>
    ticket?: boolean | TicketAttachment$ticketArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | TicketAttachment$commentArgs<ExtArgs>
    ticket?: boolean | TicketAttachment$ticketArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAttachment"
    objects: {
      comment: Prisma.$TicketCommentPayload<ExtArgs> | null
      ticket: Prisma.$SupportTicketPayload<ExtArgs> | null
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      originalFilename: string
      fileSize: number
      mimeType: string
      createdAt: Date
      ticketId: number | null
      commentId: number | null
      uploaderId: number
    }, ExtArgs["result"]["ticketAttachment"]>
    composites: {}
  }

  type TicketAttachmentGetPayload<S extends boolean | null | undefined | TicketAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAttachmentPayload, S>

  type TicketAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketAttachmentCountAggregateInputType | true
    }

  export interface TicketAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAttachment'], meta: { name: 'TicketAttachment' } }
    /**
     * Find zero or one TicketAttachment that matches the filter.
     * @param {TicketAttachmentFindUniqueArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAttachmentFindUniqueArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TicketAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TicketAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAttachmentFindFirstArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TicketAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TicketAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany()
     * 
     * // Get first 10 TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAttachmentFindManyArgs>(args?: SelectSubset<T, TicketAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TicketAttachment.
     * @param {TicketAttachmentCreateArgs} args - Arguments to create a TicketAttachment.
     * @example
     * // Create one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.create({
     *   data: {
     *     // ... data to create a TicketAttachment
     *   }
     * })
     * 
     */
    create<T extends TicketAttachmentCreateArgs>(args: SelectSubset<T, TicketAttachmentCreateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TicketAttachments.
     * @param {TicketAttachmentCreateManyArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAttachmentCreateManyArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketAttachments and returns the data saved in the database.
     * @param {TicketAttachmentCreateManyAndReturnArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TicketAttachment.
     * @param {TicketAttachmentDeleteArgs} args - Arguments to delete one TicketAttachment.
     * @example
     * // Delete one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.delete({
     *   where: {
     *     // ... filter to delete one TicketAttachment
     *   }
     * })
     * 
     */
    delete<T extends TicketAttachmentDeleteArgs>(args: SelectSubset<T, TicketAttachmentDeleteArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TicketAttachment.
     * @param {TicketAttachmentUpdateArgs} args - Arguments to update one TicketAttachment.
     * @example
     * // Update one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAttachmentUpdateArgs>(args: SelectSubset<T, TicketAttachmentUpdateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TicketAttachments.
     * @param {TicketAttachmentDeleteManyArgs} args - Arguments to filter TicketAttachments to delete.
     * @example
     * // Delete a few TicketAttachments
     * const { count } = await prisma.ticketAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAttachmentDeleteManyArgs>(args?: SelectSubset<T, TicketAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAttachmentUpdateManyArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments and returns the data updated in the database.
     * @param {TicketAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TicketAttachments.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TicketAttachment.
     * @param {TicketAttachmentUpsertArgs} args - Arguments to update or create a TicketAttachment.
     * @example
     * // Update or create a TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.upsert({
     *   create: {
     *     // ... data to create a TicketAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAttachmentUpsertArgs>(args: SelectSubset<T, TicketAttachmentUpsertArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentCountArgs} args - Arguments to filter TicketAttachments to count.
     * @example
     * // Count the number of TicketAttachments
     * const count = await prisma.ticketAttachment.count({
     *   where: {
     *     // ... the filter for the TicketAttachments we want to count
     *   }
     * })
    **/
    count<T extends TicketAttachmentCountArgs>(
      args?: Subset<T, TicketAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAttachmentAggregateArgs>(args: Subset<T, TicketAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAttachmentAggregateType<T>>

    /**
     * Group by TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAttachment model
   */
  readonly fields: TicketAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends TicketAttachment$commentArgs<ExtArgs> = {}>(args?: Subset<T, TicketAttachment$commentArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    ticket<T extends TicketAttachment$ticketArgs<ExtArgs> = {}>(args?: Subset<T, TicketAttachment$ticketArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAttachment model
   */ 
  interface TicketAttachmentFieldRefs {
    readonly id: FieldRef<"TicketAttachment", 'Int'>
    readonly filename: FieldRef<"TicketAttachment", 'String'>
    readonly originalFilename: FieldRef<"TicketAttachment", 'String'>
    readonly fileSize: FieldRef<"TicketAttachment", 'Int'>
    readonly mimeType: FieldRef<"TicketAttachment", 'String'>
    readonly createdAt: FieldRef<"TicketAttachment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketAttachment", 'Int'>
    readonly commentId: FieldRef<"TicketAttachment", 'Int'>
    readonly uploaderId: FieldRef<"TicketAttachment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TicketAttachment findUnique
   */
  export type TicketAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findUniqueOrThrow
   */
  export type TicketAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findFirst
   */
  export type TicketAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findFirstOrThrow
   */
  export type TicketAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findMany
   */
  export type TicketAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachments to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment create
   */
  export type TicketAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAttachment.
     */
    data: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
  }

  /**
   * TicketAttachment createMany
   */
  export type TicketAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketAttachment createManyAndReturn
   */
  export type TicketAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment update
   */
  export type TicketAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAttachment.
     */
    data: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAttachment to update.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment updateMany
   */
  export type TicketAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
  }

  /**
   * TicketAttachment updateManyAndReturn
   */
  export type TicketAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment upsert
   */
  export type TicketAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAttachment to update in case it exists.
     */
    where: TicketAttachmentWhereUniqueInput
    /**
     * In case the TicketAttachment found by the `where` argument doesn't exist, create a new TicketAttachment with this data.
     */
    create: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
    /**
     * In case the TicketAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
  }

  /**
   * TicketAttachment delete
   */
  export type TicketAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAttachment to delete.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment deleteMany
   */
  export type TicketAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachments to delete
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to delete.
     */
    limit?: number
  }

  /**
   * TicketAttachment.comment
   */
  export type TicketAttachment$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
  }

  /**
   * TicketAttachment.ticket
   */
  export type TicketAttachment$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
  }

  /**
   * TicketAttachment without action
   */
  export type TicketAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model AlertCondition
   */

  export type AggregateAlertCondition = {
    _count: AlertConditionCountAggregateOutputType | null
    _avg: AlertConditionAvgAggregateOutputType | null
    _sum: AlertConditionSumAggregateOutputType | null
    _min: AlertConditionMinAggregateOutputType | null
    _max: AlertConditionMaxAggregateOutputType | null
  }

  export type AlertConditionAvgAggregateOutputType = {
    id: number | null
    timeWindowMin: number | null
    repeatIntervalMin: number | null
    countThreshold: number | null
    emailTemplateId: number | null
  }

  export type AlertConditionSumAggregateOutputType = {
    id: number | null
    timeWindowMin: number | null
    repeatIntervalMin: number | null
    countThreshold: number | null
    emailTemplateId: number | null
  }

  export type AlertConditionMinAggregateOutputType = {
    id: number | null
    name: string | null
    sourceTable: string | null
    fieldName: string | null
    comparator: string | null
    thresholdValue: string | null
    timeWindowMin: number | null
    repeatIntervalMin: number | null
    countThreshold: number | null
    lastTriggeredAt: Date | null
    active: boolean | null
    emailTemplateId: number | null
  }

  export type AlertConditionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    sourceTable: string | null
    fieldName: string | null
    comparator: string | null
    thresholdValue: string | null
    timeWindowMin: number | null
    repeatIntervalMin: number | null
    countThreshold: number | null
    lastTriggeredAt: Date | null
    active: boolean | null
    emailTemplateId: number | null
  }

  export type AlertConditionCountAggregateOutputType = {
    id: number
    name: number
    sourceTable: number
    fieldName: number
    comparator: number
    thresholdValue: number
    timeWindowMin: number
    repeatIntervalMin: number
    countThreshold: number
    lastTriggeredAt: number
    active: number
    emailTemplateId: number
    _all: number
  }


  export type AlertConditionAvgAggregateInputType = {
    id?: true
    timeWindowMin?: true
    repeatIntervalMin?: true
    countThreshold?: true
    emailTemplateId?: true
  }

  export type AlertConditionSumAggregateInputType = {
    id?: true
    timeWindowMin?: true
    repeatIntervalMin?: true
    countThreshold?: true
    emailTemplateId?: true
  }

  export type AlertConditionMinAggregateInputType = {
    id?: true
    name?: true
    sourceTable?: true
    fieldName?: true
    comparator?: true
    thresholdValue?: true
    timeWindowMin?: true
    repeatIntervalMin?: true
    countThreshold?: true
    lastTriggeredAt?: true
    active?: true
    emailTemplateId?: true
  }

  export type AlertConditionMaxAggregateInputType = {
    id?: true
    name?: true
    sourceTable?: true
    fieldName?: true
    comparator?: true
    thresholdValue?: true
    timeWindowMin?: true
    repeatIntervalMin?: true
    countThreshold?: true
    lastTriggeredAt?: true
    active?: true
    emailTemplateId?: true
  }

  export type AlertConditionCountAggregateInputType = {
    id?: true
    name?: true
    sourceTable?: true
    fieldName?: true
    comparator?: true
    thresholdValue?: true
    timeWindowMin?: true
    repeatIntervalMin?: true
    countThreshold?: true
    lastTriggeredAt?: true
    active?: true
    emailTemplateId?: true
    _all?: true
  }

  export type AlertConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertCondition to aggregate.
     */
    where?: AlertConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConditions to fetch.
     */
    orderBy?: AlertConditionOrderByWithRelationInput | AlertConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertConditions
    **/
    _count?: true | AlertConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertConditionMaxAggregateInputType
  }

  export type GetAlertConditionAggregateType<T extends AlertConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertCondition[P]>
      : GetScalarType<T[P], AggregateAlertCondition[P]>
  }




  export type AlertConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertConditionWhereInput
    orderBy?: AlertConditionOrderByWithAggregationInput | AlertConditionOrderByWithAggregationInput[]
    by: AlertConditionScalarFieldEnum[] | AlertConditionScalarFieldEnum
    having?: AlertConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertConditionCountAggregateInputType | true
    _avg?: AlertConditionAvgAggregateInputType
    _sum?: AlertConditionSumAggregateInputType
    _min?: AlertConditionMinAggregateInputType
    _max?: AlertConditionMaxAggregateInputType
  }

  export type AlertConditionGroupByOutputType = {
    id: number
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin: number | null
    repeatIntervalMin: number | null
    countThreshold: number | null
    lastTriggeredAt: Date | null
    active: boolean
    emailTemplateId: number | null
    _count: AlertConditionCountAggregateOutputType | null
    _avg: AlertConditionAvgAggregateOutputType | null
    _sum: AlertConditionSumAggregateOutputType | null
    _min: AlertConditionMinAggregateOutputType | null
    _max: AlertConditionMaxAggregateOutputType | null
  }

  type GetAlertConditionGroupByPayload<T extends AlertConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertConditionGroupByOutputType[P]>
            : GetScalarType<T[P], AlertConditionGroupByOutputType[P]>
        }
      >
    >


  export type AlertConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sourceTable?: boolean
    fieldName?: boolean
    comparator?: boolean
    thresholdValue?: boolean
    timeWindowMin?: boolean
    repeatIntervalMin?: boolean
    countThreshold?: boolean
    lastTriggeredAt?: boolean
    active?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | AlertCondition$emailTemplateArgs<ExtArgs>
    triggeredAlerts?: boolean | AlertCondition$triggeredAlertsArgs<ExtArgs>
    _count?: boolean | AlertConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertCondition"]>

  export type AlertConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sourceTable?: boolean
    fieldName?: boolean
    comparator?: boolean
    thresholdValue?: boolean
    timeWindowMin?: boolean
    repeatIntervalMin?: boolean
    countThreshold?: boolean
    lastTriggeredAt?: boolean
    active?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | AlertCondition$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["alertCondition"]>

  export type AlertConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sourceTable?: boolean
    fieldName?: boolean
    comparator?: boolean
    thresholdValue?: boolean
    timeWindowMin?: boolean
    repeatIntervalMin?: boolean
    countThreshold?: boolean
    lastTriggeredAt?: boolean
    active?: boolean
    emailTemplateId?: boolean
    emailTemplate?: boolean | AlertCondition$emailTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["alertCondition"]>

  export type AlertConditionSelectScalar = {
    id?: boolean
    name?: boolean
    sourceTable?: boolean
    fieldName?: boolean
    comparator?: boolean
    thresholdValue?: boolean
    timeWindowMin?: boolean
    repeatIntervalMin?: boolean
    countThreshold?: boolean
    lastTriggeredAt?: boolean
    active?: boolean
    emailTemplateId?: boolean
  }

  export type AlertConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sourceTable" | "fieldName" | "comparator" | "thresholdValue" | "timeWindowMin" | "repeatIntervalMin" | "countThreshold" | "lastTriggeredAt" | "active" | "emailTemplateId", ExtArgs["result"]["alertCondition"]>
  export type AlertConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | AlertCondition$emailTemplateArgs<ExtArgs>
    triggeredAlerts?: boolean | AlertCondition$triggeredAlertsArgs<ExtArgs>
    _count?: boolean | AlertConditionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | AlertCondition$emailTemplateArgs<ExtArgs>
  }
  export type AlertConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTemplate?: boolean | AlertCondition$emailTemplateArgs<ExtArgs>
  }

  export type $AlertConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertCondition"
    objects: {
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
      triggeredAlerts: Prisma.$AlertEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      sourceTable: string
      fieldName: string
      comparator: string
      thresholdValue: string
      timeWindowMin: number | null
      repeatIntervalMin: number | null
      countThreshold: number | null
      lastTriggeredAt: Date | null
      active: boolean
      emailTemplateId: number | null
    }, ExtArgs["result"]["alertCondition"]>
    composites: {}
  }

  type AlertConditionGetPayload<S extends boolean | null | undefined | AlertConditionDefaultArgs> = $Result.GetResult<Prisma.$AlertConditionPayload, S>

  type AlertConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertConditionCountAggregateInputType | true
    }

  export interface AlertConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertCondition'], meta: { name: 'AlertCondition' } }
    /**
     * Find zero or one AlertCondition that matches the filter.
     * @param {AlertConditionFindUniqueArgs} args - Arguments to find a AlertCondition
     * @example
     * // Get one AlertCondition
     * const alertCondition = await prisma.alertCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertConditionFindUniqueArgs>(args: SelectSubset<T, AlertConditionFindUniqueArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AlertCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertConditionFindUniqueOrThrowArgs} args - Arguments to find a AlertCondition
     * @example
     * // Get one AlertCondition
     * const alertCondition = await prisma.alertCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AlertCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionFindFirstArgs} args - Arguments to find a AlertCondition
     * @example
     * // Get one AlertCondition
     * const alertCondition = await prisma.alertCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertConditionFindFirstArgs>(args?: SelectSubset<T, AlertConditionFindFirstArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AlertCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionFindFirstOrThrowArgs} args - Arguments to find a AlertCondition
     * @example
     * // Get one AlertCondition
     * const alertCondition = await prisma.alertCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AlertConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertConditions
     * const alertConditions = await prisma.alertCondition.findMany()
     * 
     * // Get first 10 AlertConditions
     * const alertConditions = await prisma.alertCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertConditionWithIdOnly = await prisma.alertCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertConditionFindManyArgs>(args?: SelectSubset<T, AlertConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AlertCondition.
     * @param {AlertConditionCreateArgs} args - Arguments to create a AlertCondition.
     * @example
     * // Create one AlertCondition
     * const AlertCondition = await prisma.alertCondition.create({
     *   data: {
     *     // ... data to create a AlertCondition
     *   }
     * })
     * 
     */
    create<T extends AlertConditionCreateArgs>(args: SelectSubset<T, AlertConditionCreateArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AlertConditions.
     * @param {AlertConditionCreateManyArgs} args - Arguments to create many AlertConditions.
     * @example
     * // Create many AlertConditions
     * const alertCondition = await prisma.alertCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertConditionCreateManyArgs>(args?: SelectSubset<T, AlertConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertConditions and returns the data saved in the database.
     * @param {AlertConditionCreateManyAndReturnArgs} args - Arguments to create many AlertConditions.
     * @example
     * // Create many AlertConditions
     * const alertCondition = await prisma.alertCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertConditions and only return the `id`
     * const alertConditionWithIdOnly = await prisma.alertCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AlertCondition.
     * @param {AlertConditionDeleteArgs} args - Arguments to delete one AlertCondition.
     * @example
     * // Delete one AlertCondition
     * const AlertCondition = await prisma.alertCondition.delete({
     *   where: {
     *     // ... filter to delete one AlertCondition
     *   }
     * })
     * 
     */
    delete<T extends AlertConditionDeleteArgs>(args: SelectSubset<T, AlertConditionDeleteArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AlertCondition.
     * @param {AlertConditionUpdateArgs} args - Arguments to update one AlertCondition.
     * @example
     * // Update one AlertCondition
     * const alertCondition = await prisma.alertCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertConditionUpdateArgs>(args: SelectSubset<T, AlertConditionUpdateArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AlertConditions.
     * @param {AlertConditionDeleteManyArgs} args - Arguments to filter AlertConditions to delete.
     * @example
     * // Delete a few AlertConditions
     * const { count } = await prisma.alertCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertConditionDeleteManyArgs>(args?: SelectSubset<T, AlertConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertConditions
     * const alertCondition = await prisma.alertCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertConditionUpdateManyArgs>(args: SelectSubset<T, AlertConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertConditions and returns the data updated in the database.
     * @param {AlertConditionUpdateManyAndReturnArgs} args - Arguments to update many AlertConditions.
     * @example
     * // Update many AlertConditions
     * const alertCondition = await prisma.alertCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertConditions and only return the `id`
     * const alertConditionWithIdOnly = await prisma.alertCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AlertCondition.
     * @param {AlertConditionUpsertArgs} args - Arguments to update or create a AlertCondition.
     * @example
     * // Update or create a AlertCondition
     * const alertCondition = await prisma.alertCondition.upsert({
     *   create: {
     *     // ... data to create a AlertCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertCondition we want to update
     *   }
     * })
     */
    upsert<T extends AlertConditionUpsertArgs>(args: SelectSubset<T, AlertConditionUpsertArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AlertConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionCountArgs} args - Arguments to filter AlertConditions to count.
     * @example
     * // Count the number of AlertConditions
     * const count = await prisma.alertCondition.count({
     *   where: {
     *     // ... the filter for the AlertConditions we want to count
     *   }
     * })
    **/
    count<T extends AlertConditionCountArgs>(
      args?: Subset<T, AlertConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertConditionAggregateArgs>(args: Subset<T, AlertConditionAggregateArgs>): Prisma.PrismaPromise<GetAlertConditionAggregateType<T>>

    /**
     * Group by AlertCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertConditionGroupByArgs['orderBy'] }
        : { orderBy?: AlertConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertCondition model
   */
  readonly fields: AlertConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailTemplate<T extends AlertCondition$emailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, AlertCondition$emailTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    triggeredAlerts<T extends AlertCondition$triggeredAlertsArgs<ExtArgs> = {}>(args?: Subset<T, AlertCondition$triggeredAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertCondition model
   */ 
  interface AlertConditionFieldRefs {
    readonly id: FieldRef<"AlertCondition", 'Int'>
    readonly name: FieldRef<"AlertCondition", 'String'>
    readonly sourceTable: FieldRef<"AlertCondition", 'String'>
    readonly fieldName: FieldRef<"AlertCondition", 'String'>
    readonly comparator: FieldRef<"AlertCondition", 'String'>
    readonly thresholdValue: FieldRef<"AlertCondition", 'String'>
    readonly timeWindowMin: FieldRef<"AlertCondition", 'Int'>
    readonly repeatIntervalMin: FieldRef<"AlertCondition", 'Int'>
    readonly countThreshold: FieldRef<"AlertCondition", 'Int'>
    readonly lastTriggeredAt: FieldRef<"AlertCondition", 'DateTime'>
    readonly active: FieldRef<"AlertCondition", 'Boolean'>
    readonly emailTemplateId: FieldRef<"AlertCondition", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AlertCondition findUnique
   */
  export type AlertConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * Filter, which AlertCondition to fetch.
     */
    where: AlertConditionWhereUniqueInput
  }

  /**
   * AlertCondition findUniqueOrThrow
   */
  export type AlertConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * Filter, which AlertCondition to fetch.
     */
    where: AlertConditionWhereUniqueInput
  }

  /**
   * AlertCondition findFirst
   */
  export type AlertConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * Filter, which AlertCondition to fetch.
     */
    where?: AlertConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConditions to fetch.
     */
    orderBy?: AlertConditionOrderByWithRelationInput | AlertConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertConditions.
     */
    cursor?: AlertConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertConditions.
     */
    distinct?: AlertConditionScalarFieldEnum | AlertConditionScalarFieldEnum[]
  }

  /**
   * AlertCondition findFirstOrThrow
   */
  export type AlertConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * Filter, which AlertCondition to fetch.
     */
    where?: AlertConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConditions to fetch.
     */
    orderBy?: AlertConditionOrderByWithRelationInput | AlertConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertConditions.
     */
    cursor?: AlertConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertConditions.
     */
    distinct?: AlertConditionScalarFieldEnum | AlertConditionScalarFieldEnum[]
  }

  /**
   * AlertCondition findMany
   */
  export type AlertConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * Filter, which AlertConditions to fetch.
     */
    where?: AlertConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertConditions to fetch.
     */
    orderBy?: AlertConditionOrderByWithRelationInput | AlertConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertConditions.
     */
    cursor?: AlertConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertConditions.
     */
    skip?: number
    distinct?: AlertConditionScalarFieldEnum | AlertConditionScalarFieldEnum[]
  }

  /**
   * AlertCondition create
   */
  export type AlertConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertCondition.
     */
    data: XOR<AlertConditionCreateInput, AlertConditionUncheckedCreateInput>
  }

  /**
   * AlertCondition createMany
   */
  export type AlertConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertConditions.
     */
    data: AlertConditionCreateManyInput | AlertConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertCondition createManyAndReturn
   */
  export type AlertConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * The data used to create many AlertConditions.
     */
    data: AlertConditionCreateManyInput | AlertConditionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertCondition update
   */
  export type AlertConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertCondition.
     */
    data: XOR<AlertConditionUpdateInput, AlertConditionUncheckedUpdateInput>
    /**
     * Choose, which AlertCondition to update.
     */
    where: AlertConditionWhereUniqueInput
  }

  /**
   * AlertCondition updateMany
   */
  export type AlertConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertConditions.
     */
    data: XOR<AlertConditionUpdateManyMutationInput, AlertConditionUncheckedUpdateManyInput>
    /**
     * Filter which AlertConditions to update
     */
    where?: AlertConditionWhereInput
    /**
     * Limit how many AlertConditions to update.
     */
    limit?: number
  }

  /**
   * AlertCondition updateManyAndReturn
   */
  export type AlertConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * The data used to update AlertConditions.
     */
    data: XOR<AlertConditionUpdateManyMutationInput, AlertConditionUncheckedUpdateManyInput>
    /**
     * Filter which AlertConditions to update
     */
    where?: AlertConditionWhereInput
    /**
     * Limit how many AlertConditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertCondition upsert
   */
  export type AlertConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertCondition to update in case it exists.
     */
    where: AlertConditionWhereUniqueInput
    /**
     * In case the AlertCondition found by the `where` argument doesn't exist, create a new AlertCondition with this data.
     */
    create: XOR<AlertConditionCreateInput, AlertConditionUncheckedCreateInput>
    /**
     * In case the AlertCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertConditionUpdateInput, AlertConditionUncheckedUpdateInput>
  }

  /**
   * AlertCondition delete
   */
  export type AlertConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
    /**
     * Filter which AlertCondition to delete.
     */
    where: AlertConditionWhereUniqueInput
  }

  /**
   * AlertCondition deleteMany
   */
  export type AlertConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertConditions to delete
     */
    where?: AlertConditionWhereInput
    /**
     * Limit how many AlertConditions to delete.
     */
    limit?: number
  }

  /**
   * AlertCondition.emailTemplate
   */
  export type AlertCondition$emailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * AlertCondition.triggeredAlerts
   */
  export type AlertCondition$triggeredAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    cursor?: AlertEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertCondition without action
   */
  export type AlertConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCondition
     */
    select?: AlertConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertCondition
     */
    omit?: AlertConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertConditionInclude<ExtArgs> | null
  }


  /**
   * Model AlertEvent
   */

  export type AggregateAlertEvent = {
    _count: AlertEventCountAggregateOutputType | null
    _avg: AlertEventAvgAggregateOutputType | null
    _sum: AlertEventSumAggregateOutputType | null
    _min: AlertEventMinAggregateOutputType | null
    _max: AlertEventMaxAggregateOutputType | null
  }

  export type AlertEventAvgAggregateOutputType = {
    id: number | null
    conditionId: number | null
  }

  export type AlertEventSumAggregateOutputType = {
    id: number | null
    conditionId: number | null
  }

  export type AlertEventMinAggregateOutputType = {
    id: number | null
    conditionId: number | null
    triggeredAt: Date | null
    resolved: boolean | null
    resolvedAt: Date | null
    notes: string | null
  }

  export type AlertEventMaxAggregateOutputType = {
    id: number | null
    conditionId: number | null
    triggeredAt: Date | null
    resolved: boolean | null
    resolvedAt: Date | null
    notes: string | null
  }

  export type AlertEventCountAggregateOutputType = {
    id: number
    conditionId: number
    triggeredAt: number
    resolved: number
    resolvedAt: number
    notes: number
    _all: number
  }


  export type AlertEventAvgAggregateInputType = {
    id?: true
    conditionId?: true
  }

  export type AlertEventSumAggregateInputType = {
    id?: true
    conditionId?: true
  }

  export type AlertEventMinAggregateInputType = {
    id?: true
    conditionId?: true
    triggeredAt?: true
    resolved?: true
    resolvedAt?: true
    notes?: true
  }

  export type AlertEventMaxAggregateInputType = {
    id?: true
    conditionId?: true
    triggeredAt?: true
    resolved?: true
    resolvedAt?: true
    notes?: true
  }

  export type AlertEventCountAggregateInputType = {
    id?: true
    conditionId?: true
    triggeredAt?: true
    resolved?: true
    resolvedAt?: true
    notes?: true
    _all?: true
  }

  export type AlertEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertEvent to aggregate.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertEvents
    **/
    _count?: true | AlertEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertEventMaxAggregateInputType
  }

  export type GetAlertEventAggregateType<T extends AlertEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertEvent[P]>
      : GetScalarType<T[P], AggregateAlertEvent[P]>
  }




  export type AlertEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithAggregationInput | AlertEventOrderByWithAggregationInput[]
    by: AlertEventScalarFieldEnum[] | AlertEventScalarFieldEnum
    having?: AlertEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertEventCountAggregateInputType | true
    _avg?: AlertEventAvgAggregateInputType
    _sum?: AlertEventSumAggregateInputType
    _min?: AlertEventMinAggregateInputType
    _max?: AlertEventMaxAggregateInputType
  }

  export type AlertEventGroupByOutputType = {
    id: number
    conditionId: number
    triggeredAt: Date
    resolved: boolean
    resolvedAt: Date | null
    notes: string | null
    _count: AlertEventCountAggregateOutputType | null
    _avg: AlertEventAvgAggregateOutputType | null
    _sum: AlertEventSumAggregateOutputType | null
    _min: AlertEventMinAggregateOutputType | null
    _max: AlertEventMaxAggregateOutputType | null
  }

  type GetAlertEventGroupByPayload<T extends AlertEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertEventGroupByOutputType[P]>
            : GetScalarType<T[P], AlertEventGroupByOutputType[P]>
        }
      >
    >


  export type AlertEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionId?: boolean
    triggeredAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    notes?: boolean
    alertCondition?: boolean | AlertConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionId?: boolean
    triggeredAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    notes?: boolean
    alertCondition?: boolean | AlertConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionId?: boolean
    triggeredAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    notes?: boolean
    alertCondition?: boolean | AlertConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectScalar = {
    id?: boolean
    conditionId?: boolean
    triggeredAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    notes?: boolean
  }

  export type AlertEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conditionId" | "triggeredAt" | "resolved" | "resolvedAt" | "notes", ExtArgs["result"]["alertEvent"]>
  export type AlertEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertCondition?: boolean | AlertConditionDefaultArgs<ExtArgs>
  }
  export type AlertEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertCondition?: boolean | AlertConditionDefaultArgs<ExtArgs>
  }
  export type AlertEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertCondition?: boolean | AlertConditionDefaultArgs<ExtArgs>
  }

  export type $AlertEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertEvent"
    objects: {
      alertCondition: Prisma.$AlertConditionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conditionId: number
      triggeredAt: Date
      resolved: boolean
      resolvedAt: Date | null
      notes: string | null
    }, ExtArgs["result"]["alertEvent"]>
    composites: {}
  }

  type AlertEventGetPayload<S extends boolean | null | undefined | AlertEventDefaultArgs> = $Result.GetResult<Prisma.$AlertEventPayload, S>

  type AlertEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertEventCountAggregateInputType | true
    }

  export interface AlertEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertEvent'], meta: { name: 'AlertEvent' } }
    /**
     * Find zero or one AlertEvent that matches the filter.
     * @param {AlertEventFindUniqueArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertEventFindUniqueArgs>(args: SelectSubset<T, AlertEventFindUniqueArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AlertEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertEventFindUniqueOrThrowArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AlertEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindFirstArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertEventFindFirstArgs>(args?: SelectSubset<T, AlertEventFindFirstArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AlertEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindFirstOrThrowArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AlertEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertEvents
     * const alertEvents = await prisma.alertEvent.findMany()
     * 
     * // Get first 10 AlertEvents
     * const alertEvents = await prisma.alertEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertEventFindManyArgs>(args?: SelectSubset<T, AlertEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AlertEvent.
     * @param {AlertEventCreateArgs} args - Arguments to create a AlertEvent.
     * @example
     * // Create one AlertEvent
     * const AlertEvent = await prisma.alertEvent.create({
     *   data: {
     *     // ... data to create a AlertEvent
     *   }
     * })
     * 
     */
    create<T extends AlertEventCreateArgs>(args: SelectSubset<T, AlertEventCreateArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AlertEvents.
     * @param {AlertEventCreateManyArgs} args - Arguments to create many AlertEvents.
     * @example
     * // Create many AlertEvents
     * const alertEvent = await prisma.alertEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertEventCreateManyArgs>(args?: SelectSubset<T, AlertEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertEvents and returns the data saved in the database.
     * @param {AlertEventCreateManyAndReturnArgs} args - Arguments to create many AlertEvents.
     * @example
     * // Create many AlertEvents
     * const alertEvent = await prisma.alertEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertEvents and only return the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AlertEvent.
     * @param {AlertEventDeleteArgs} args - Arguments to delete one AlertEvent.
     * @example
     * // Delete one AlertEvent
     * const AlertEvent = await prisma.alertEvent.delete({
     *   where: {
     *     // ... filter to delete one AlertEvent
     *   }
     * })
     * 
     */
    delete<T extends AlertEventDeleteArgs>(args: SelectSubset<T, AlertEventDeleteArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AlertEvent.
     * @param {AlertEventUpdateArgs} args - Arguments to update one AlertEvent.
     * @example
     * // Update one AlertEvent
     * const alertEvent = await prisma.alertEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertEventUpdateArgs>(args: SelectSubset<T, AlertEventUpdateArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AlertEvents.
     * @param {AlertEventDeleteManyArgs} args - Arguments to filter AlertEvents to delete.
     * @example
     * // Delete a few AlertEvents
     * const { count } = await prisma.alertEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertEventDeleteManyArgs>(args?: SelectSubset<T, AlertEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertEvents
     * const alertEvent = await prisma.alertEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertEventUpdateManyArgs>(args: SelectSubset<T, AlertEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertEvents and returns the data updated in the database.
     * @param {AlertEventUpdateManyAndReturnArgs} args - Arguments to update many AlertEvents.
     * @example
     * // Update many AlertEvents
     * const alertEvent = await prisma.alertEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertEvents and only return the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AlertEvent.
     * @param {AlertEventUpsertArgs} args - Arguments to update or create a AlertEvent.
     * @example
     * // Update or create a AlertEvent
     * const alertEvent = await prisma.alertEvent.upsert({
     *   create: {
     *     // ... data to create a AlertEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertEvent we want to update
     *   }
     * })
     */
    upsert<T extends AlertEventUpsertArgs>(args: SelectSubset<T, AlertEventUpsertArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventCountArgs} args - Arguments to filter AlertEvents to count.
     * @example
     * // Count the number of AlertEvents
     * const count = await prisma.alertEvent.count({
     *   where: {
     *     // ... the filter for the AlertEvents we want to count
     *   }
     * })
    **/
    count<T extends AlertEventCountArgs>(
      args?: Subset<T, AlertEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertEventAggregateArgs>(args: Subset<T, AlertEventAggregateArgs>): Prisma.PrismaPromise<GetAlertEventAggregateType<T>>

    /**
     * Group by AlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertEventGroupByArgs['orderBy'] }
        : { orderBy?: AlertEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertEvent model
   */
  readonly fields: AlertEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alertCondition<T extends AlertConditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertConditionDefaultArgs<ExtArgs>>): Prisma__AlertConditionClient<$Result.GetResult<Prisma.$AlertConditionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertEvent model
   */ 
  interface AlertEventFieldRefs {
    readonly id: FieldRef<"AlertEvent", 'Int'>
    readonly conditionId: FieldRef<"AlertEvent", 'Int'>
    readonly triggeredAt: FieldRef<"AlertEvent", 'DateTime'>
    readonly resolved: FieldRef<"AlertEvent", 'Boolean'>
    readonly resolvedAt: FieldRef<"AlertEvent", 'DateTime'>
    readonly notes: FieldRef<"AlertEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlertEvent findUnique
   */
  export type AlertEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent findUniqueOrThrow
   */
  export type AlertEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent findFirst
   */
  export type AlertEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertEvents.
     */
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent findFirstOrThrow
   */
  export type AlertEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertEvents.
     */
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent findMany
   */
  export type AlertEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvents to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent create
   */
  export type AlertEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertEvent.
     */
    data: XOR<AlertEventCreateInput, AlertEventUncheckedCreateInput>
  }

  /**
   * AlertEvent createMany
   */
  export type AlertEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertEvents.
     */
    data: AlertEventCreateManyInput | AlertEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertEvent createManyAndReturn
   */
  export type AlertEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * The data used to create many AlertEvents.
     */
    data: AlertEventCreateManyInput | AlertEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertEvent update
   */
  export type AlertEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertEvent.
     */
    data: XOR<AlertEventUpdateInput, AlertEventUncheckedUpdateInput>
    /**
     * Choose, which AlertEvent to update.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent updateMany
   */
  export type AlertEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertEvents.
     */
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyInput>
    /**
     * Filter which AlertEvents to update
     */
    where?: AlertEventWhereInput
    /**
     * Limit how many AlertEvents to update.
     */
    limit?: number
  }

  /**
   * AlertEvent updateManyAndReturn
   */
  export type AlertEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * The data used to update AlertEvents.
     */
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyInput>
    /**
     * Filter which AlertEvents to update
     */
    where?: AlertEventWhereInput
    /**
     * Limit how many AlertEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertEvent upsert
   */
  export type AlertEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertEvent to update in case it exists.
     */
    where: AlertEventWhereUniqueInput
    /**
     * In case the AlertEvent found by the `where` argument doesn't exist, create a new AlertEvent with this data.
     */
    create: XOR<AlertEventCreateInput, AlertEventUncheckedCreateInput>
    /**
     * In case the AlertEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertEventUpdateInput, AlertEventUncheckedUpdateInput>
  }

  /**
   * AlertEvent delete
   */
  export type AlertEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter which AlertEvent to delete.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent deleteMany
   */
  export type AlertEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertEvents to delete
     */
    where?: AlertEventWhereInput
    /**
     * Limit how many AlertEvents to delete.
     */
    limit?: number
  }

  /**
   * AlertEvent without action
   */
  export type AlertEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertEvent
     */
    omit?: AlertEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
  }


  /**
   * Model LibraryEntry
   */

  export type AggregateLibraryEntry = {
    _count: LibraryEntryCountAggregateOutputType | null
    _avg: LibraryEntryAvgAggregateOutputType | null
    _sum: LibraryEntrySumAggregateOutputType | null
    _min: LibraryEntryMinAggregateOutputType | null
    _max: LibraryEntryMaxAggregateOutputType | null
  }

  export type LibraryEntryAvgAggregateOutputType = {
    id: number | null
    pubYear: number | null
  }

  export type LibraryEntrySumAggregateOutputType = {
    id: number | null
    pubYear: number | null
  }

  export type LibraryEntryMinAggregateOutputType = {
    id: number | null
    refNo: string | null
    category: string | null
    title: string | null
    author: string | null
    pubYear: number | null
    creationDate: Date | null
    borrower: string | null
    loanDate: Date | null
    remarks: string | null
    attachmentUrl: string | null
    attachmentFilename: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryEntryMaxAggregateOutputType = {
    id: number | null
    refNo: string | null
    category: string | null
    title: string | null
    author: string | null
    pubYear: number | null
    creationDate: Date | null
    borrower: string | null
    loanDate: Date | null
    remarks: string | null
    attachmentUrl: string | null
    attachmentFilename: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryEntryCountAggregateOutputType = {
    id: number
    refNo: number
    category: number
    title: number
    author: number
    pubYear: number
    creationDate: number
    borrower: number
    loanDate: number
    remarks: number
    attachmentUrl: number
    attachmentFilename: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryEntryAvgAggregateInputType = {
    id?: true
    pubYear?: true
  }

  export type LibraryEntrySumAggregateInputType = {
    id?: true
    pubYear?: true
  }

  export type LibraryEntryMinAggregateInputType = {
    id?: true
    refNo?: true
    category?: true
    title?: true
    author?: true
    pubYear?: true
    creationDate?: true
    borrower?: true
    loanDate?: true
    remarks?: true
    attachmentUrl?: true
    attachmentFilename?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryEntryMaxAggregateInputType = {
    id?: true
    refNo?: true
    category?: true
    title?: true
    author?: true
    pubYear?: true
    creationDate?: true
    borrower?: true
    loanDate?: true
    remarks?: true
    attachmentUrl?: true
    attachmentFilename?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryEntryCountAggregateInputType = {
    id?: true
    refNo?: true
    category?: true
    title?: true
    author?: true
    pubYear?: true
    creationDate?: true
    borrower?: true
    loanDate?: true
    remarks?: true
    attachmentUrl?: true
    attachmentFilename?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryEntry to aggregate.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryEntries
    **/
    _count?: true | LibraryEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryEntryMaxAggregateInputType
  }

  export type GetLibraryEntryAggregateType<T extends LibraryEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryEntry[P]>
      : GetScalarType<T[P], AggregateLibraryEntry[P]>
  }




  export type LibraryEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryEntryWhereInput
    orderBy?: LibraryEntryOrderByWithAggregationInput | LibraryEntryOrderByWithAggregationInput[]
    by: LibraryEntryScalarFieldEnum[] | LibraryEntryScalarFieldEnum
    having?: LibraryEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryEntryCountAggregateInputType | true
    _avg?: LibraryEntryAvgAggregateInputType
    _sum?: LibraryEntrySumAggregateInputType
    _min?: LibraryEntryMinAggregateInputType
    _max?: LibraryEntryMaxAggregateInputType
  }

  export type LibraryEntryGroupByOutputType = {
    id: number
    refNo: string
    category: string
    title: string
    author: string | null
    pubYear: number | null
    creationDate: Date
    borrower: string | null
    loanDate: Date | null
    remarks: string | null
    attachmentUrl: string | null
    attachmentFilename: string | null
    createdAt: Date
    updatedAt: Date
    _count: LibraryEntryCountAggregateOutputType | null
    _avg: LibraryEntryAvgAggregateOutputType | null
    _sum: LibraryEntrySumAggregateOutputType | null
    _min: LibraryEntryMinAggregateOutputType | null
    _max: LibraryEntryMaxAggregateOutputType | null
  }

  type GetLibraryEntryGroupByPayload<T extends LibraryEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryEntryGroupByOutputType[P]>
        }
      >
    >


  export type LibraryEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    category?: boolean
    title?: boolean
    author?: boolean
    pubYear?: boolean
    creationDate?: boolean
    borrower?: boolean
    loanDate?: boolean
    remarks?: boolean
    attachmentUrl?: boolean
    attachmentFilename?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["libraryEntry"]>

  export type LibraryEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    category?: boolean
    title?: boolean
    author?: boolean
    pubYear?: boolean
    creationDate?: boolean
    borrower?: boolean
    loanDate?: boolean
    remarks?: boolean
    attachmentUrl?: boolean
    attachmentFilename?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["libraryEntry"]>

  export type LibraryEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    category?: boolean
    title?: boolean
    author?: boolean
    pubYear?: boolean
    creationDate?: boolean
    borrower?: boolean
    loanDate?: boolean
    remarks?: boolean
    attachmentUrl?: boolean
    attachmentFilename?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["libraryEntry"]>

  export type LibraryEntrySelectScalar = {
    id?: boolean
    refNo?: boolean
    category?: boolean
    title?: boolean
    author?: boolean
    pubYear?: boolean
    creationDate?: boolean
    borrower?: boolean
    loanDate?: boolean
    remarks?: boolean
    attachmentUrl?: boolean
    attachmentFilename?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LibraryEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "refNo" | "category" | "title" | "author" | "pubYear" | "creationDate" | "borrower" | "loanDate" | "remarks" | "attachmentUrl" | "attachmentFilename" | "createdAt" | "updatedAt", ExtArgs["result"]["libraryEntry"]>

  export type $LibraryEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LibraryEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      refNo: string
      category: string
      title: string
      author: string | null
      pubYear: number | null
      creationDate: Date
      borrower: string | null
      loanDate: Date | null
      remarks: string | null
      attachmentUrl: string | null
      attachmentFilename: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["libraryEntry"]>
    composites: {}
  }

  type LibraryEntryGetPayload<S extends boolean | null | undefined | LibraryEntryDefaultArgs> = $Result.GetResult<Prisma.$LibraryEntryPayload, S>

  type LibraryEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LibraryEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LibraryEntryCountAggregateInputType | true
    }

  export interface LibraryEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryEntry'], meta: { name: 'LibraryEntry' } }
    /**
     * Find zero or one LibraryEntry that matches the filter.
     * @param {LibraryEntryFindUniqueArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryEntryFindUniqueArgs>(args: SelectSubset<T, LibraryEntryFindUniqueArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LibraryEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryEntryFindUniqueOrThrowArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LibraryEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryFindFirstArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryEntryFindFirstArgs>(args?: SelectSubset<T, LibraryEntryFindFirstArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LibraryEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryFindFirstOrThrowArgs} args - Arguments to find a LibraryEntry
     * @example
     * // Get one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LibraryEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryEntries
     * const libraryEntries = await prisma.libraryEntry.findMany()
     * 
     * // Get first 10 LibraryEntries
     * const libraryEntries = await prisma.libraryEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryEntryWithIdOnly = await prisma.libraryEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryEntryFindManyArgs>(args?: SelectSubset<T, LibraryEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LibraryEntry.
     * @param {LibraryEntryCreateArgs} args - Arguments to create a LibraryEntry.
     * @example
     * // Create one LibraryEntry
     * const LibraryEntry = await prisma.libraryEntry.create({
     *   data: {
     *     // ... data to create a LibraryEntry
     *   }
     * })
     * 
     */
    create<T extends LibraryEntryCreateArgs>(args: SelectSubset<T, LibraryEntryCreateArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LibraryEntries.
     * @param {LibraryEntryCreateManyArgs} args - Arguments to create many LibraryEntries.
     * @example
     * // Create many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryEntryCreateManyArgs>(args?: SelectSubset<T, LibraryEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LibraryEntries and returns the data saved in the database.
     * @param {LibraryEntryCreateManyAndReturnArgs} args - Arguments to create many LibraryEntries.
     * @example
     * // Create many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LibraryEntries and only return the `id`
     * const libraryEntryWithIdOnly = await prisma.libraryEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LibraryEntry.
     * @param {LibraryEntryDeleteArgs} args - Arguments to delete one LibraryEntry.
     * @example
     * // Delete one LibraryEntry
     * const LibraryEntry = await prisma.libraryEntry.delete({
     *   where: {
     *     // ... filter to delete one LibraryEntry
     *   }
     * })
     * 
     */
    delete<T extends LibraryEntryDeleteArgs>(args: SelectSubset<T, LibraryEntryDeleteArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LibraryEntry.
     * @param {LibraryEntryUpdateArgs} args - Arguments to update one LibraryEntry.
     * @example
     * // Update one LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryEntryUpdateArgs>(args: SelectSubset<T, LibraryEntryUpdateArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LibraryEntries.
     * @param {LibraryEntryDeleteManyArgs} args - Arguments to filter LibraryEntries to delete.
     * @example
     * // Delete a few LibraryEntries
     * const { count } = await prisma.libraryEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryEntryDeleteManyArgs>(args?: SelectSubset<T, LibraryEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryEntryUpdateManyArgs>(args: SelectSubset<T, LibraryEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryEntries and returns the data updated in the database.
     * @param {LibraryEntryUpdateManyAndReturnArgs} args - Arguments to update many LibraryEntries.
     * @example
     * // Update many LibraryEntries
     * const libraryEntry = await prisma.libraryEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LibraryEntries and only return the `id`
     * const libraryEntryWithIdOnly = await prisma.libraryEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LibraryEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LibraryEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LibraryEntry.
     * @param {LibraryEntryUpsertArgs} args - Arguments to update or create a LibraryEntry.
     * @example
     * // Update or create a LibraryEntry
     * const libraryEntry = await prisma.libraryEntry.upsert({
     *   create: {
     *     // ... data to create a LibraryEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryEntry we want to update
     *   }
     * })
     */
    upsert<T extends LibraryEntryUpsertArgs>(args: SelectSubset<T, LibraryEntryUpsertArgs<ExtArgs>>): Prisma__LibraryEntryClient<$Result.GetResult<Prisma.$LibraryEntryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LibraryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryCountArgs} args - Arguments to filter LibraryEntries to count.
     * @example
     * // Count the number of LibraryEntries
     * const count = await prisma.libraryEntry.count({
     *   where: {
     *     // ... the filter for the LibraryEntries we want to count
     *   }
     * })
    **/
    count<T extends LibraryEntryCountArgs>(
      args?: Subset<T, LibraryEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryEntryAggregateArgs>(args: Subset<T, LibraryEntryAggregateArgs>): Prisma.PrismaPromise<GetLibraryEntryAggregateType<T>>

    /**
     * Group by LibraryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryEntryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryEntry model
   */
  readonly fields: LibraryEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LibraryEntry model
   */ 
  interface LibraryEntryFieldRefs {
    readonly id: FieldRef<"LibraryEntry", 'Int'>
    readonly refNo: FieldRef<"LibraryEntry", 'String'>
    readonly category: FieldRef<"LibraryEntry", 'String'>
    readonly title: FieldRef<"LibraryEntry", 'String'>
    readonly author: FieldRef<"LibraryEntry", 'String'>
    readonly pubYear: FieldRef<"LibraryEntry", 'Int'>
    readonly creationDate: FieldRef<"LibraryEntry", 'DateTime'>
    readonly borrower: FieldRef<"LibraryEntry", 'String'>
    readonly loanDate: FieldRef<"LibraryEntry", 'DateTime'>
    readonly remarks: FieldRef<"LibraryEntry", 'String'>
    readonly attachmentUrl: FieldRef<"LibraryEntry", 'String'>
    readonly attachmentFilename: FieldRef<"LibraryEntry", 'String'>
    readonly createdAt: FieldRef<"LibraryEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"LibraryEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LibraryEntry findUnique
   */
  export type LibraryEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry findUniqueOrThrow
   */
  export type LibraryEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry findFirst
   */
  export type LibraryEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryEntries.
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryEntries.
     */
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * LibraryEntry findFirstOrThrow
   */
  export type LibraryEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Filter, which LibraryEntry to fetch.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryEntries.
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryEntries.
     */
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * LibraryEntry findMany
   */
  export type LibraryEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Filter, which LibraryEntries to fetch.
     */
    where?: LibraryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryEntries to fetch.
     */
    orderBy?: LibraryEntryOrderByWithRelationInput | LibraryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryEntries.
     */
    cursor?: LibraryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryEntries.
     */
    skip?: number
    distinct?: LibraryEntryScalarFieldEnum | LibraryEntryScalarFieldEnum[]
  }

  /**
   * LibraryEntry create
   */
  export type LibraryEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a LibraryEntry.
     */
    data: XOR<LibraryEntryCreateInput, LibraryEntryUncheckedCreateInput>
  }

  /**
   * LibraryEntry createMany
   */
  export type LibraryEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryEntries.
     */
    data: LibraryEntryCreateManyInput | LibraryEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LibraryEntry createManyAndReturn
   */
  export type LibraryEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LibraryEntries.
     */
    data: LibraryEntryCreateManyInput | LibraryEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LibraryEntry update
   */
  export type LibraryEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a LibraryEntry.
     */
    data: XOR<LibraryEntryUpdateInput, LibraryEntryUncheckedUpdateInput>
    /**
     * Choose, which LibraryEntry to update.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry updateMany
   */
  export type LibraryEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryEntries.
     */
    data: XOR<LibraryEntryUpdateManyMutationInput, LibraryEntryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryEntries to update
     */
    where?: LibraryEntryWhereInput
    /**
     * Limit how many LibraryEntries to update.
     */
    limit?: number
  }

  /**
   * LibraryEntry updateManyAndReturn
   */
  export type LibraryEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The data used to update LibraryEntries.
     */
    data: XOR<LibraryEntryUpdateManyMutationInput, LibraryEntryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryEntries to update
     */
    where?: LibraryEntryWhereInput
    /**
     * Limit how many LibraryEntries to update.
     */
    limit?: number
  }

  /**
   * LibraryEntry upsert
   */
  export type LibraryEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the LibraryEntry to update in case it exists.
     */
    where: LibraryEntryWhereUniqueInput
    /**
     * In case the LibraryEntry found by the `where` argument doesn't exist, create a new LibraryEntry with this data.
     */
    create: XOR<LibraryEntryCreateInput, LibraryEntryUncheckedCreateInput>
    /**
     * In case the LibraryEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryEntryUpdateInput, LibraryEntryUncheckedUpdateInput>
  }

  /**
   * LibraryEntry delete
   */
  export type LibraryEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
    /**
     * Filter which LibraryEntry to delete.
     */
    where: LibraryEntryWhereUniqueInput
  }

  /**
   * LibraryEntry deleteMany
   */
  export type LibraryEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryEntries to delete
     */
    where?: LibraryEntryWhereInput
    /**
     * Limit how many LibraryEntries to delete.
     */
    limit?: number
  }

  /**
   * LibraryEntry without action
   */
  export type LibraryEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryEntry
     */
    select?: LibraryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryEntry
     */
    omit?: LibraryEntryOmit<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
    senderId: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isRead: boolean | null
    senderId: number | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isRead: boolean | null
    senderId: number | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    subject: number
    message: number
    createdAt: number
    updatedAt: number
    isRead: number
    senderId: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
    senderId?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
    senderId?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    isRead?: true
    senderId?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    isRead?: true
    senderId?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    isRead?: true
    senderId?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    subject: string
    message: string
    createdAt: Date
    updatedAt: Date
    isRead: boolean
    senderId: number
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRead?: boolean
    senderId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipients?: boolean | Feedback$recipientsArgs<ExtArgs>
    _count?: boolean | FeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRead?: boolean
    senderId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRead?: boolean
    senderId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRead?: boolean
    senderId?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "message" | "createdAt" | "updatedAt" | "isRead" | "senderId", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipients?: boolean | Feedback$recipientsArgs<ExtArgs>
    _count?: boolean | FeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipients: Prisma.$FeedbackRecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subject: string
      message: string
      createdAt: Date
      updatedAt: Date
      isRead: boolean
      senderId: number
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    recipients<T extends Feedback$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly subject: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
    readonly isRead: FieldRef<"Feedback", 'Boolean'>
    readonly senderId: FieldRef<"Feedback", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback.recipients
   */
  export type Feedback$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    where?: FeedbackRecipientWhereInput
    orderBy?: FeedbackRecipientOrderByWithRelationInput | FeedbackRecipientOrderByWithRelationInput[]
    cursor?: FeedbackRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackRecipientScalarFieldEnum | FeedbackRecipientScalarFieldEnum[]
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model FeedbackRecipient
   */

  export type AggregateFeedbackRecipient = {
    _count: FeedbackRecipientCountAggregateOutputType | null
    _avg: FeedbackRecipientAvgAggregateOutputType | null
    _sum: FeedbackRecipientSumAggregateOutputType | null
    _min: FeedbackRecipientMinAggregateOutputType | null
    _max: FeedbackRecipientMaxAggregateOutputType | null
  }

  export type FeedbackRecipientAvgAggregateOutputType = {
    id: number | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackRecipientSumAggregateOutputType = {
    id: number | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackRecipientMinAggregateOutputType = {
    id: number | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackRecipientMaxAggregateOutputType = {
    id: number | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackRecipientCountAggregateOutputType = {
    id: number
    feedbackId: number
    userId: number
    _all: number
  }


  export type FeedbackRecipientAvgAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackRecipientSumAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackRecipientMinAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackRecipientMaxAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackRecipientCountAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
    _all?: true
  }

  export type FeedbackRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackRecipient to aggregate.
     */
    where?: FeedbackRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRecipients to fetch.
     */
    orderBy?: FeedbackRecipientOrderByWithRelationInput | FeedbackRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackRecipients
    **/
    _count?: true | FeedbackRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackRecipientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackRecipientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackRecipientMaxAggregateInputType
  }

  export type GetFeedbackRecipientAggregateType<T extends FeedbackRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackRecipient[P]>
      : GetScalarType<T[P], AggregateFeedbackRecipient[P]>
  }




  export type FeedbackRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackRecipientWhereInput
    orderBy?: FeedbackRecipientOrderByWithAggregationInput | FeedbackRecipientOrderByWithAggregationInput[]
    by: FeedbackRecipientScalarFieldEnum[] | FeedbackRecipientScalarFieldEnum
    having?: FeedbackRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackRecipientCountAggregateInputType | true
    _avg?: FeedbackRecipientAvgAggregateInputType
    _sum?: FeedbackRecipientSumAggregateInputType
    _min?: FeedbackRecipientMinAggregateInputType
    _max?: FeedbackRecipientMaxAggregateInputType
  }

  export type FeedbackRecipientGroupByOutputType = {
    id: number
    feedbackId: number
    userId: number
    _count: FeedbackRecipientCountAggregateOutputType | null
    _avg: FeedbackRecipientAvgAggregateOutputType | null
    _sum: FeedbackRecipientSumAggregateOutputType | null
    _min: FeedbackRecipientMinAggregateOutputType | null
    _max: FeedbackRecipientMaxAggregateOutputType | null
  }

  type GetFeedbackRecipientGroupByPayload<T extends FeedbackRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackRecipientGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedbackId?: boolean
    userId?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackRecipient"]>

  export type FeedbackRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedbackId?: boolean
    userId?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackRecipient"]>

  export type FeedbackRecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedbackId?: boolean
    userId?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackRecipient"]>

  export type FeedbackRecipientSelectScalar = {
    id?: boolean
    feedbackId?: boolean
    userId?: boolean
  }

  export type FeedbackRecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feedbackId" | "userId", ExtArgs["result"]["feedbackRecipient"]>
  export type FeedbackRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackRecipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackRecipient"
    objects: {
      feedback: Prisma.$FeedbackPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      feedbackId: number
      userId: number
    }, ExtArgs["result"]["feedbackRecipient"]>
    composites: {}
  }

  type FeedbackRecipientGetPayload<S extends boolean | null | undefined | FeedbackRecipientDefaultArgs> = $Result.GetResult<Prisma.$FeedbackRecipientPayload, S>

  type FeedbackRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackRecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackRecipientCountAggregateInputType | true
    }

  export interface FeedbackRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackRecipient'], meta: { name: 'FeedbackRecipient' } }
    /**
     * Find zero or one FeedbackRecipient that matches the filter.
     * @param {FeedbackRecipientFindUniqueArgs} args - Arguments to find a FeedbackRecipient
     * @example
     * // Get one FeedbackRecipient
     * const feedbackRecipient = await prisma.feedbackRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackRecipientFindUniqueArgs>(args: SelectSubset<T, FeedbackRecipientFindUniqueArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FeedbackRecipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackRecipientFindUniqueOrThrowArgs} args - Arguments to find a FeedbackRecipient
     * @example
     * // Get one FeedbackRecipient
     * const feedbackRecipient = await prisma.feedbackRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FeedbackRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientFindFirstArgs} args - Arguments to find a FeedbackRecipient
     * @example
     * // Get one FeedbackRecipient
     * const feedbackRecipient = await prisma.feedbackRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackRecipientFindFirstArgs>(args?: SelectSubset<T, FeedbackRecipientFindFirstArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FeedbackRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientFindFirstOrThrowArgs} args - Arguments to find a FeedbackRecipient
     * @example
     * // Get one FeedbackRecipient
     * const feedbackRecipient = await prisma.feedbackRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FeedbackRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackRecipients
     * const feedbackRecipients = await prisma.feedbackRecipient.findMany()
     * 
     * // Get first 10 FeedbackRecipients
     * const feedbackRecipients = await prisma.feedbackRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackRecipientWithIdOnly = await prisma.feedbackRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackRecipientFindManyArgs>(args?: SelectSubset<T, FeedbackRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FeedbackRecipient.
     * @param {FeedbackRecipientCreateArgs} args - Arguments to create a FeedbackRecipient.
     * @example
     * // Create one FeedbackRecipient
     * const FeedbackRecipient = await prisma.feedbackRecipient.create({
     *   data: {
     *     // ... data to create a FeedbackRecipient
     *   }
     * })
     * 
     */
    create<T extends FeedbackRecipientCreateArgs>(args: SelectSubset<T, FeedbackRecipientCreateArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FeedbackRecipients.
     * @param {FeedbackRecipientCreateManyArgs} args - Arguments to create many FeedbackRecipients.
     * @example
     * // Create many FeedbackRecipients
     * const feedbackRecipient = await prisma.feedbackRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackRecipientCreateManyArgs>(args?: SelectSubset<T, FeedbackRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedbackRecipients and returns the data saved in the database.
     * @param {FeedbackRecipientCreateManyAndReturnArgs} args - Arguments to create many FeedbackRecipients.
     * @example
     * // Create many FeedbackRecipients
     * const feedbackRecipient = await prisma.feedbackRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedbackRecipients and only return the `id`
     * const feedbackRecipientWithIdOnly = await prisma.feedbackRecipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a FeedbackRecipient.
     * @param {FeedbackRecipientDeleteArgs} args - Arguments to delete one FeedbackRecipient.
     * @example
     * // Delete one FeedbackRecipient
     * const FeedbackRecipient = await prisma.feedbackRecipient.delete({
     *   where: {
     *     // ... filter to delete one FeedbackRecipient
     *   }
     * })
     * 
     */
    delete<T extends FeedbackRecipientDeleteArgs>(args: SelectSubset<T, FeedbackRecipientDeleteArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FeedbackRecipient.
     * @param {FeedbackRecipientUpdateArgs} args - Arguments to update one FeedbackRecipient.
     * @example
     * // Update one FeedbackRecipient
     * const feedbackRecipient = await prisma.feedbackRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackRecipientUpdateArgs>(args: SelectSubset<T, FeedbackRecipientUpdateArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FeedbackRecipients.
     * @param {FeedbackRecipientDeleteManyArgs} args - Arguments to filter FeedbackRecipients to delete.
     * @example
     * // Delete a few FeedbackRecipients
     * const { count } = await prisma.feedbackRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackRecipientDeleteManyArgs>(args?: SelectSubset<T, FeedbackRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackRecipients
     * const feedbackRecipient = await prisma.feedbackRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackRecipientUpdateManyArgs>(args: SelectSubset<T, FeedbackRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackRecipients and returns the data updated in the database.
     * @param {FeedbackRecipientUpdateManyAndReturnArgs} args - Arguments to update many FeedbackRecipients.
     * @example
     * // Update many FeedbackRecipients
     * const feedbackRecipient = await prisma.feedbackRecipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedbackRecipients and only return the `id`
     * const feedbackRecipientWithIdOnly = await prisma.feedbackRecipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackRecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackRecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one FeedbackRecipient.
     * @param {FeedbackRecipientUpsertArgs} args - Arguments to update or create a FeedbackRecipient.
     * @example
     * // Update or create a FeedbackRecipient
     * const feedbackRecipient = await prisma.feedbackRecipient.upsert({
     *   create: {
     *     // ... data to create a FeedbackRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackRecipient we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackRecipientUpsertArgs>(args: SelectSubset<T, FeedbackRecipientUpsertArgs<ExtArgs>>): Prisma__FeedbackRecipientClient<$Result.GetResult<Prisma.$FeedbackRecipientPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FeedbackRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientCountArgs} args - Arguments to filter FeedbackRecipients to count.
     * @example
     * // Count the number of FeedbackRecipients
     * const count = await prisma.feedbackRecipient.count({
     *   where: {
     *     // ... the filter for the FeedbackRecipients we want to count
     *   }
     * })
    **/
    count<T extends FeedbackRecipientCountArgs>(
      args?: Subset<T, FeedbackRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackRecipientAggregateArgs>(args: Subset<T, FeedbackRecipientAggregateArgs>): Prisma.PrismaPromise<GetFeedbackRecipientAggregateType<T>>

    /**
     * Group by FeedbackRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackRecipientGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackRecipient model
   */
  readonly fields: FeedbackRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedback<T extends FeedbackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedbackDefaultArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedbackRecipient model
   */ 
  interface FeedbackRecipientFieldRefs {
    readonly id: FieldRef<"FeedbackRecipient", 'Int'>
    readonly feedbackId: FieldRef<"FeedbackRecipient", 'Int'>
    readonly userId: FieldRef<"FeedbackRecipient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FeedbackRecipient findUnique
   */
  export type FeedbackRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRecipient to fetch.
     */
    where: FeedbackRecipientWhereUniqueInput
  }

  /**
   * FeedbackRecipient findUniqueOrThrow
   */
  export type FeedbackRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRecipient to fetch.
     */
    where: FeedbackRecipientWhereUniqueInput
  }

  /**
   * FeedbackRecipient findFirst
   */
  export type FeedbackRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRecipient to fetch.
     */
    where?: FeedbackRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRecipients to fetch.
     */
    orderBy?: FeedbackRecipientOrderByWithRelationInput | FeedbackRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackRecipients.
     */
    cursor?: FeedbackRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackRecipients.
     */
    distinct?: FeedbackRecipientScalarFieldEnum | FeedbackRecipientScalarFieldEnum[]
  }

  /**
   * FeedbackRecipient findFirstOrThrow
   */
  export type FeedbackRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRecipient to fetch.
     */
    where?: FeedbackRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRecipients to fetch.
     */
    orderBy?: FeedbackRecipientOrderByWithRelationInput | FeedbackRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackRecipients.
     */
    cursor?: FeedbackRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackRecipients.
     */
    distinct?: FeedbackRecipientScalarFieldEnum | FeedbackRecipientScalarFieldEnum[]
  }

  /**
   * FeedbackRecipient findMany
   */
  export type FeedbackRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRecipients to fetch.
     */
    where?: FeedbackRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRecipients to fetch.
     */
    orderBy?: FeedbackRecipientOrderByWithRelationInput | FeedbackRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackRecipients.
     */
    cursor?: FeedbackRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRecipients.
     */
    skip?: number
    distinct?: FeedbackRecipientScalarFieldEnum | FeedbackRecipientScalarFieldEnum[]
  }

  /**
   * FeedbackRecipient create
   */
  export type FeedbackRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackRecipient.
     */
    data: XOR<FeedbackRecipientCreateInput, FeedbackRecipientUncheckedCreateInput>
  }

  /**
   * FeedbackRecipient createMany
   */
  export type FeedbackRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackRecipients.
     */
    data: FeedbackRecipientCreateManyInput | FeedbackRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedbackRecipient createManyAndReturn
   */
  export type FeedbackRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * The data used to create many FeedbackRecipients.
     */
    data: FeedbackRecipientCreateManyInput | FeedbackRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedbackRecipient update
   */
  export type FeedbackRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackRecipient.
     */
    data: XOR<FeedbackRecipientUpdateInput, FeedbackRecipientUncheckedUpdateInput>
    /**
     * Choose, which FeedbackRecipient to update.
     */
    where: FeedbackRecipientWhereUniqueInput
  }

  /**
   * FeedbackRecipient updateMany
   */
  export type FeedbackRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackRecipients.
     */
    data: XOR<FeedbackRecipientUpdateManyMutationInput, FeedbackRecipientUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackRecipients to update
     */
    where?: FeedbackRecipientWhereInput
    /**
     * Limit how many FeedbackRecipients to update.
     */
    limit?: number
  }

  /**
   * FeedbackRecipient updateManyAndReturn
   */
  export type FeedbackRecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * The data used to update FeedbackRecipients.
     */
    data: XOR<FeedbackRecipientUpdateManyMutationInput, FeedbackRecipientUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackRecipients to update
     */
    where?: FeedbackRecipientWhereInput
    /**
     * Limit how many FeedbackRecipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedbackRecipient upsert
   */
  export type FeedbackRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackRecipient to update in case it exists.
     */
    where: FeedbackRecipientWhereUniqueInput
    /**
     * In case the FeedbackRecipient found by the `where` argument doesn't exist, create a new FeedbackRecipient with this data.
     */
    create: XOR<FeedbackRecipientCreateInput, FeedbackRecipientUncheckedCreateInput>
    /**
     * In case the FeedbackRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackRecipientUpdateInput, FeedbackRecipientUncheckedUpdateInput>
  }

  /**
   * FeedbackRecipient delete
   */
  export type FeedbackRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
    /**
     * Filter which FeedbackRecipient to delete.
     */
    where: FeedbackRecipientWhereUniqueInput
  }

  /**
   * FeedbackRecipient deleteMany
   */
  export type FeedbackRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackRecipients to delete
     */
    where?: FeedbackRecipientWhereInput
    /**
     * Limit how many FeedbackRecipients to delete.
     */
    limit?: number
  }

  /**
   * FeedbackRecipient without action
   */
  export type FeedbackRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRecipient
     */
    select?: FeedbackRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRecipient
     */
    omit?: FeedbackRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRecipientInclude<ExtArgs> | null
  }


  /**
   * Model PagePermission
   */

  export type AggregatePagePermission = {
    _count: PagePermissionCountAggregateOutputType | null
    _avg: PagePermissionAvgAggregateOutputType | null
    _sum: PagePermissionSumAggregateOutputType | null
    _min: PagePermissionMinAggregateOutputType | null
    _max: PagePermissionMaxAggregateOutputType | null
  }

  export type PagePermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PagePermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PagePermissionMinAggregateOutputType = {
    id: number | null
    route: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PagePermissionMaxAggregateOutputType = {
    id: number | null
    route: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PagePermissionCountAggregateOutputType = {
    id: number
    route: number
    description: number
    createdAt: number
    _all: number
  }


  export type PagePermissionAvgAggregateInputType = {
    id?: true
  }

  export type PagePermissionSumAggregateInputType = {
    id?: true
  }

  export type PagePermissionMinAggregateInputType = {
    id?: true
    route?: true
    description?: true
    createdAt?: true
  }

  export type PagePermissionMaxAggregateInputType = {
    id?: true
    route?: true
    description?: true
    createdAt?: true
  }

  export type PagePermissionCountAggregateInputType = {
    id?: true
    route?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PagePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagePermission to aggregate.
     */
    where?: PagePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagePermissions to fetch.
     */
    orderBy?: PagePermissionOrderByWithRelationInput | PagePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PagePermissions
    **/
    _count?: true | PagePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagePermissionMaxAggregateInputType
  }

  export type GetPagePermissionAggregateType<T extends PagePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePagePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagePermission[P]>
      : GetScalarType<T[P], AggregatePagePermission[P]>
  }




  export type PagePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagePermissionWhereInput
    orderBy?: PagePermissionOrderByWithAggregationInput | PagePermissionOrderByWithAggregationInput[]
    by: PagePermissionScalarFieldEnum[] | PagePermissionScalarFieldEnum
    having?: PagePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagePermissionCountAggregateInputType | true
    _avg?: PagePermissionAvgAggregateInputType
    _sum?: PagePermissionSumAggregateInputType
    _min?: PagePermissionMinAggregateInputType
    _max?: PagePermissionMaxAggregateInputType
  }

  export type PagePermissionGroupByOutputType = {
    id: number
    route: string
    description: string | null
    createdAt: Date
    _count: PagePermissionCountAggregateOutputType | null
    _avg: PagePermissionAvgAggregateOutputType | null
    _sum: PagePermissionSumAggregateOutputType | null
    _min: PagePermissionMinAggregateOutputType | null
    _max: PagePermissionMaxAggregateOutputType | null
  }

  type GetPagePermissionGroupByPayload<T extends PagePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PagePermissionGroupByOutputType[P]>
        }
      >
    >


  export type PagePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route?: boolean
    description?: boolean
    createdAt?: boolean
    allowedRoles?: boolean | PagePermission$allowedRolesArgs<ExtArgs>
    allowedUsers?: boolean | PagePermission$allowedUsersArgs<ExtArgs>
    _count?: boolean | PagePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagePermission"]>

  export type PagePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pagePermission"]>

  export type PagePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pagePermission"]>

  export type PagePermissionSelectScalar = {
    id?: boolean
    route?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PagePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "route" | "description" | "createdAt", ExtArgs["result"]["pagePermission"]>
  export type PagePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allowedRoles?: boolean | PagePermission$allowedRolesArgs<ExtArgs>
    allowedUsers?: boolean | PagePermission$allowedUsersArgs<ExtArgs>
    _count?: boolean | PagePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PagePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PagePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PagePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PagePermission"
    objects: {
      allowedRoles: Prisma.$RolePermissionPayload<ExtArgs>[]
      allowedUsers: Prisma.$UserPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      route: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["pagePermission"]>
    composites: {}
  }

  type PagePermissionGetPayload<S extends boolean | null | undefined | PagePermissionDefaultArgs> = $Result.GetResult<Prisma.$PagePermissionPayload, S>

  type PagePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagePermissionCountAggregateInputType | true
    }

  export interface PagePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PagePermission'], meta: { name: 'PagePermission' } }
    /**
     * Find zero or one PagePermission that matches the filter.
     * @param {PagePermissionFindUniqueArgs} args - Arguments to find a PagePermission
     * @example
     * // Get one PagePermission
     * const pagePermission = await prisma.pagePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagePermissionFindUniqueArgs>(args: SelectSubset<T, PagePermissionFindUniqueArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PagePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagePermissionFindUniqueOrThrowArgs} args - Arguments to find a PagePermission
     * @example
     * // Get one PagePermission
     * const pagePermission = await prisma.pagePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PagePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PagePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionFindFirstArgs} args - Arguments to find a PagePermission
     * @example
     * // Get one PagePermission
     * const pagePermission = await prisma.pagePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagePermissionFindFirstArgs>(args?: SelectSubset<T, PagePermissionFindFirstArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PagePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionFindFirstOrThrowArgs} args - Arguments to find a PagePermission
     * @example
     * // Get one PagePermission
     * const pagePermission = await prisma.pagePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PagePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PagePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PagePermissions
     * const pagePermissions = await prisma.pagePermission.findMany()
     * 
     * // Get first 10 PagePermissions
     * const pagePermissions = await prisma.pagePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagePermissionWithIdOnly = await prisma.pagePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagePermissionFindManyArgs>(args?: SelectSubset<T, PagePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PagePermission.
     * @param {PagePermissionCreateArgs} args - Arguments to create a PagePermission.
     * @example
     * // Create one PagePermission
     * const PagePermission = await prisma.pagePermission.create({
     *   data: {
     *     // ... data to create a PagePermission
     *   }
     * })
     * 
     */
    create<T extends PagePermissionCreateArgs>(args: SelectSubset<T, PagePermissionCreateArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PagePermissions.
     * @param {PagePermissionCreateManyArgs} args - Arguments to create many PagePermissions.
     * @example
     * // Create many PagePermissions
     * const pagePermission = await prisma.pagePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagePermissionCreateManyArgs>(args?: SelectSubset<T, PagePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PagePermissions and returns the data saved in the database.
     * @param {PagePermissionCreateManyAndReturnArgs} args - Arguments to create many PagePermissions.
     * @example
     * // Create many PagePermissions
     * const pagePermission = await prisma.pagePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PagePermissions and only return the `id`
     * const pagePermissionWithIdOnly = await prisma.pagePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PagePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PagePermission.
     * @param {PagePermissionDeleteArgs} args - Arguments to delete one PagePermission.
     * @example
     * // Delete one PagePermission
     * const PagePermission = await prisma.pagePermission.delete({
     *   where: {
     *     // ... filter to delete one PagePermission
     *   }
     * })
     * 
     */
    delete<T extends PagePermissionDeleteArgs>(args: SelectSubset<T, PagePermissionDeleteArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PagePermission.
     * @param {PagePermissionUpdateArgs} args - Arguments to update one PagePermission.
     * @example
     * // Update one PagePermission
     * const pagePermission = await prisma.pagePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagePermissionUpdateArgs>(args: SelectSubset<T, PagePermissionUpdateArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PagePermissions.
     * @param {PagePermissionDeleteManyArgs} args - Arguments to filter PagePermissions to delete.
     * @example
     * // Delete a few PagePermissions
     * const { count } = await prisma.pagePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagePermissionDeleteManyArgs>(args?: SelectSubset<T, PagePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PagePermissions
     * const pagePermission = await prisma.pagePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagePermissionUpdateManyArgs>(args: SelectSubset<T, PagePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagePermissions and returns the data updated in the database.
     * @param {PagePermissionUpdateManyAndReturnArgs} args - Arguments to update many PagePermissions.
     * @example
     * // Update many PagePermissions
     * const pagePermission = await prisma.pagePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PagePermissions and only return the `id`
     * const pagePermissionWithIdOnly = await prisma.pagePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PagePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PagePermission.
     * @param {PagePermissionUpsertArgs} args - Arguments to update or create a PagePermission.
     * @example
     * // Update or create a PagePermission
     * const pagePermission = await prisma.pagePermission.upsert({
     *   create: {
     *     // ... data to create a PagePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PagePermission we want to update
     *   }
     * })
     */
    upsert<T extends PagePermissionUpsertArgs>(args: SelectSubset<T, PagePermissionUpsertArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PagePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionCountArgs} args - Arguments to filter PagePermissions to count.
     * @example
     * // Count the number of PagePermissions
     * const count = await prisma.pagePermission.count({
     *   where: {
     *     // ... the filter for the PagePermissions we want to count
     *   }
     * })
    **/
    count<T extends PagePermissionCountArgs>(
      args?: Subset<T, PagePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PagePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagePermissionAggregateArgs>(args: Subset<T, PagePermissionAggregateArgs>): Prisma.PrismaPromise<GetPagePermissionAggregateType<T>>

    /**
     * Group by PagePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagePermissionGroupByArgs['orderBy'] }
        : { orderBy?: PagePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PagePermission model
   */
  readonly fields: PagePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PagePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    allowedRoles<T extends PagePermission$allowedRolesArgs<ExtArgs> = {}>(args?: Subset<T, PagePermission$allowedRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    allowedUsers<T extends PagePermission$allowedUsersArgs<ExtArgs> = {}>(args?: Subset<T, PagePermission$allowedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PagePermission model
   */ 
  interface PagePermissionFieldRefs {
    readonly id: FieldRef<"PagePermission", 'Int'>
    readonly route: FieldRef<"PagePermission", 'String'>
    readonly description: FieldRef<"PagePermission", 'String'>
    readonly createdAt: FieldRef<"PagePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PagePermission findUnique
   */
  export type PagePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * Filter, which PagePermission to fetch.
     */
    where: PagePermissionWhereUniqueInput
  }

  /**
   * PagePermission findUniqueOrThrow
   */
  export type PagePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * Filter, which PagePermission to fetch.
     */
    where: PagePermissionWhereUniqueInput
  }

  /**
   * PagePermission findFirst
   */
  export type PagePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * Filter, which PagePermission to fetch.
     */
    where?: PagePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagePermissions to fetch.
     */
    orderBy?: PagePermissionOrderByWithRelationInput | PagePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagePermissions.
     */
    cursor?: PagePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagePermissions.
     */
    distinct?: PagePermissionScalarFieldEnum | PagePermissionScalarFieldEnum[]
  }

  /**
   * PagePermission findFirstOrThrow
   */
  export type PagePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * Filter, which PagePermission to fetch.
     */
    where?: PagePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagePermissions to fetch.
     */
    orderBy?: PagePermissionOrderByWithRelationInput | PagePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagePermissions.
     */
    cursor?: PagePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagePermissions.
     */
    distinct?: PagePermissionScalarFieldEnum | PagePermissionScalarFieldEnum[]
  }

  /**
   * PagePermission findMany
   */
  export type PagePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * Filter, which PagePermissions to fetch.
     */
    where?: PagePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagePermissions to fetch.
     */
    orderBy?: PagePermissionOrderByWithRelationInput | PagePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PagePermissions.
     */
    cursor?: PagePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagePermissions.
     */
    skip?: number
    distinct?: PagePermissionScalarFieldEnum | PagePermissionScalarFieldEnum[]
  }

  /**
   * PagePermission create
   */
  export type PagePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a PagePermission.
     */
    data: XOR<PagePermissionCreateInput, PagePermissionUncheckedCreateInput>
  }

  /**
   * PagePermission createMany
   */
  export type PagePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PagePermissions.
     */
    data: PagePermissionCreateManyInput | PagePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PagePermission createManyAndReturn
   */
  export type PagePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many PagePermissions.
     */
    data: PagePermissionCreateManyInput | PagePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PagePermission update
   */
  export type PagePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a PagePermission.
     */
    data: XOR<PagePermissionUpdateInput, PagePermissionUncheckedUpdateInput>
    /**
     * Choose, which PagePermission to update.
     */
    where: PagePermissionWhereUniqueInput
  }

  /**
   * PagePermission updateMany
   */
  export type PagePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PagePermissions.
     */
    data: XOR<PagePermissionUpdateManyMutationInput, PagePermissionUncheckedUpdateManyInput>
    /**
     * Filter which PagePermissions to update
     */
    where?: PagePermissionWhereInput
    /**
     * Limit how many PagePermissions to update.
     */
    limit?: number
  }

  /**
   * PagePermission updateManyAndReturn
   */
  export type PagePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * The data used to update PagePermissions.
     */
    data: XOR<PagePermissionUpdateManyMutationInput, PagePermissionUncheckedUpdateManyInput>
    /**
     * Filter which PagePermissions to update
     */
    where?: PagePermissionWhereInput
    /**
     * Limit how many PagePermissions to update.
     */
    limit?: number
  }

  /**
   * PagePermission upsert
   */
  export type PagePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the PagePermission to update in case it exists.
     */
    where: PagePermissionWhereUniqueInput
    /**
     * In case the PagePermission found by the `where` argument doesn't exist, create a new PagePermission with this data.
     */
    create: XOR<PagePermissionCreateInput, PagePermissionUncheckedCreateInput>
    /**
     * In case the PagePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagePermissionUpdateInput, PagePermissionUncheckedUpdateInput>
  }

  /**
   * PagePermission delete
   */
  export type PagePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
    /**
     * Filter which PagePermission to delete.
     */
    where: PagePermissionWhereUniqueInput
  }

  /**
   * PagePermission deleteMany
   */
  export type PagePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagePermissions to delete
     */
    where?: PagePermissionWhereInput
    /**
     * Limit how many PagePermissions to delete.
     */
    limit?: number
  }

  /**
   * PagePermission.allowedRoles
   */
  export type PagePermission$allowedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * PagePermission.allowedUsers
   */
  export type PagePermission$allowedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    cursor?: UserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * PagePermission without action
   */
  export type PagePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagePermission
     */
    select?: PagePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagePermission
     */
    omit?: PagePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagePermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    pagePermissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    pagePermissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleName: string | null
    pagePermissionId: number | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleName: string | null
    pagePermissionId: number | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleName: number
    pagePermissionId: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    pagePermissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    pagePermissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleName?: true
    pagePermissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleName?: true
    pagePermissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleName?: true
    pagePermissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleName: string
    pagePermissionId: number
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    pagePermissionId?: boolean
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    pagePermissionId?: boolean
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    pagePermissionId?: boolean
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleName?: boolean
    pagePermissionId?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleName" | "pagePermissionId", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      pagePermission: Prisma.$PagePermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleName: string
      pagePermissionId: number
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pagePermission<T extends PagePermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PagePermissionDefaultArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleName: FieldRef<"RolePermission", 'String'>
    readonly pagePermissionId: FieldRef<"RolePermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserPermission
   */

  export type AggregateUserPermission = {
    _count: UserPermissionCountAggregateOutputType | null
    _avg: UserPermissionAvgAggregateOutputType | null
    _sum: UserPermissionSumAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  export type UserPermissionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    pagePermissionId: number | null
  }

  export type UserPermissionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    pagePermissionId: number | null
  }

  export type UserPermissionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    pagePermissionId: number | null
  }

  export type UserPermissionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    pagePermissionId: number | null
  }

  export type UserPermissionCountAggregateOutputType = {
    id: number
    userId: number
    pagePermissionId: number
    _all: number
  }


  export type UserPermissionAvgAggregateInputType = {
    id?: true
    userId?: true
    pagePermissionId?: true
  }

  export type UserPermissionSumAggregateInputType = {
    id?: true
    userId?: true
    pagePermissionId?: true
  }

  export type UserPermissionMinAggregateInputType = {
    id?: true
    userId?: true
    pagePermissionId?: true
  }

  export type UserPermissionMaxAggregateInputType = {
    id?: true
    userId?: true
    pagePermissionId?: true
  }

  export type UserPermissionCountAggregateInputType = {
    id?: true
    userId?: true
    pagePermissionId?: true
    _all?: true
  }

  export type UserPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermission to aggregate.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPermissions
    **/
    _count?: true | UserPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPermissionMaxAggregateInputType
  }

  export type GetUserPermissionAggregateType<T extends UserPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPermission[P]>
      : GetScalarType<T[P], AggregateUserPermission[P]>
  }




  export type UserPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithAggregationInput | UserPermissionOrderByWithAggregationInput[]
    by: UserPermissionScalarFieldEnum[] | UserPermissionScalarFieldEnum
    having?: UserPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPermissionCountAggregateInputType | true
    _avg?: UserPermissionAvgAggregateInputType
    _sum?: UserPermissionSumAggregateInputType
    _min?: UserPermissionMinAggregateInputType
    _max?: UserPermissionMaxAggregateInputType
  }

  export type UserPermissionGroupByOutputType = {
    id: number
    userId: number
    pagePermissionId: number
    _count: UserPermissionCountAggregateOutputType | null
    _avg: UserPermissionAvgAggregateOutputType | null
    _sum: UserPermissionSumAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  type GetUserPermissionGroupByPayload<T extends UserPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
        }
      >
    >


  export type UserPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pagePermissionId?: boolean
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pagePermissionId?: boolean
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pagePermissionId?: boolean
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectScalar = {
    id?: boolean
    userId?: boolean
    pagePermissionId?: boolean
  }

  export type UserPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "pagePermissionId", ExtArgs["result"]["userPermission"]>
  export type UserPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagePermission?: boolean | PagePermissionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPermission"
    objects: {
      pagePermission: Prisma.$PagePermissionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      pagePermissionId: number
    }, ExtArgs["result"]["userPermission"]>
    composites: {}
  }

  type UserPermissionGetPayload<S extends boolean | null | undefined | UserPermissionDefaultArgs> = $Result.GetResult<Prisma.$UserPermissionPayload, S>

  type UserPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPermissionCountAggregateInputType | true
    }

  export interface UserPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPermission'], meta: { name: 'UserPermission' } }
    /**
     * Find zero or one UserPermission that matches the filter.
     * @param {UserPermissionFindUniqueArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPermissionFindUniqueArgs>(args: SelectSubset<T, UserPermissionFindUniqueArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPermissionFindUniqueOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindFirstArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPermissionFindFirstArgs>(args?: SelectSubset<T, UserPermissionFindFirstArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindFirstOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPermissions
     * const userPermissions = await prisma.userPermission.findMany()
     * 
     * // Get first 10 UserPermissions
     * const userPermissions = await prisma.userPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPermissionFindManyArgs>(args?: SelectSubset<T, UserPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserPermission.
     * @param {UserPermissionCreateArgs} args - Arguments to create a UserPermission.
     * @example
     * // Create one UserPermission
     * const UserPermission = await prisma.userPermission.create({
     *   data: {
     *     // ... data to create a UserPermission
     *   }
     * })
     * 
     */
    create<T extends UserPermissionCreateArgs>(args: SelectSubset<T, UserPermissionCreateArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserPermissions.
     * @param {UserPermissionCreateManyArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermission = await prisma.userPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPermissionCreateManyArgs>(args?: SelectSubset<T, UserPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPermissions and returns the data saved in the database.
     * @param {UserPermissionCreateManyAndReturnArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermission = await prisma.userPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPermissions and only return the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserPermission.
     * @param {UserPermissionDeleteArgs} args - Arguments to delete one UserPermission.
     * @example
     * // Delete one UserPermission
     * const UserPermission = await prisma.userPermission.delete({
     *   where: {
     *     // ... filter to delete one UserPermission
     *   }
     * })
     * 
     */
    delete<T extends UserPermissionDeleteArgs>(args: SelectSubset<T, UserPermissionDeleteArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserPermission.
     * @param {UserPermissionUpdateArgs} args - Arguments to update one UserPermission.
     * @example
     * // Update one UserPermission
     * const userPermission = await prisma.userPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPermissionUpdateArgs>(args: SelectSubset<T, UserPermissionUpdateArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserPermissions.
     * @param {UserPermissionDeleteManyArgs} args - Arguments to filter UserPermissions to delete.
     * @example
     * // Delete a few UserPermissions
     * const { count } = await prisma.userPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPermissionDeleteManyArgs>(args?: SelectSubset<T, UserPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPermissionUpdateManyArgs>(args: SelectSubset<T, UserPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions and returns the data updated in the database.
     * @param {UserPermissionUpdateManyAndReturnArgs} args - Arguments to update many UserPermissions.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPermissions and only return the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserPermission.
     * @param {UserPermissionUpsertArgs} args - Arguments to update or create a UserPermission.
     * @example
     * // Update or create a UserPermission
     * const userPermission = await prisma.userPermission.upsert({
     *   create: {
     *     // ... data to create a UserPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPermission we want to update
     *   }
     * })
     */
    upsert<T extends UserPermissionUpsertArgs>(args: SelectSubset<T, UserPermissionUpsertArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionCountArgs} args - Arguments to filter UserPermissions to count.
     * @example
     * // Count the number of UserPermissions
     * const count = await prisma.userPermission.count({
     *   where: {
     *     // ... the filter for the UserPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserPermissionCountArgs>(
      args?: Subset<T, UserPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPermissionAggregateArgs>(args: Subset<T, UserPermissionAggregateArgs>): Prisma.PrismaPromise<GetUserPermissionAggregateType<T>>

    /**
     * Group by UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPermissionGroupByArgs['orderBy'] }
        : { orderBy?: UserPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPermission model
   */
  readonly fields: UserPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pagePermission<T extends PagePermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PagePermissionDefaultArgs<ExtArgs>>): Prisma__PagePermissionClient<$Result.GetResult<Prisma.$PagePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPermission model
   */ 
  interface UserPermissionFieldRefs {
    readonly id: FieldRef<"UserPermission", 'Int'>
    readonly userId: FieldRef<"UserPermission", 'Int'>
    readonly pagePermissionId: FieldRef<"UserPermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserPermission findUnique
   */
  export type UserPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission findUniqueOrThrow
   */
  export type UserPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission findFirst
   */
  export type UserPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission findFirstOrThrow
   */
  export type UserPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission findMany
   */
  export type UserPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission create
   */
  export type UserPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPermission.
     */
    data: XOR<UserPermissionCreateInput, UserPermissionUncheckedCreateInput>
  }

  /**
   * UserPermission createMany
   */
  export type UserPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionCreateManyInput | UserPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPermission createManyAndReturn
   */
  export type UserPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionCreateManyInput | UserPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPermission update
   */
  export type UserPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPermission.
     */
    data: XOR<UserPermissionUpdateInput, UserPermissionUncheckedUpdateInput>
    /**
     * Choose, which UserPermission to update.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission updateMany
   */
  export type UserPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
  }

  /**
   * UserPermission updateManyAndReturn
   */
  export type UserPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPermission upsert
   */
  export type UserPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPermission to update in case it exists.
     */
    where: UserPermissionWhereUniqueInput
    /**
     * In case the UserPermission found by the `where` argument doesn't exist, create a new UserPermission with this data.
     */
    create: XOR<UserPermissionCreateInput, UserPermissionUncheckedCreateInput>
    /**
     * In case the UserPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPermissionUpdateInput, UserPermissionUncheckedUpdateInput>
  }

  /**
   * UserPermission delete
   */
  export type UserPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter which UserPermission to delete.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission deleteMany
   */
  export type UserPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermissions to delete
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to delete.
     */
    limit?: number
  }

  /**
   * UserPermission without action
   */
  export type UserPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
  }


  /**
   * Model pages
   */

  export type AggregatePages = {
    _count: PagesCountAggregateOutputType | null
    _avg: PagesAvgAggregateOutputType | null
    _sum: PagesSumAggregateOutputType | null
    _min: PagesMinAggregateOutputType | null
    _max: PagesMaxAggregateOutputType | null
  }

  export type PagesAvgAggregateOutputType = {
    id: number | null
  }

  export type PagesSumAggregateOutputType = {
    id: number | null
  }

  export type PagesMinAggregateOutputType = {
    id: number | null
    notes: string | null
  }

  export type PagesMaxAggregateOutputType = {
    id: number | null
    notes: string | null
  }

  export type PagesCountAggregateOutputType = {
    id: number
    notes: number
    _all: number
  }


  export type PagesAvgAggregateInputType = {
    id?: true
  }

  export type PagesSumAggregateInputType = {
    id?: true
  }

  export type PagesMinAggregateInputType = {
    id?: true
    notes?: true
  }

  export type PagesMaxAggregateInputType = {
    id?: true
    notes?: true
  }

  export type PagesCountAggregateInputType = {
    id?: true
    notes?: true
    _all?: true
  }

  export type PagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pages to aggregate.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pages
    **/
    _count?: true | PagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagesMaxAggregateInputType
  }

  export type GetPagesAggregateType<T extends PagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePages[P]>
      : GetScalarType<T[P], AggregatePages[P]>
  }




  export type pagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagesWhereInput
    orderBy?: pagesOrderByWithAggregationInput | pagesOrderByWithAggregationInput[]
    by: PagesScalarFieldEnum[] | PagesScalarFieldEnum
    having?: pagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagesCountAggregateInputType | true
    _avg?: PagesAvgAggregateInputType
    _sum?: PagesSumAggregateInputType
    _min?: PagesMinAggregateInputType
    _max?: PagesMaxAggregateInputType
  }

  export type PagesGroupByOutputType = {
    id: number
    notes: string | null
    _count: PagesCountAggregateOutputType | null
    _avg: PagesAvgAggregateOutputType | null
    _sum: PagesSumAggregateOutputType | null
    _min: PagesMinAggregateOutputType | null
    _max: PagesMaxAggregateOutputType | null
  }

  type GetPagesGroupByPayload<T extends pagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagesGroupByOutputType[P]>
            : GetScalarType<T[P], PagesGroupByOutputType[P]>
        }
      >
    >


  export type pagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notes?: boolean
  }, ExtArgs["result"]["pages"]>

  export type pagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notes?: boolean
  }, ExtArgs["result"]["pages"]>

  export type pagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notes?: boolean
  }, ExtArgs["result"]["pages"]>

  export type pagesSelectScalar = {
    id?: boolean
    notes?: boolean
  }

  export type pagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notes", ExtArgs["result"]["pages"]>

  export type $pagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notes: string | null
    }, ExtArgs["result"]["pages"]>
    composites: {}
  }

  type pagesGetPayload<S extends boolean | null | undefined | pagesDefaultArgs> = $Result.GetResult<Prisma.$pagesPayload, S>

  type pagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagesCountAggregateInputType | true
    }

  export interface pagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pages'], meta: { name: 'pages' } }
    /**
     * Find zero or one Pages that matches the filter.
     * @param {pagesFindUniqueArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pagesFindUniqueArgs>(args: SelectSubset<T, pagesFindUniqueArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pagesFindUniqueOrThrowArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pagesFindUniqueOrThrowArgs>(args: SelectSubset<T, pagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesFindFirstArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pagesFindFirstArgs>(args?: SelectSubset<T, pagesFindFirstArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesFindFirstOrThrowArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pagesFindFirstOrThrowArgs>(args?: SelectSubset<T, pagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.pages.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.pages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagesWithIdOnly = await prisma.pages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pagesFindManyArgs>(args?: SelectSubset<T, pagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pages.
     * @param {pagesCreateArgs} args - Arguments to create a Pages.
     * @example
     * // Create one Pages
     * const Pages = await prisma.pages.create({
     *   data: {
     *     // ... data to create a Pages
     *   }
     * })
     * 
     */
    create<T extends pagesCreateArgs>(args: SelectSubset<T, pagesCreateArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pages.
     * @param {pagesCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const pages = await prisma.pages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pagesCreateManyArgs>(args?: SelectSubset<T, pagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {pagesCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const pages = await prisma.pages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pagesWithIdOnly = await prisma.pages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pagesCreateManyAndReturnArgs>(args?: SelectSubset<T, pagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pages.
     * @param {pagesDeleteArgs} args - Arguments to delete one Pages.
     * @example
     * // Delete one Pages
     * const Pages = await prisma.pages.delete({
     *   where: {
     *     // ... filter to delete one Pages
     *   }
     * })
     * 
     */
    delete<T extends pagesDeleteArgs>(args: SelectSubset<T, pagesDeleteArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pages.
     * @param {pagesUpdateArgs} args - Arguments to update one Pages.
     * @example
     * // Update one Pages
     * const pages = await prisma.pages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pagesUpdateArgs>(args: SelectSubset<T, pagesUpdateArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pages.
     * @param {pagesDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.pages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pagesDeleteManyArgs>(args?: SelectSubset<T, pagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const pages = await prisma.pages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pagesUpdateManyArgs>(args: SelectSubset<T, pagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {pagesUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const pages = await prisma.pages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pagesWithIdOnly = await prisma.pages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pagesUpdateManyAndReturnArgs>(args: SelectSubset<T, pagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pages.
     * @param {pagesUpsertArgs} args - Arguments to update or create a Pages.
     * @example
     * // Update or create a Pages
     * const pages = await prisma.pages.upsert({
     *   create: {
     *     // ... data to create a Pages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pages we want to update
     *   }
     * })
     */
    upsert<T extends pagesUpsertArgs>(args: SelectSubset<T, pagesUpsertArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.pages.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends pagesCountArgs>(
      args?: Subset<T, pagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagesAggregateArgs>(args: Subset<T, PagesAggregateArgs>): Prisma.PrismaPromise<GetPagesAggregateType<T>>

    /**
     * Group by Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagesGroupByArgs['orderBy'] }
        : { orderBy?: pagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pages model
   */
  readonly fields: pagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pages model
   */ 
  interface pagesFieldRefs {
    readonly id: FieldRef<"pages", 'Int'>
    readonly notes: FieldRef<"pages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pages findUnique
   */
  export type pagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages findUniqueOrThrow
   */
  export type pagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages findFirst
   */
  export type pagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pages.
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pages.
     */
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * pages findFirstOrThrow
   */
  export type pagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pages.
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pages.
     */
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * pages findMany
   */
  export type pagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pages.
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * pages create
   */
  export type pagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * The data needed to create a pages.
     */
    data?: XOR<pagesCreateInput, pagesUncheckedCreateInput>
  }

  /**
   * pages createMany
   */
  export type pagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pages.
     */
    data: pagesCreateManyInput | pagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pages createManyAndReturn
   */
  export type pagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * The data used to create many pages.
     */
    data: pagesCreateManyInput | pagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pages update
   */
  export type pagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * The data needed to update a pages.
     */
    data: XOR<pagesUpdateInput, pagesUncheckedUpdateInput>
    /**
     * Choose, which pages to update.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages updateMany
   */
  export type pagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pages.
     */
    data: XOR<pagesUpdateManyMutationInput, pagesUncheckedUpdateManyInput>
    /**
     * Filter which pages to update
     */
    where?: pagesWhereInput
    /**
     * Limit how many pages to update.
     */
    limit?: number
  }

  /**
   * pages updateManyAndReturn
   */
  export type pagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * The data used to update pages.
     */
    data: XOR<pagesUpdateManyMutationInput, pagesUncheckedUpdateManyInput>
    /**
     * Filter which pages to update
     */
    where?: pagesWhereInput
    /**
     * Limit how many pages to update.
     */
    limit?: number
  }

  /**
   * pages upsert
   */
  export type pagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * The filter to search for the pages to update in case it exists.
     */
    where: pagesWhereUniqueInput
    /**
     * In case the pages found by the `where` argument doesn't exist, create a new pages with this data.
     */
    create: XOR<pagesCreateInput, pagesUncheckedCreateInput>
    /**
     * In case the pages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagesUpdateInput, pagesUncheckedUpdateInput>
  }

  /**
   * pages delete
   */
  export type pagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
    /**
     * Filter which pages to delete.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages deleteMany
   */
  export type pagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pages to delete
     */
    where?: pagesWhereInput
    /**
     * Limit how many pages to delete.
     */
    limit?: number
  }

  /**
   * pages without action
   */
  export type pagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pages
     */
    omit?: pagesOmit<ExtArgs> | null
  }


  /**
   * Model ProjectType
   */

  export type AggregateProjectType = {
    _count: ProjectTypeCountAggregateOutputType | null
    _avg: ProjectTypeAvgAggregateOutputType | null
    _sum: ProjectTypeSumAggregateOutputType | null
    _min: ProjectTypeMinAggregateOutputType | null
    _max: ProjectTypeMaxAggregateOutputType | null
  }

  export type ProjectTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ProjectTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ProjectTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type ProjectTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type ProjectTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type ProjectTypeAvgAggregateInputType = {
    id?: true
  }

  export type ProjectTypeSumAggregateInputType = {
    id?: true
  }

  export type ProjectTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ProjectTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ProjectTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ProjectTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectType to aggregate.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTypes
    **/
    _count?: true | ProjectTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTypeMaxAggregateInputType
  }

  export type GetProjectTypeAggregateType<T extends ProjectTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectType[P]>
      : GetScalarType<T[P], AggregateProjectType[P]>
  }




  export type ProjectTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTypeWhereInput
    orderBy?: ProjectTypeOrderByWithAggregationInput | ProjectTypeOrderByWithAggregationInput[]
    by: ProjectTypeScalarFieldEnum[] | ProjectTypeScalarFieldEnum
    having?: ProjectTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTypeCountAggregateInputType | true
    _avg?: ProjectTypeAvgAggregateInputType
    _sum?: ProjectTypeSumAggregateInputType
    _min?: ProjectTypeMinAggregateInputType
    _max?: ProjectTypeMaxAggregateInputType
  }

  export type ProjectTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: ProjectTypeCountAggregateOutputType | null
    _avg: ProjectTypeAvgAggregateOutputType | null
    _sum: ProjectTypeSumAggregateOutputType | null
    _min: ProjectTypeMinAggregateOutputType | null
    _max: ProjectTypeMaxAggregateOutputType | null
  }

  type GetProjectTypeGroupByPayload<T extends ProjectTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    projects?: boolean | ProjectType$projectsArgs<ExtArgs>
    _count?: boolean | ProjectTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectType"]>

  export type ProjectTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["projectType"]>

  export type ProjectTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["projectType"]>

  export type ProjectTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type ProjectTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["projectType"]>
  export type ProjectTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectType$projectsArgs<ExtArgs>
    _count?: boolean | ProjectTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProjectTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectType"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["projectType"]>
    composites: {}
  }

  type ProjectTypeGetPayload<S extends boolean | null | undefined | ProjectTypeDefaultArgs> = $Result.GetResult<Prisma.$ProjectTypePayload, S>

  type ProjectTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTypeCountAggregateInputType | true
    }

  export interface ProjectTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectType'], meta: { name: 'ProjectType' } }
    /**
     * Find zero or one ProjectType that matches the filter.
     * @param {ProjectTypeFindUniqueArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTypeFindUniqueArgs>(args: SelectSubset<T, ProjectTypeFindUniqueArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ProjectType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTypeFindUniqueOrThrowArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindFirstArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTypeFindFirstArgs>(args?: SelectSubset<T, ProjectTypeFindFirstArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindFirstOrThrowArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ProjectTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTypes
     * const projectTypes = await prisma.projectType.findMany()
     * 
     * // Get first 10 ProjectTypes
     * const projectTypes = await prisma.projectType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTypeFindManyArgs>(args?: SelectSubset<T, ProjectTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ProjectType.
     * @param {ProjectTypeCreateArgs} args - Arguments to create a ProjectType.
     * @example
     * // Create one ProjectType
     * const ProjectType = await prisma.projectType.create({
     *   data: {
     *     // ... data to create a ProjectType
     *   }
     * })
     * 
     */
    create<T extends ProjectTypeCreateArgs>(args: SelectSubset<T, ProjectTypeCreateArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ProjectTypes.
     * @param {ProjectTypeCreateManyArgs} args - Arguments to create many ProjectTypes.
     * @example
     * // Create many ProjectTypes
     * const projectType = await prisma.projectType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTypeCreateManyArgs>(args?: SelectSubset<T, ProjectTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTypes and returns the data saved in the database.
     * @param {ProjectTypeCreateManyAndReturnArgs} args - Arguments to create many ProjectTypes.
     * @example
     * // Create many ProjectTypes
     * const projectType = await prisma.projectType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTypes and only return the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ProjectType.
     * @param {ProjectTypeDeleteArgs} args - Arguments to delete one ProjectType.
     * @example
     * // Delete one ProjectType
     * const ProjectType = await prisma.projectType.delete({
     *   where: {
     *     // ... filter to delete one ProjectType
     *   }
     * })
     * 
     */
    delete<T extends ProjectTypeDeleteArgs>(args: SelectSubset<T, ProjectTypeDeleteArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ProjectType.
     * @param {ProjectTypeUpdateArgs} args - Arguments to update one ProjectType.
     * @example
     * // Update one ProjectType
     * const projectType = await prisma.projectType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTypeUpdateArgs>(args: SelectSubset<T, ProjectTypeUpdateArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ProjectTypes.
     * @param {ProjectTypeDeleteManyArgs} args - Arguments to filter ProjectTypes to delete.
     * @example
     * // Delete a few ProjectTypes
     * const { count } = await prisma.projectType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTypeDeleteManyArgs>(args?: SelectSubset<T, ProjectTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTypes
     * const projectType = await prisma.projectType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTypeUpdateManyArgs>(args: SelectSubset<T, ProjectTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypes and returns the data updated in the database.
     * @param {ProjectTypeUpdateManyAndReturnArgs} args - Arguments to update many ProjectTypes.
     * @example
     * // Update many ProjectTypes
     * const projectType = await prisma.projectType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTypes and only return the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ProjectType.
     * @param {ProjectTypeUpsertArgs} args - Arguments to update or create a ProjectType.
     * @example
     * // Update or create a ProjectType
     * const projectType = await prisma.projectType.upsert({
     *   create: {
     *     // ... data to create a ProjectType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectType we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTypeUpsertArgs>(args: SelectSubset<T, ProjectTypeUpsertArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeCountArgs} args - Arguments to filter ProjectTypes to count.
     * @example
     * // Count the number of ProjectTypes
     * const count = await prisma.projectType.count({
     *   where: {
     *     // ... the filter for the ProjectTypes we want to count
     *   }
     * })
    **/
    count<T extends ProjectTypeCountArgs>(
      args?: Subset<T, ProjectTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTypeAggregateArgs>(args: Subset<T, ProjectTypeAggregateArgs>): Prisma.PrismaPromise<GetProjectTypeAggregateType<T>>

    /**
     * Group by ProjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectType model
   */
  readonly fields: ProjectTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectType$projectsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectType$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectType model
   */ 
  interface ProjectTypeFieldRefs {
    readonly id: FieldRef<"ProjectType", 'Int'>
    readonly name: FieldRef<"ProjectType", 'String'>
    readonly description: FieldRef<"ProjectType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectType findUnique
   */
  export type ProjectTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType findUniqueOrThrow
   */
  export type ProjectTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType findFirst
   */
  export type ProjectTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
     */
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType findFirstOrThrow
   */
  export type ProjectTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
     */
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType findMany
   */
  export type ProjectTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTypes to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType create
   */
  export type ProjectTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectType.
     */
    data: XOR<ProjectTypeCreateInput, ProjectTypeUncheckedCreateInput>
  }

  /**
   * ProjectType createMany
   */
  export type ProjectTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTypes.
     */
    data: ProjectTypeCreateManyInput | ProjectTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectType createManyAndReturn
   */
  export type ProjectTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectTypes.
     */
    data: ProjectTypeCreateManyInput | ProjectTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectType update
   */
  export type ProjectTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectType.
     */
    data: XOR<ProjectTypeUpdateInput, ProjectTypeUncheckedUpdateInput>
    /**
     * Choose, which ProjectType to update.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType updateMany
   */
  export type ProjectTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTypes.
     */
    data: XOR<ProjectTypeUpdateManyMutationInput, ProjectTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTypes to update
     */
    where?: ProjectTypeWhereInput
    /**
     * Limit how many ProjectTypes to update.
     */
    limit?: number
  }

  /**
   * ProjectType updateManyAndReturn
   */
  export type ProjectTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The data used to update ProjectTypes.
     */
    data: XOR<ProjectTypeUpdateManyMutationInput, ProjectTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTypes to update
     */
    where?: ProjectTypeWhereInput
    /**
     * Limit how many ProjectTypes to update.
     */
    limit?: number
  }

  /**
   * ProjectType upsert
   */
  export type ProjectTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectType to update in case it exists.
     */
    where: ProjectTypeWhereUniqueInput
    /**
     * In case the ProjectType found by the `where` argument doesn't exist, create a new ProjectType with this data.
     */
    create: XOR<ProjectTypeCreateInput, ProjectTypeUncheckedCreateInput>
    /**
     * In case the ProjectType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTypeUpdateInput, ProjectTypeUncheckedUpdateInput>
  }

  /**
   * ProjectType delete
   */
  export type ProjectTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter which ProjectType to delete.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType deleteMany
   */
  export type ProjectTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTypes to delete
     */
    where?: ProjectTypeWhereInput
    /**
     * Limit how many ProjectTypes to delete.
     */
    limit?: number
  }

  /**
   * ProjectType.projects
   */
  export type ProjectType$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * ProjectType without action
   */
  export type ProjectTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    projectTypeId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    projectTypeId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    businessCode: string | null
    projectCode: string | null
    name: string | null
    createDate: Date | null
    projectTypeId: number | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    businessCode: string | null
    projectCode: string | null
    name: string | null
    createDate: Date | null
    projectTypeId: number | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    businessCode: number
    projectCode: number
    name: number
    createDate: number
    projectTypeId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    projectTypeId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    projectTypeId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    businessCode?: true
    projectCode?: true
    name?: true
    createDate?: true
    projectTypeId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    businessCode?: true
    projectCode?: true
    name?: true
    createDate?: true
    projectTypeId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    businessCode?: true
    projectCode?: true
    name?: true
    createDate?: true
    projectTypeId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    businessCode: string
    projectCode: string
    name: string
    createDate: Date
    projectTypeId: number | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessCode?: boolean
    projectCode?: boolean
    name?: boolean
    createDate?: boolean
    projectTypeId?: boolean
    models?: boolean | Project$modelsArgs<ExtArgs>
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
    assignments?: boolean | Project$assignmentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessCode?: boolean
    projectCode?: boolean
    name?: boolean
    createDate?: boolean
    projectTypeId?: boolean
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessCode?: boolean
    projectCode?: boolean
    name?: boolean
    createDate?: boolean
    projectTypeId?: boolean
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    businessCode?: boolean
    projectCode?: boolean
    name?: boolean
    createDate?: boolean
    projectTypeId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessCode" | "projectCode" | "name" | "createDate" | "projectTypeId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | Project$modelsArgs<ExtArgs>
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
    assignments?: boolean | Project$assignmentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      models: Prisma.$ModelEntryPayload<ExtArgs>[]
      projectType: Prisma.$ProjectTypePayload<ExtArgs> | null
      assignments: Prisma.$ProjectAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      businessCode: string
      projectCode: string
      name: string
      createDate: Date
      projectTypeId: number | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends Project$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Project$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    projectType<T extends Project$projectTypeArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectTypeArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    assignments<T extends Project$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly businessCode: FieldRef<"Project", 'String'>
    readonly projectCode: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly createDate: FieldRef<"Project", 'DateTime'>
    readonly projectTypeId: FieldRef<"Project", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.models
   */
  export type Project$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    where?: ModelEntryWhereInput
    orderBy?: ModelEntryOrderByWithRelationInput | ModelEntryOrderByWithRelationInput[]
    cursor?: ModelEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelEntryScalarFieldEnum | ModelEntryScalarFieldEnum[]
  }

  /**
   * Project.projectType
   */
  export type Project$projectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    where?: ProjectTypeWhereInput
  }

  /**
   * Project.assignments
   */
  export type Project$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    where?: ProjectAssignmentWhereInput
    orderBy?: ProjectAssignmentOrderByWithRelationInput | ProjectAssignmentOrderByWithRelationInput[]
    cursor?: ProjectAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectAssignmentScalarFieldEnum | ProjectAssignmentScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ModelEntry
   */

  export type AggregateModelEntry = {
    _count: ModelEntryCountAggregateOutputType | null
    _avg: ModelEntryAvgAggregateOutputType | null
    _sum: ModelEntrySumAggregateOutputType | null
    _min: ModelEntryMinAggregateOutputType | null
    _max: ModelEntryMaxAggregateOutputType | null
  }

  export type ModelEntryAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ModelEntrySumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ModelEntryMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    createDate: Date | null
    createBy: string | null
    modifyDate: Date | null
    modifyBy: string | null
    projectId: number | null
  }

  export type ModelEntryMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    createDate: Date | null
    createBy: string | null
    modifyDate: Date | null
    modifyBy: string | null
    projectId: number | null
  }

  export type ModelEntryCountAggregateOutputType = {
    id: number
    code: number
    description: number
    createDate: number
    createBy: number
    modifyDate: number
    modifyBy: number
    projectId: number
    _all: number
  }


  export type ModelEntryAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ModelEntrySumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ModelEntryMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createDate?: true
    createBy?: true
    modifyDate?: true
    modifyBy?: true
    projectId?: true
  }

  export type ModelEntryMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createDate?: true
    createBy?: true
    modifyDate?: true
    modifyBy?: true
    projectId?: true
  }

  export type ModelEntryCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createDate?: true
    createBy?: true
    modifyDate?: true
    modifyBy?: true
    projectId?: true
    _all?: true
  }

  export type ModelEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelEntry to aggregate.
     */
    where?: ModelEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEntries to fetch.
     */
    orderBy?: ModelEntryOrderByWithRelationInput | ModelEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelEntries
    **/
    _count?: true | ModelEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelEntryMaxAggregateInputType
  }

  export type GetModelEntryAggregateType<T extends ModelEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateModelEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelEntry[P]>
      : GetScalarType<T[P], AggregateModelEntry[P]>
  }




  export type ModelEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelEntryWhereInput
    orderBy?: ModelEntryOrderByWithAggregationInput | ModelEntryOrderByWithAggregationInput[]
    by: ModelEntryScalarFieldEnum[] | ModelEntryScalarFieldEnum
    having?: ModelEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelEntryCountAggregateInputType | true
    _avg?: ModelEntryAvgAggregateInputType
    _sum?: ModelEntrySumAggregateInputType
    _min?: ModelEntryMinAggregateInputType
    _max?: ModelEntryMaxAggregateInputType
  }

  export type ModelEntryGroupByOutputType = {
    id: number
    code: string
    description: string | null
    createDate: Date
    createBy: string
    modifyDate: Date | null
    modifyBy: string | null
    projectId: number
    _count: ModelEntryCountAggregateOutputType | null
    _avg: ModelEntryAvgAggregateOutputType | null
    _sum: ModelEntrySumAggregateOutputType | null
    _min: ModelEntryMinAggregateOutputType | null
    _max: ModelEntryMaxAggregateOutputType | null
  }

  type GetModelEntryGroupByPayload<T extends ModelEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ModelEntryGroupByOutputType[P]>
        }
      >
    >


  export type ModelEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createDate?: boolean
    createBy?: boolean
    modifyDate?: boolean
    modifyBy?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelEntry"]>

  export type ModelEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createDate?: boolean
    createBy?: boolean
    modifyDate?: boolean
    modifyBy?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelEntry"]>

  export type ModelEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createDate?: boolean
    createBy?: boolean
    modifyDate?: boolean
    modifyBy?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelEntry"]>

  export type ModelEntrySelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    createDate?: boolean
    createBy?: boolean
    modifyDate?: boolean
    modifyBy?: boolean
    projectId?: boolean
  }

  export type ModelEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "createDate" | "createBy" | "modifyDate" | "modifyBy" | "projectId", ExtArgs["result"]["modelEntry"]>
  export type ModelEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ModelEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ModelEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ModelEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelEntry"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      description: string | null
      createDate: Date
      createBy: string
      modifyDate: Date | null
      modifyBy: string | null
      projectId: number
    }, ExtArgs["result"]["modelEntry"]>
    composites: {}
  }

  type ModelEntryGetPayload<S extends boolean | null | undefined | ModelEntryDefaultArgs> = $Result.GetResult<Prisma.$ModelEntryPayload, S>

  type ModelEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelEntryCountAggregateInputType | true
    }

  export interface ModelEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelEntry'], meta: { name: 'ModelEntry' } }
    /**
     * Find zero or one ModelEntry that matches the filter.
     * @param {ModelEntryFindUniqueArgs} args - Arguments to find a ModelEntry
     * @example
     * // Get one ModelEntry
     * const modelEntry = await prisma.modelEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelEntryFindUniqueArgs>(args: SelectSubset<T, ModelEntryFindUniqueArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ModelEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelEntryFindUniqueOrThrowArgs} args - Arguments to find a ModelEntry
     * @example
     * // Get one ModelEntry
     * const modelEntry = await prisma.modelEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ModelEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryFindFirstArgs} args - Arguments to find a ModelEntry
     * @example
     * // Get one ModelEntry
     * const modelEntry = await prisma.modelEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelEntryFindFirstArgs>(args?: SelectSubset<T, ModelEntryFindFirstArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ModelEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryFindFirstOrThrowArgs} args - Arguments to find a ModelEntry
     * @example
     * // Get one ModelEntry
     * const modelEntry = await prisma.modelEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelEntries
     * const modelEntries = await prisma.modelEntry.findMany()
     * 
     * // Get first 10 ModelEntries
     * const modelEntries = await prisma.modelEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelEntryWithIdOnly = await prisma.modelEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelEntryFindManyArgs>(args?: SelectSubset<T, ModelEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ModelEntry.
     * @param {ModelEntryCreateArgs} args - Arguments to create a ModelEntry.
     * @example
     * // Create one ModelEntry
     * const ModelEntry = await prisma.modelEntry.create({
     *   data: {
     *     // ... data to create a ModelEntry
     *   }
     * })
     * 
     */
    create<T extends ModelEntryCreateArgs>(args: SelectSubset<T, ModelEntryCreateArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ModelEntries.
     * @param {ModelEntryCreateManyArgs} args - Arguments to create many ModelEntries.
     * @example
     * // Create many ModelEntries
     * const modelEntry = await prisma.modelEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelEntryCreateManyArgs>(args?: SelectSubset<T, ModelEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelEntries and returns the data saved in the database.
     * @param {ModelEntryCreateManyAndReturnArgs} args - Arguments to create many ModelEntries.
     * @example
     * // Create many ModelEntries
     * const modelEntry = await prisma.modelEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelEntries and only return the `id`
     * const modelEntryWithIdOnly = await prisma.modelEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ModelEntry.
     * @param {ModelEntryDeleteArgs} args - Arguments to delete one ModelEntry.
     * @example
     * // Delete one ModelEntry
     * const ModelEntry = await prisma.modelEntry.delete({
     *   where: {
     *     // ... filter to delete one ModelEntry
     *   }
     * })
     * 
     */
    delete<T extends ModelEntryDeleteArgs>(args: SelectSubset<T, ModelEntryDeleteArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ModelEntry.
     * @param {ModelEntryUpdateArgs} args - Arguments to update one ModelEntry.
     * @example
     * // Update one ModelEntry
     * const modelEntry = await prisma.modelEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelEntryUpdateArgs>(args: SelectSubset<T, ModelEntryUpdateArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ModelEntries.
     * @param {ModelEntryDeleteManyArgs} args - Arguments to filter ModelEntries to delete.
     * @example
     * // Delete a few ModelEntries
     * const { count } = await prisma.modelEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelEntryDeleteManyArgs>(args?: SelectSubset<T, ModelEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelEntries
     * const modelEntry = await prisma.modelEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelEntryUpdateManyArgs>(args: SelectSubset<T, ModelEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelEntries and returns the data updated in the database.
     * @param {ModelEntryUpdateManyAndReturnArgs} args - Arguments to update many ModelEntries.
     * @example
     * // Update many ModelEntries
     * const modelEntry = await prisma.modelEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelEntries and only return the `id`
     * const modelEntryWithIdOnly = await prisma.modelEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ModelEntry.
     * @param {ModelEntryUpsertArgs} args - Arguments to update or create a ModelEntry.
     * @example
     * // Update or create a ModelEntry
     * const modelEntry = await prisma.modelEntry.upsert({
     *   create: {
     *     // ... data to create a ModelEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelEntry we want to update
     *   }
     * })
     */
    upsert<T extends ModelEntryUpsertArgs>(args: SelectSubset<T, ModelEntryUpsertArgs<ExtArgs>>): Prisma__ModelEntryClient<$Result.GetResult<Prisma.$ModelEntryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ModelEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryCountArgs} args - Arguments to filter ModelEntries to count.
     * @example
     * // Count the number of ModelEntries
     * const count = await prisma.modelEntry.count({
     *   where: {
     *     // ... the filter for the ModelEntries we want to count
     *   }
     * })
    **/
    count<T extends ModelEntryCountArgs>(
      args?: Subset<T, ModelEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelEntryAggregateArgs>(args: Subset<T, ModelEntryAggregateArgs>): Prisma.PrismaPromise<GetModelEntryAggregateType<T>>

    /**
     * Group by ModelEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelEntryGroupByArgs['orderBy'] }
        : { orderBy?: ModelEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelEntry model
   */
  readonly fields: ModelEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelEntry model
   */ 
  interface ModelEntryFieldRefs {
    readonly id: FieldRef<"ModelEntry", 'Int'>
    readonly code: FieldRef<"ModelEntry", 'String'>
    readonly description: FieldRef<"ModelEntry", 'String'>
    readonly createDate: FieldRef<"ModelEntry", 'DateTime'>
    readonly createBy: FieldRef<"ModelEntry", 'String'>
    readonly modifyDate: FieldRef<"ModelEntry", 'DateTime'>
    readonly modifyBy: FieldRef<"ModelEntry", 'String'>
    readonly projectId: FieldRef<"ModelEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ModelEntry findUnique
   */
  export type ModelEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * Filter, which ModelEntry to fetch.
     */
    where: ModelEntryWhereUniqueInput
  }

  /**
   * ModelEntry findUniqueOrThrow
   */
  export type ModelEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * Filter, which ModelEntry to fetch.
     */
    where: ModelEntryWhereUniqueInput
  }

  /**
   * ModelEntry findFirst
   */
  export type ModelEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * Filter, which ModelEntry to fetch.
     */
    where?: ModelEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEntries to fetch.
     */
    orderBy?: ModelEntryOrderByWithRelationInput | ModelEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelEntries.
     */
    cursor?: ModelEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelEntries.
     */
    distinct?: ModelEntryScalarFieldEnum | ModelEntryScalarFieldEnum[]
  }

  /**
   * ModelEntry findFirstOrThrow
   */
  export type ModelEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * Filter, which ModelEntry to fetch.
     */
    where?: ModelEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEntries to fetch.
     */
    orderBy?: ModelEntryOrderByWithRelationInput | ModelEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelEntries.
     */
    cursor?: ModelEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelEntries.
     */
    distinct?: ModelEntryScalarFieldEnum | ModelEntryScalarFieldEnum[]
  }

  /**
   * ModelEntry findMany
   */
  export type ModelEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * Filter, which ModelEntries to fetch.
     */
    where?: ModelEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEntries to fetch.
     */
    orderBy?: ModelEntryOrderByWithRelationInput | ModelEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelEntries.
     */
    cursor?: ModelEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEntries.
     */
    skip?: number
    distinct?: ModelEntryScalarFieldEnum | ModelEntryScalarFieldEnum[]
  }

  /**
   * ModelEntry create
   */
  export type ModelEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelEntry.
     */
    data: XOR<ModelEntryCreateInput, ModelEntryUncheckedCreateInput>
  }

  /**
   * ModelEntry createMany
   */
  export type ModelEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelEntries.
     */
    data: ModelEntryCreateManyInput | ModelEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelEntry createManyAndReturn
   */
  export type ModelEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * The data used to create many ModelEntries.
     */
    data: ModelEntryCreateManyInput | ModelEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModelEntry update
   */
  export type ModelEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelEntry.
     */
    data: XOR<ModelEntryUpdateInput, ModelEntryUncheckedUpdateInput>
    /**
     * Choose, which ModelEntry to update.
     */
    where: ModelEntryWhereUniqueInput
  }

  /**
   * ModelEntry updateMany
   */
  export type ModelEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelEntries.
     */
    data: XOR<ModelEntryUpdateManyMutationInput, ModelEntryUncheckedUpdateManyInput>
    /**
     * Filter which ModelEntries to update
     */
    where?: ModelEntryWhereInput
    /**
     * Limit how many ModelEntries to update.
     */
    limit?: number
  }

  /**
   * ModelEntry updateManyAndReturn
   */
  export type ModelEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * The data used to update ModelEntries.
     */
    data: XOR<ModelEntryUpdateManyMutationInput, ModelEntryUncheckedUpdateManyInput>
    /**
     * Filter which ModelEntries to update
     */
    where?: ModelEntryWhereInput
    /**
     * Limit how many ModelEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModelEntry upsert
   */
  export type ModelEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelEntry to update in case it exists.
     */
    where: ModelEntryWhereUniqueInput
    /**
     * In case the ModelEntry found by the `where` argument doesn't exist, create a new ModelEntry with this data.
     */
    create: XOR<ModelEntryCreateInput, ModelEntryUncheckedCreateInput>
    /**
     * In case the ModelEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelEntryUpdateInput, ModelEntryUncheckedUpdateInput>
  }

  /**
   * ModelEntry delete
   */
  export type ModelEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
    /**
     * Filter which ModelEntry to delete.
     */
    where: ModelEntryWhereUniqueInput
  }

  /**
   * ModelEntry deleteMany
   */
  export type ModelEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelEntries to delete
     */
    where?: ModelEntryWhereInput
    /**
     * Limit how many ModelEntries to delete.
     */
    limit?: number
  }

  /**
   * ModelEntry without action
   */
  export type ModelEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEntry
     */
    select?: ModelEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEntry
     */
    omit?: ModelEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEntryInclude<ExtArgs> | null
  }


  /**
   * Model ProjectAssignment
   */

  export type AggregateProjectAssignment = {
    _count: ProjectAssignmentCountAggregateOutputType | null
    _avg: ProjectAssignmentAvgAggregateOutputType | null
    _sum: ProjectAssignmentSumAggregateOutputType | null
    _min: ProjectAssignmentMinAggregateOutputType | null
    _max: ProjectAssignmentMaxAggregateOutputType | null
  }

  export type ProjectAssignmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    projectId: number | null
  }

  export type ProjectAssignmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    projectId: number | null
  }

  export type ProjectAssignmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    projectId: number | null
    role: string | null
  }

  export type ProjectAssignmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    projectId: number | null
    role: string | null
  }

  export type ProjectAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    role: number
    _all: number
  }


  export type ProjectAssignmentAvgAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
  }

  export type ProjectAssignmentSumAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
  }

  export type ProjectAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    role?: true
  }

  export type ProjectAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    role?: true
  }

  export type ProjectAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    role?: true
    _all?: true
  }

  export type ProjectAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectAssignment to aggregate.
     */
    where?: ProjectAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAssignments to fetch.
     */
    orderBy?: ProjectAssignmentOrderByWithRelationInput | ProjectAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectAssignments
    **/
    _count?: true | ProjectAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectAssignmentMaxAggregateInputType
  }

  export type GetProjectAssignmentAggregateType<T extends ProjectAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectAssignment[P]>
      : GetScalarType<T[P], AggregateProjectAssignment[P]>
  }




  export type ProjectAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectAssignmentWhereInput
    orderBy?: ProjectAssignmentOrderByWithAggregationInput | ProjectAssignmentOrderByWithAggregationInput[]
    by: ProjectAssignmentScalarFieldEnum[] | ProjectAssignmentScalarFieldEnum
    having?: ProjectAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectAssignmentCountAggregateInputType | true
    _avg?: ProjectAssignmentAvgAggregateInputType
    _sum?: ProjectAssignmentSumAggregateInputType
    _min?: ProjectAssignmentMinAggregateInputType
    _max?: ProjectAssignmentMaxAggregateInputType
  }

  export type ProjectAssignmentGroupByOutputType = {
    id: number
    userId: number
    projectId: number
    role: string
    _count: ProjectAssignmentCountAggregateOutputType | null
    _avg: ProjectAssignmentAvgAggregateOutputType | null
    _sum: ProjectAssignmentSumAggregateOutputType | null
    _min: ProjectAssignmentMinAggregateOutputType | null
    _max: ProjectAssignmentMaxAggregateOutputType | null
  }

  type GetProjectAssignmentGroupByPayload<T extends ProjectAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectAssignment"]>

  export type ProjectAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectAssignment"]>

  export type ProjectAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectAssignment"]>

  export type ProjectAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
  }

  export type ProjectAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "projectId" | "role", ExtArgs["result"]["projectAssignment"]>
  export type ProjectAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectAssignment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      projectId: number
      role: string
    }, ExtArgs["result"]["projectAssignment"]>
    composites: {}
  }

  type ProjectAssignmentGetPayload<S extends boolean | null | undefined | ProjectAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ProjectAssignmentPayload, S>

  type ProjectAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectAssignmentCountAggregateInputType | true
    }

  export interface ProjectAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectAssignment'], meta: { name: 'ProjectAssignment' } }
    /**
     * Find zero or one ProjectAssignment that matches the filter.
     * @param {ProjectAssignmentFindUniqueArgs} args - Arguments to find a ProjectAssignment
     * @example
     * // Get one ProjectAssignment
     * const projectAssignment = await prisma.projectAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectAssignmentFindUniqueArgs>(args: SelectSubset<T, ProjectAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ProjectAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ProjectAssignment
     * @example
     * // Get one ProjectAssignment
     * const projectAssignment = await prisma.projectAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentFindFirstArgs} args - Arguments to find a ProjectAssignment
     * @example
     * // Get one ProjectAssignment
     * const projectAssignment = await prisma.projectAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectAssignmentFindFirstArgs>(args?: SelectSubset<T, ProjectAssignmentFindFirstArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentFindFirstOrThrowArgs} args - Arguments to find a ProjectAssignment
     * @example
     * // Get one ProjectAssignment
     * const projectAssignment = await prisma.projectAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ProjectAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectAssignments
     * const projectAssignments = await prisma.projectAssignment.findMany()
     * 
     * // Get first 10 ProjectAssignments
     * const projectAssignments = await prisma.projectAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectAssignmentWithIdOnly = await prisma.projectAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectAssignmentFindManyArgs>(args?: SelectSubset<T, ProjectAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ProjectAssignment.
     * @param {ProjectAssignmentCreateArgs} args - Arguments to create a ProjectAssignment.
     * @example
     * // Create one ProjectAssignment
     * const ProjectAssignment = await prisma.projectAssignment.create({
     *   data: {
     *     // ... data to create a ProjectAssignment
     *   }
     * })
     * 
     */
    create<T extends ProjectAssignmentCreateArgs>(args: SelectSubset<T, ProjectAssignmentCreateArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ProjectAssignments.
     * @param {ProjectAssignmentCreateManyArgs} args - Arguments to create many ProjectAssignments.
     * @example
     * // Create many ProjectAssignments
     * const projectAssignment = await prisma.projectAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectAssignmentCreateManyArgs>(args?: SelectSubset<T, ProjectAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectAssignments and returns the data saved in the database.
     * @param {ProjectAssignmentCreateManyAndReturnArgs} args - Arguments to create many ProjectAssignments.
     * @example
     * // Create many ProjectAssignments
     * const projectAssignment = await prisma.projectAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectAssignments and only return the `id`
     * const projectAssignmentWithIdOnly = await prisma.projectAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ProjectAssignment.
     * @param {ProjectAssignmentDeleteArgs} args - Arguments to delete one ProjectAssignment.
     * @example
     * // Delete one ProjectAssignment
     * const ProjectAssignment = await prisma.projectAssignment.delete({
     *   where: {
     *     // ... filter to delete one ProjectAssignment
     *   }
     * })
     * 
     */
    delete<T extends ProjectAssignmentDeleteArgs>(args: SelectSubset<T, ProjectAssignmentDeleteArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ProjectAssignment.
     * @param {ProjectAssignmentUpdateArgs} args - Arguments to update one ProjectAssignment.
     * @example
     * // Update one ProjectAssignment
     * const projectAssignment = await prisma.projectAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectAssignmentUpdateArgs>(args: SelectSubset<T, ProjectAssignmentUpdateArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ProjectAssignments.
     * @param {ProjectAssignmentDeleteManyArgs} args - Arguments to filter ProjectAssignments to delete.
     * @example
     * // Delete a few ProjectAssignments
     * const { count } = await prisma.projectAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectAssignmentDeleteManyArgs>(args?: SelectSubset<T, ProjectAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectAssignments
     * const projectAssignment = await prisma.projectAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectAssignmentUpdateManyArgs>(args: SelectSubset<T, ProjectAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectAssignments and returns the data updated in the database.
     * @param {ProjectAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ProjectAssignments.
     * @example
     * // Update many ProjectAssignments
     * const projectAssignment = await prisma.projectAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectAssignments and only return the `id`
     * const projectAssignmentWithIdOnly = await prisma.projectAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ProjectAssignment.
     * @param {ProjectAssignmentUpsertArgs} args - Arguments to update or create a ProjectAssignment.
     * @example
     * // Update or create a ProjectAssignment
     * const projectAssignment = await prisma.projectAssignment.upsert({
     *   create: {
     *     // ... data to create a ProjectAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ProjectAssignmentUpsertArgs>(args: SelectSubset<T, ProjectAssignmentUpsertArgs<ExtArgs>>): Prisma__ProjectAssignmentClient<$Result.GetResult<Prisma.$ProjectAssignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ProjectAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentCountArgs} args - Arguments to filter ProjectAssignments to count.
     * @example
     * // Count the number of ProjectAssignments
     * const count = await prisma.projectAssignment.count({
     *   where: {
     *     // ... the filter for the ProjectAssignments we want to count
     *   }
     * })
    **/
    count<T extends ProjectAssignmentCountArgs>(
      args?: Subset<T, ProjectAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAssignmentAggregateArgs>(args: Subset<T, ProjectAssignmentAggregateArgs>): Prisma.PrismaPromise<GetProjectAssignmentAggregateType<T>>

    /**
     * Group by ProjectAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectAssignment model
   */
  readonly fields: ProjectAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectAssignment model
   */ 
  interface ProjectAssignmentFieldRefs {
    readonly id: FieldRef<"ProjectAssignment", 'Int'>
    readonly userId: FieldRef<"ProjectAssignment", 'Int'>
    readonly projectId: FieldRef<"ProjectAssignment", 'Int'>
    readonly role: FieldRef<"ProjectAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectAssignment findUnique
   */
  export type ProjectAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAssignment to fetch.
     */
    where: ProjectAssignmentWhereUniqueInput
  }

  /**
   * ProjectAssignment findUniqueOrThrow
   */
  export type ProjectAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAssignment to fetch.
     */
    where: ProjectAssignmentWhereUniqueInput
  }

  /**
   * ProjectAssignment findFirst
   */
  export type ProjectAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAssignment to fetch.
     */
    where?: ProjectAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAssignments to fetch.
     */
    orderBy?: ProjectAssignmentOrderByWithRelationInput | ProjectAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectAssignments.
     */
    cursor?: ProjectAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectAssignments.
     */
    distinct?: ProjectAssignmentScalarFieldEnum | ProjectAssignmentScalarFieldEnum[]
  }

  /**
   * ProjectAssignment findFirstOrThrow
   */
  export type ProjectAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAssignment to fetch.
     */
    where?: ProjectAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAssignments to fetch.
     */
    orderBy?: ProjectAssignmentOrderByWithRelationInput | ProjectAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectAssignments.
     */
    cursor?: ProjectAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectAssignments.
     */
    distinct?: ProjectAssignmentScalarFieldEnum | ProjectAssignmentScalarFieldEnum[]
  }

  /**
   * ProjectAssignment findMany
   */
  export type ProjectAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAssignments to fetch.
     */
    where?: ProjectAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAssignments to fetch.
     */
    orderBy?: ProjectAssignmentOrderByWithRelationInput | ProjectAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectAssignments.
     */
    cursor?: ProjectAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAssignments.
     */
    skip?: number
    distinct?: ProjectAssignmentScalarFieldEnum | ProjectAssignmentScalarFieldEnum[]
  }

  /**
   * ProjectAssignment create
   */
  export type ProjectAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectAssignment.
     */
    data: XOR<ProjectAssignmentCreateInput, ProjectAssignmentUncheckedCreateInput>
  }

  /**
   * ProjectAssignment createMany
   */
  export type ProjectAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectAssignments.
     */
    data: ProjectAssignmentCreateManyInput | ProjectAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectAssignment createManyAndReturn
   */
  export type ProjectAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectAssignments.
     */
    data: ProjectAssignmentCreateManyInput | ProjectAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectAssignment update
   */
  export type ProjectAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectAssignment.
     */
    data: XOR<ProjectAssignmentUpdateInput, ProjectAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ProjectAssignment to update.
     */
    where: ProjectAssignmentWhereUniqueInput
  }

  /**
   * ProjectAssignment updateMany
   */
  export type ProjectAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectAssignments.
     */
    data: XOR<ProjectAssignmentUpdateManyMutationInput, ProjectAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectAssignments to update
     */
    where?: ProjectAssignmentWhereInput
    /**
     * Limit how many ProjectAssignments to update.
     */
    limit?: number
  }

  /**
   * ProjectAssignment updateManyAndReturn
   */
  export type ProjectAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ProjectAssignments.
     */
    data: XOR<ProjectAssignmentUpdateManyMutationInput, ProjectAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectAssignments to update
     */
    where?: ProjectAssignmentWhereInput
    /**
     * Limit how many ProjectAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectAssignment upsert
   */
  export type ProjectAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectAssignment to update in case it exists.
     */
    where: ProjectAssignmentWhereUniqueInput
    /**
     * In case the ProjectAssignment found by the `where` argument doesn't exist, create a new ProjectAssignment with this data.
     */
    create: XOR<ProjectAssignmentCreateInput, ProjectAssignmentUncheckedCreateInput>
    /**
     * In case the ProjectAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectAssignmentUpdateInput, ProjectAssignmentUncheckedUpdateInput>
  }

  /**
   * ProjectAssignment delete
   */
  export type ProjectAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ProjectAssignment to delete.
     */
    where: ProjectAssignmentWhereUniqueInput
  }

  /**
   * ProjectAssignment deleteMany
   */
  export type ProjectAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectAssignments to delete
     */
    where?: ProjectAssignmentWhereInput
    /**
     * Limit how many ProjectAssignments to delete.
     */
    limit?: number
  }

  /**
   * ProjectAssignment without action
   */
  export type ProjectAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAssignment
     */
    select?: ProjectAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectAssignment
     */
    omit?: ProjectAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model SambaLog
   */

  export type AggregateSambaLog = {
    _count: SambaLogCountAggregateOutputType | null
    _avg: SambaLogAvgAggregateOutputType | null
    _sum: SambaLogSumAggregateOutputType | null
    _min: SambaLogMinAggregateOutputType | null
    _max: SambaLogMaxAggregateOutputType | null
  }

  export type SambaLogAvgAggregateOutputType = {
    id: number | null
    errorCode: number | null
  }

  export type SambaLogSumAggregateOutputType = {
    id: number | null
    errorCode: number | null
  }

  export type SambaLogMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    component: string | null
    level: string | null
    message: string | null
    zone: string | null
    name: string | null
    errorCode: number | null
    errorName: string | null
    hostname: string | null
    createdAt: Date | null
  }

  export type SambaLogMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    component: string | null
    level: string | null
    message: string | null
    zone: string | null
    name: string | null
    errorCode: number | null
    errorName: string | null
    hostname: string | null
    createdAt: Date | null
  }

  export type SambaLogCountAggregateOutputType = {
    id: number
    timestamp: number
    component: number
    level: number
    message: number
    zone: number
    name: number
    errorCode: number
    errorName: number
    hostname: number
    createdAt: number
    _all: number
  }


  export type SambaLogAvgAggregateInputType = {
    id?: true
    errorCode?: true
  }

  export type SambaLogSumAggregateInputType = {
    id?: true
    errorCode?: true
  }

  export type SambaLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    component?: true
    level?: true
    message?: true
    zone?: true
    name?: true
    errorCode?: true
    errorName?: true
    hostname?: true
    createdAt?: true
  }

  export type SambaLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    component?: true
    level?: true
    message?: true
    zone?: true
    name?: true
    errorCode?: true
    errorName?: true
    hostname?: true
    createdAt?: true
  }

  export type SambaLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    component?: true
    level?: true
    message?: true
    zone?: true
    name?: true
    errorCode?: true
    errorName?: true
    hostname?: true
    createdAt?: true
    _all?: true
  }

  export type SambaLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SambaLog to aggregate.
     */
    where?: SambaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SambaLogs to fetch.
     */
    orderBy?: SambaLogOrderByWithRelationInput | SambaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SambaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SambaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SambaLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SambaLogs
    **/
    _count?: true | SambaLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SambaLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SambaLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SambaLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SambaLogMaxAggregateInputType
  }

  export type GetSambaLogAggregateType<T extends SambaLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSambaLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSambaLog[P]>
      : GetScalarType<T[P], AggregateSambaLog[P]>
  }




  export type SambaLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SambaLogWhereInput
    orderBy?: SambaLogOrderByWithAggregationInput | SambaLogOrderByWithAggregationInput[]
    by: SambaLogScalarFieldEnum[] | SambaLogScalarFieldEnum
    having?: SambaLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SambaLogCountAggregateInputType | true
    _avg?: SambaLogAvgAggregateInputType
    _sum?: SambaLogSumAggregateInputType
    _min?: SambaLogMinAggregateInputType
    _max?: SambaLogMaxAggregateInputType
  }

  export type SambaLogGroupByOutputType = {
    id: number
    timestamp: Date
    component: string
    level: string
    message: string
    zone: string | null
    name: string | null
    errorCode: number | null
    errorName: string | null
    hostname: string | null
    createdAt: Date
    _count: SambaLogCountAggregateOutputType | null
    _avg: SambaLogAvgAggregateOutputType | null
    _sum: SambaLogSumAggregateOutputType | null
    _min: SambaLogMinAggregateOutputType | null
    _max: SambaLogMaxAggregateOutputType | null
  }

  type GetSambaLogGroupByPayload<T extends SambaLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SambaLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SambaLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SambaLogGroupByOutputType[P]>
            : GetScalarType<T[P], SambaLogGroupByOutputType[P]>
        }
      >
    >


  export type SambaLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    component?: boolean
    level?: boolean
    message?: boolean
    zone?: boolean
    name?: boolean
    errorCode?: boolean
    errorName?: boolean
    hostname?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sambaLog"]>

  export type SambaLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    component?: boolean
    level?: boolean
    message?: boolean
    zone?: boolean
    name?: boolean
    errorCode?: boolean
    errorName?: boolean
    hostname?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sambaLog"]>

  export type SambaLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    component?: boolean
    level?: boolean
    message?: boolean
    zone?: boolean
    name?: boolean
    errorCode?: boolean
    errorName?: boolean
    hostname?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sambaLog"]>

  export type SambaLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    component?: boolean
    level?: boolean
    message?: boolean
    zone?: boolean
    name?: boolean
    errorCode?: boolean
    errorName?: boolean
    hostname?: boolean
    createdAt?: boolean
  }

  export type SambaLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "component" | "level" | "message" | "zone" | "name" | "errorCode" | "errorName" | "hostname" | "createdAt", ExtArgs["result"]["sambaLog"]>

  export type $SambaLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SambaLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      component: string
      level: string
      message: string
      zone: string | null
      name: string | null
      errorCode: number | null
      errorName: string | null
      hostname: string | null
      createdAt: Date
    }, ExtArgs["result"]["sambaLog"]>
    composites: {}
  }

  type SambaLogGetPayload<S extends boolean | null | undefined | SambaLogDefaultArgs> = $Result.GetResult<Prisma.$SambaLogPayload, S>

  type SambaLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SambaLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SambaLogCountAggregateInputType | true
    }

  export interface SambaLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SambaLog'], meta: { name: 'SambaLog' } }
    /**
     * Find zero or one SambaLog that matches the filter.
     * @param {SambaLogFindUniqueArgs} args - Arguments to find a SambaLog
     * @example
     * // Get one SambaLog
     * const sambaLog = await prisma.sambaLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SambaLogFindUniqueArgs>(args: SelectSubset<T, SambaLogFindUniqueArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SambaLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SambaLogFindUniqueOrThrowArgs} args - Arguments to find a SambaLog
     * @example
     * // Get one SambaLog
     * const sambaLog = await prisma.sambaLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SambaLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SambaLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SambaLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogFindFirstArgs} args - Arguments to find a SambaLog
     * @example
     * // Get one SambaLog
     * const sambaLog = await prisma.sambaLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SambaLogFindFirstArgs>(args?: SelectSubset<T, SambaLogFindFirstArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SambaLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogFindFirstOrThrowArgs} args - Arguments to find a SambaLog
     * @example
     * // Get one SambaLog
     * const sambaLog = await prisma.sambaLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SambaLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SambaLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SambaLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SambaLogs
     * const sambaLogs = await prisma.sambaLog.findMany()
     * 
     * // Get first 10 SambaLogs
     * const sambaLogs = await prisma.sambaLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sambaLogWithIdOnly = await prisma.sambaLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SambaLogFindManyArgs>(args?: SelectSubset<T, SambaLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SambaLog.
     * @param {SambaLogCreateArgs} args - Arguments to create a SambaLog.
     * @example
     * // Create one SambaLog
     * const SambaLog = await prisma.sambaLog.create({
     *   data: {
     *     // ... data to create a SambaLog
     *   }
     * })
     * 
     */
    create<T extends SambaLogCreateArgs>(args: SelectSubset<T, SambaLogCreateArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SambaLogs.
     * @param {SambaLogCreateManyArgs} args - Arguments to create many SambaLogs.
     * @example
     * // Create many SambaLogs
     * const sambaLog = await prisma.sambaLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SambaLogCreateManyArgs>(args?: SelectSubset<T, SambaLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SambaLogs and returns the data saved in the database.
     * @param {SambaLogCreateManyAndReturnArgs} args - Arguments to create many SambaLogs.
     * @example
     * // Create many SambaLogs
     * const sambaLog = await prisma.sambaLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SambaLogs and only return the `id`
     * const sambaLogWithIdOnly = await prisma.sambaLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SambaLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SambaLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SambaLog.
     * @param {SambaLogDeleteArgs} args - Arguments to delete one SambaLog.
     * @example
     * // Delete one SambaLog
     * const SambaLog = await prisma.sambaLog.delete({
     *   where: {
     *     // ... filter to delete one SambaLog
     *   }
     * })
     * 
     */
    delete<T extends SambaLogDeleteArgs>(args: SelectSubset<T, SambaLogDeleteArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SambaLog.
     * @param {SambaLogUpdateArgs} args - Arguments to update one SambaLog.
     * @example
     * // Update one SambaLog
     * const sambaLog = await prisma.sambaLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SambaLogUpdateArgs>(args: SelectSubset<T, SambaLogUpdateArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SambaLogs.
     * @param {SambaLogDeleteManyArgs} args - Arguments to filter SambaLogs to delete.
     * @example
     * // Delete a few SambaLogs
     * const { count } = await prisma.sambaLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SambaLogDeleteManyArgs>(args?: SelectSubset<T, SambaLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SambaLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SambaLogs
     * const sambaLog = await prisma.sambaLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SambaLogUpdateManyArgs>(args: SelectSubset<T, SambaLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SambaLogs and returns the data updated in the database.
     * @param {SambaLogUpdateManyAndReturnArgs} args - Arguments to update many SambaLogs.
     * @example
     * // Update many SambaLogs
     * const sambaLog = await prisma.sambaLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SambaLogs and only return the `id`
     * const sambaLogWithIdOnly = await prisma.sambaLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SambaLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SambaLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SambaLog.
     * @param {SambaLogUpsertArgs} args - Arguments to update or create a SambaLog.
     * @example
     * // Update or create a SambaLog
     * const sambaLog = await prisma.sambaLog.upsert({
     *   create: {
     *     // ... data to create a SambaLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SambaLog we want to update
     *   }
     * })
     */
    upsert<T extends SambaLogUpsertArgs>(args: SelectSubset<T, SambaLogUpsertArgs<ExtArgs>>): Prisma__SambaLogClient<$Result.GetResult<Prisma.$SambaLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SambaLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogCountArgs} args - Arguments to filter SambaLogs to count.
     * @example
     * // Count the number of SambaLogs
     * const count = await prisma.sambaLog.count({
     *   where: {
     *     // ... the filter for the SambaLogs we want to count
     *   }
     * })
    **/
    count<T extends SambaLogCountArgs>(
      args?: Subset<T, SambaLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SambaLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SambaLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SambaLogAggregateArgs>(args: Subset<T, SambaLogAggregateArgs>): Prisma.PrismaPromise<GetSambaLogAggregateType<T>>

    /**
     * Group by SambaLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SambaLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SambaLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SambaLogGroupByArgs['orderBy'] }
        : { orderBy?: SambaLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SambaLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSambaLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SambaLog model
   */
  readonly fields: SambaLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SambaLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SambaLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SambaLog model
   */ 
  interface SambaLogFieldRefs {
    readonly id: FieldRef<"SambaLog", 'Int'>
    readonly timestamp: FieldRef<"SambaLog", 'DateTime'>
    readonly component: FieldRef<"SambaLog", 'String'>
    readonly level: FieldRef<"SambaLog", 'String'>
    readonly message: FieldRef<"SambaLog", 'String'>
    readonly zone: FieldRef<"SambaLog", 'String'>
    readonly name: FieldRef<"SambaLog", 'String'>
    readonly errorCode: FieldRef<"SambaLog", 'Int'>
    readonly errorName: FieldRef<"SambaLog", 'String'>
    readonly hostname: FieldRef<"SambaLog", 'String'>
    readonly createdAt: FieldRef<"SambaLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SambaLog findUnique
   */
  export type SambaLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * Filter, which SambaLog to fetch.
     */
    where: SambaLogWhereUniqueInput
  }

  /**
   * SambaLog findUniqueOrThrow
   */
  export type SambaLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * Filter, which SambaLog to fetch.
     */
    where: SambaLogWhereUniqueInput
  }

  /**
   * SambaLog findFirst
   */
  export type SambaLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * Filter, which SambaLog to fetch.
     */
    where?: SambaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SambaLogs to fetch.
     */
    orderBy?: SambaLogOrderByWithRelationInput | SambaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SambaLogs.
     */
    cursor?: SambaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SambaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SambaLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SambaLogs.
     */
    distinct?: SambaLogScalarFieldEnum | SambaLogScalarFieldEnum[]
  }

  /**
   * SambaLog findFirstOrThrow
   */
  export type SambaLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * Filter, which SambaLog to fetch.
     */
    where?: SambaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SambaLogs to fetch.
     */
    orderBy?: SambaLogOrderByWithRelationInput | SambaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SambaLogs.
     */
    cursor?: SambaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SambaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SambaLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SambaLogs.
     */
    distinct?: SambaLogScalarFieldEnum | SambaLogScalarFieldEnum[]
  }

  /**
   * SambaLog findMany
   */
  export type SambaLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * Filter, which SambaLogs to fetch.
     */
    where?: SambaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SambaLogs to fetch.
     */
    orderBy?: SambaLogOrderByWithRelationInput | SambaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SambaLogs.
     */
    cursor?: SambaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SambaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SambaLogs.
     */
    skip?: number
    distinct?: SambaLogScalarFieldEnum | SambaLogScalarFieldEnum[]
  }

  /**
   * SambaLog create
   */
  export type SambaLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SambaLog.
     */
    data: XOR<SambaLogCreateInput, SambaLogUncheckedCreateInput>
  }

  /**
   * SambaLog createMany
   */
  export type SambaLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SambaLogs.
     */
    data: SambaLogCreateManyInput | SambaLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SambaLog createManyAndReturn
   */
  export type SambaLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * The data used to create many SambaLogs.
     */
    data: SambaLogCreateManyInput | SambaLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SambaLog update
   */
  export type SambaLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SambaLog.
     */
    data: XOR<SambaLogUpdateInput, SambaLogUncheckedUpdateInput>
    /**
     * Choose, which SambaLog to update.
     */
    where: SambaLogWhereUniqueInput
  }

  /**
   * SambaLog updateMany
   */
  export type SambaLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SambaLogs.
     */
    data: XOR<SambaLogUpdateManyMutationInput, SambaLogUncheckedUpdateManyInput>
    /**
     * Filter which SambaLogs to update
     */
    where?: SambaLogWhereInput
    /**
     * Limit how many SambaLogs to update.
     */
    limit?: number
  }

  /**
   * SambaLog updateManyAndReturn
   */
  export type SambaLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * The data used to update SambaLogs.
     */
    data: XOR<SambaLogUpdateManyMutationInput, SambaLogUncheckedUpdateManyInput>
    /**
     * Filter which SambaLogs to update
     */
    where?: SambaLogWhereInput
    /**
     * Limit how many SambaLogs to update.
     */
    limit?: number
  }

  /**
   * SambaLog upsert
   */
  export type SambaLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SambaLog to update in case it exists.
     */
    where: SambaLogWhereUniqueInput
    /**
     * In case the SambaLog found by the `where` argument doesn't exist, create a new SambaLog with this data.
     */
    create: XOR<SambaLogCreateInput, SambaLogUncheckedCreateInput>
    /**
     * In case the SambaLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SambaLogUpdateInput, SambaLogUncheckedUpdateInput>
  }

  /**
   * SambaLog delete
   */
  export type SambaLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
    /**
     * Filter which SambaLog to delete.
     */
    where: SambaLogWhereUniqueInput
  }

  /**
   * SambaLog deleteMany
   */
  export type SambaLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SambaLogs to delete
     */
    where?: SambaLogWhereInput
    /**
     * Limit how many SambaLogs to delete.
     */
    limit?: number
  }

  /**
   * SambaLog without action
   */
  export type SambaLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SambaLog
     */
    select?: SambaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SambaLog
     */
    omit?: SambaLogOmit<ExtArgs> | null
  }


  /**
   * Model location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    modifyBy: string | null
    createBy: string | null
    modifyDate: Date | null
    CCY: string | null
    Region: string | null
    Remarks: string | null
    WCI_URL: string | null
    createDate: Date | null
    fullname: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    modifyBy: string | null
    createBy: string | null
    modifyDate: Date | null
    CCY: string | null
    Region: string | null
    Remarks: string | null
    WCI_URL: string | null
    createDate: Date | null
    fullname: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    modifyBy: number
    createBy: number
    modifyDate: number
    CCY: number
    Region: number
    Remarks: number
    WCI_URL: number
    createDate: number
    fullname: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    modifyBy?: true
    createBy?: true
    modifyDate?: true
    CCY?: true
    Region?: true
    Remarks?: true
    WCI_URL?: true
    createDate?: true
    fullname?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    modifyBy?: true
    createBy?: true
    modifyDate?: true
    CCY?: true
    Region?: true
    Remarks?: true
    WCI_URL?: true
    createDate?: true
    fullname?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    modifyBy?: true
    createBy?: true
    modifyDate?: true
    CCY?: true
    Region?: true
    Remarks?: true
    WCI_URL?: true
    createDate?: true
    fullname?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location to aggregate.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type locationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationWhereInput
    orderBy?: locationOrderByWithAggregationInput | locationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    code: string
    name: string
    modifyBy: string | null
    createBy: string
    modifyDate: Date
    CCY: string | null
    Region: string | null
    Remarks: string | null
    WCI_URL: string | null
    createDate: Date
    fullname: string | null
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends locationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    modifyBy?: boolean
    createBy?: boolean
    modifyDate?: boolean
    CCY?: boolean
    Region?: boolean
    Remarks?: boolean
    WCI_URL?: boolean
    createDate?: boolean
    fullname?: boolean
    TeamLocation?: boolean | location$TeamLocationArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type locationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    modifyBy?: boolean
    createBy?: boolean
    modifyDate?: boolean
    CCY?: boolean
    Region?: boolean
    Remarks?: boolean
    WCI_URL?: boolean
    createDate?: boolean
    fullname?: boolean
  }, ExtArgs["result"]["location"]>

  export type locationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    modifyBy?: boolean
    createBy?: boolean
    modifyDate?: boolean
    CCY?: boolean
    Region?: boolean
    Remarks?: boolean
    WCI_URL?: boolean
    createDate?: boolean
    fullname?: boolean
  }, ExtArgs["result"]["location"]>

  export type locationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    modifyBy?: boolean
    createBy?: boolean
    modifyDate?: boolean
    CCY?: boolean
    Region?: boolean
    Remarks?: boolean
    WCI_URL?: boolean
    createDate?: boolean
    fullname?: boolean
  }

  export type locationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "modifyBy" | "createBy" | "modifyDate" | "CCY" | "Region" | "Remarks" | "WCI_URL" | "createDate" | "fullname", ExtArgs["result"]["location"]>
  export type locationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TeamLocation?: boolean | location$TeamLocationArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type locationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type locationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $locationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "location"
    objects: {
      TeamLocation: Prisma.$TeamLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      modifyBy: string | null
      createBy: string
      modifyDate: Date
      CCY: string | null
      Region: string | null
      Remarks: string | null
      WCI_URL: string | null
      createDate: Date
      fullname: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type locationGetPayload<S extends boolean | null | undefined | locationDefaultArgs> = $Result.GetResult<Prisma.$locationPayload, S>

  type locationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface locationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['location'], meta: { name: 'location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationFindUniqueArgs>(args: SelectSubset<T, locationFindUniqueArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationFindUniqueOrThrowArgs>(args: SelectSubset<T, locationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationFindFirstArgs>(args?: SelectSubset<T, locationFindFirstArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationFindFirstOrThrowArgs>(args?: SelectSubset<T, locationFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationFindManyArgs>(args?: SelectSubset<T, locationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends locationCreateArgs>(args: SelectSubset<T, locationCreateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Locations.
     * @param {locationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationCreateManyArgs>(args?: SelectSubset<T, locationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {locationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends locationCreateManyAndReturnArgs>(args?: SelectSubset<T, locationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends locationDeleteArgs>(args: SelectSubset<T, locationDeleteArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationUpdateArgs>(args: SelectSubset<T, locationUpdateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationDeleteManyArgs>(args?: SelectSubset<T, locationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationUpdateManyArgs>(args: SelectSubset<T, locationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {locationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends locationUpdateManyAndReturnArgs>(args: SelectSubset<T, locationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends locationUpsertArgs>(args: SelectSubset<T, locationUpsertArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationGroupByArgs['orderBy'] }
        : { orderBy?: locationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the location model
   */
  readonly fields: locationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TeamLocation<T extends location$TeamLocationArgs<ExtArgs> = {}>(args?: Subset<T, location$TeamLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the location model
   */ 
  interface locationFieldRefs {
    readonly id: FieldRef<"location", 'Int'>
    readonly code: FieldRef<"location", 'String'>
    readonly name: FieldRef<"location", 'String'>
    readonly modifyBy: FieldRef<"location", 'String'>
    readonly createBy: FieldRef<"location", 'String'>
    readonly modifyDate: FieldRef<"location", 'DateTime'>
    readonly CCY: FieldRef<"location", 'String'>
    readonly Region: FieldRef<"location", 'String'>
    readonly Remarks: FieldRef<"location", 'String'>
    readonly WCI_URL: FieldRef<"location", 'String'>
    readonly createDate: FieldRef<"location", 'DateTime'>
    readonly fullname: FieldRef<"location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * location findUnique
   */
  export type locationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findUniqueOrThrow
   */
  export type locationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findFirst
   */
  export type locationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findFirstOrThrow
   */
  export type locationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findMany
   */
  export type locationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location create
   */
  export type locationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to create a location.
     */
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }

  /**
   * location createMany
   */
  export type locationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationCreateManyInput | locationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location createManyAndReturn
   */
  export type locationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * The data used to create many locations.
     */
    data: locationCreateManyInput | locationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location update
   */
  export type locationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to update a location.
     */
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location updateMany
   */
  export type locationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * location updateManyAndReturn
   */
  export type locationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * location upsert
   */
  export type locationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The filter to search for the location to update in case it exists.
     */
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     */
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }

  /**
   * location delete
   */
  export type locationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter which location to delete.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * location.TeamLocation
   */
  export type location$TeamLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    where?: TeamLocationWhereInput
    orderBy?: TeamLocationOrderByWithRelationInput | TeamLocationOrderByWithRelationInput[]
    cursor?: TeamLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamLocationScalarFieldEnum | TeamLocationScalarFieldEnum[]
  }

  /**
   * location without action
   */
  export type locationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
  }


  /**
   * Model ldapuser
   */

  export type AggregateLdapuser = {
    _count: LdapuserCountAggregateOutputType | null
    _avg: LdapuserAvgAggregateOutputType | null
    _sum: LdapuserSumAggregateOutputType | null
    _min: LdapuserMinAggregateOutputType | null
    _max: LdapuserMaxAggregateOutputType | null
  }

  export type LdapuserAvgAggregateOutputType = {
    instanceType: number | null
    whenCreated: number | null
    uSNCreated: number | null
    badPwdCount: number | null
    codePage: number | null
    countryCode: number | null
    badPasswordTime: number | null
    lastLogoff: number | null
    lastLogon: number | null
    primaryGroupID: number | null
    accountExpires: number | null
    logonCount: number | null
    sAMAccountType: number | null
    pwdLastSet: number | null
    userAccountControl: number | null
    whenChanged: number | null
    uSNChanged: number | null
    adminCount: number | null
    id: number | null
  }

  export type LdapuserSumAggregateOutputType = {
    instanceType: number | null
    whenCreated: bigint | null
    uSNCreated: number | null
    badPwdCount: number | null
    codePage: number | null
    countryCode: number | null
    badPasswordTime: bigint | null
    lastLogoff: bigint | null
    lastLogon: bigint | null
    primaryGroupID: number | null
    accountExpires: bigint | null
    logonCount: number | null
    sAMAccountType: number | null
    pwdLastSet: bigint | null
    userAccountControl: number | null
    whenChanged: bigint | null
    uSNChanged: number | null
    adminCount: number | null
    id: number | null
  }

  export type LdapuserMinAggregateOutputType = {
    dn: string | null
    cn: string | null
    sn: string | null
    givenName: string | null
    instanceType: number | null
    whenCreated: bigint | null
    displayName: string | null
    uSNCreated: number | null
    name: string | null
    objectGUID: string | null
    badPwdCount: number | null
    codePage: number | null
    countryCode: number | null
    badPasswordTime: bigint | null
    lastLogoff: bigint | null
    lastLogon: bigint | null
    primaryGroupID: number | null
    objectSid: string | null
    accountExpires: bigint | null
    logonCount: number | null
    sAMAccountName: string | null
    sAMAccountType: number | null
    userPrincipalName: string | null
    objectCategory: string | null
    pwdLastSet: bigint | null
    userAccountControl: number | null
    whenChanged: bigint | null
    uSNChanged: number | null
    distinguishedName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    adminCount: number | null
    description: string | null
    isCriticalSystemObject: boolean | null
    memberOf: string | null
    servicePrincipalName: string | null
    showInAdvancedViewOnly: boolean | null
    id: number | null
  }

  export type LdapuserMaxAggregateOutputType = {
    dn: string | null
    cn: string | null
    sn: string | null
    givenName: string | null
    instanceType: number | null
    whenCreated: bigint | null
    displayName: string | null
    uSNCreated: number | null
    name: string | null
    objectGUID: string | null
    badPwdCount: number | null
    codePage: number | null
    countryCode: number | null
    badPasswordTime: bigint | null
    lastLogoff: bigint | null
    lastLogon: bigint | null
    primaryGroupID: number | null
    objectSid: string | null
    accountExpires: bigint | null
    logonCount: number | null
    sAMAccountName: string | null
    sAMAccountType: number | null
    userPrincipalName: string | null
    objectCategory: string | null
    pwdLastSet: bigint | null
    userAccountControl: number | null
    whenChanged: bigint | null
    uSNChanged: number | null
    distinguishedName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    adminCount: number | null
    description: string | null
    isCriticalSystemObject: boolean | null
    memberOf: string | null
    servicePrincipalName: string | null
    showInAdvancedViewOnly: boolean | null
    id: number | null
  }

  export type LdapuserCountAggregateOutputType = {
    dn: number
    objectClass: number
    cn: number
    sn: number
    givenName: number
    instanceType: number
    whenCreated: number
    displayName: number
    uSNCreated: number
    name: number
    objectGUID: number
    badPwdCount: number
    codePage: number
    countryCode: number
    badPasswordTime: number
    lastLogoff: number
    lastLogon: number
    primaryGroupID: number
    objectSid: number
    accountExpires: number
    logonCount: number
    sAMAccountName: number
    sAMAccountType: number
    userPrincipalName: number
    objectCategory: number
    pwdLastSet: number
    userAccountControl: number
    whenChanged: number
    uSNChanged: number
    distinguishedName: number
    createdAt: number
    updatedAt: number
    adminCount: number
    description: number
    isCriticalSystemObject: number
    memberOf: number
    servicePrincipalName: number
    showInAdvancedViewOnly: number
    id: number
    _all: number
  }


  export type LdapuserAvgAggregateInputType = {
    instanceType?: true
    whenCreated?: true
    uSNCreated?: true
    badPwdCount?: true
    codePage?: true
    countryCode?: true
    badPasswordTime?: true
    lastLogoff?: true
    lastLogon?: true
    primaryGroupID?: true
    accountExpires?: true
    logonCount?: true
    sAMAccountType?: true
    pwdLastSet?: true
    userAccountControl?: true
    whenChanged?: true
    uSNChanged?: true
    adminCount?: true
    id?: true
  }

  export type LdapuserSumAggregateInputType = {
    instanceType?: true
    whenCreated?: true
    uSNCreated?: true
    badPwdCount?: true
    codePage?: true
    countryCode?: true
    badPasswordTime?: true
    lastLogoff?: true
    lastLogon?: true
    primaryGroupID?: true
    accountExpires?: true
    logonCount?: true
    sAMAccountType?: true
    pwdLastSet?: true
    userAccountControl?: true
    whenChanged?: true
    uSNChanged?: true
    adminCount?: true
    id?: true
  }

  export type LdapuserMinAggregateInputType = {
    dn?: true
    cn?: true
    sn?: true
    givenName?: true
    instanceType?: true
    whenCreated?: true
    displayName?: true
    uSNCreated?: true
    name?: true
    objectGUID?: true
    badPwdCount?: true
    codePage?: true
    countryCode?: true
    badPasswordTime?: true
    lastLogoff?: true
    lastLogon?: true
    primaryGroupID?: true
    objectSid?: true
    accountExpires?: true
    logonCount?: true
    sAMAccountName?: true
    sAMAccountType?: true
    userPrincipalName?: true
    objectCategory?: true
    pwdLastSet?: true
    userAccountControl?: true
    whenChanged?: true
    uSNChanged?: true
    distinguishedName?: true
    createdAt?: true
    updatedAt?: true
    adminCount?: true
    description?: true
    isCriticalSystemObject?: true
    memberOf?: true
    servicePrincipalName?: true
    showInAdvancedViewOnly?: true
    id?: true
  }

  export type LdapuserMaxAggregateInputType = {
    dn?: true
    cn?: true
    sn?: true
    givenName?: true
    instanceType?: true
    whenCreated?: true
    displayName?: true
    uSNCreated?: true
    name?: true
    objectGUID?: true
    badPwdCount?: true
    codePage?: true
    countryCode?: true
    badPasswordTime?: true
    lastLogoff?: true
    lastLogon?: true
    primaryGroupID?: true
    objectSid?: true
    accountExpires?: true
    logonCount?: true
    sAMAccountName?: true
    sAMAccountType?: true
    userPrincipalName?: true
    objectCategory?: true
    pwdLastSet?: true
    userAccountControl?: true
    whenChanged?: true
    uSNChanged?: true
    distinguishedName?: true
    createdAt?: true
    updatedAt?: true
    adminCount?: true
    description?: true
    isCriticalSystemObject?: true
    memberOf?: true
    servicePrincipalName?: true
    showInAdvancedViewOnly?: true
    id?: true
  }

  export type LdapuserCountAggregateInputType = {
    dn?: true
    objectClass?: true
    cn?: true
    sn?: true
    givenName?: true
    instanceType?: true
    whenCreated?: true
    displayName?: true
    uSNCreated?: true
    name?: true
    objectGUID?: true
    badPwdCount?: true
    codePage?: true
    countryCode?: true
    badPasswordTime?: true
    lastLogoff?: true
    lastLogon?: true
    primaryGroupID?: true
    objectSid?: true
    accountExpires?: true
    logonCount?: true
    sAMAccountName?: true
    sAMAccountType?: true
    userPrincipalName?: true
    objectCategory?: true
    pwdLastSet?: true
    userAccountControl?: true
    whenChanged?: true
    uSNChanged?: true
    distinguishedName?: true
    createdAt?: true
    updatedAt?: true
    adminCount?: true
    description?: true
    isCriticalSystemObject?: true
    memberOf?: true
    servicePrincipalName?: true
    showInAdvancedViewOnly?: true
    id?: true
    _all?: true
  }

  export type LdapuserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ldapuser to aggregate.
     */
    where?: ldapuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ldapusers to fetch.
     */
    orderBy?: ldapuserOrderByWithRelationInput | ldapuserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ldapuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ldapusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ldapusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ldapusers
    **/
    _count?: true | LdapuserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LdapuserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LdapuserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LdapuserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LdapuserMaxAggregateInputType
  }

  export type GetLdapuserAggregateType<T extends LdapuserAggregateArgs> = {
        [P in keyof T & keyof AggregateLdapuser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLdapuser[P]>
      : GetScalarType<T[P], AggregateLdapuser[P]>
  }




  export type ldapuserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ldapuserWhereInput
    orderBy?: ldapuserOrderByWithAggregationInput | ldapuserOrderByWithAggregationInput[]
    by: LdapuserScalarFieldEnum[] | LdapuserScalarFieldEnum
    having?: ldapuserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LdapuserCountAggregateInputType | true
    _avg?: LdapuserAvgAggregateInputType
    _sum?: LdapuserSumAggregateInputType
    _min?: LdapuserMinAggregateInputType
    _max?: LdapuserMaxAggregateInputType
  }

  export type LdapuserGroupByOutputType = {
    dn: string
    objectClass: string[]
    cn: string
    sn: string | null
    givenName: string | null
    instanceType: number
    whenCreated: bigint
    displayName: string | null
    uSNCreated: number
    name: string
    objectGUID: string
    badPwdCount: number | null
    codePage: number
    countryCode: number
    badPasswordTime: bigint | null
    lastLogoff: bigint | null
    lastLogon: bigint | null
    primaryGroupID: number
    objectSid: string
    accountExpires: bigint
    logonCount: number | null
    sAMAccountName: string
    sAMAccountType: number
    userPrincipalName: string | null
    objectCategory: string
    pwdLastSet: bigint
    userAccountControl: number
    whenChanged: bigint
    uSNChanged: number
    distinguishedName: string
    createdAt: Date
    updatedAt: Date
    adminCount: number | null
    description: string | null
    isCriticalSystemObject: boolean | null
    memberOf: string | null
    servicePrincipalName: string | null
    showInAdvancedViewOnly: boolean | null
    id: number
    _count: LdapuserCountAggregateOutputType | null
    _avg: LdapuserAvgAggregateOutputType | null
    _sum: LdapuserSumAggregateOutputType | null
    _min: LdapuserMinAggregateOutputType | null
    _max: LdapuserMaxAggregateOutputType | null
  }

  type GetLdapuserGroupByPayload<T extends ldapuserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LdapuserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LdapuserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LdapuserGroupByOutputType[P]>
            : GetScalarType<T[P], LdapuserGroupByOutputType[P]>
        }
      >
    >


  export type ldapuserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dn?: boolean
    objectClass?: boolean
    cn?: boolean
    sn?: boolean
    givenName?: boolean
    instanceType?: boolean
    whenCreated?: boolean
    displayName?: boolean
    uSNCreated?: boolean
    name?: boolean
    objectGUID?: boolean
    badPwdCount?: boolean
    codePage?: boolean
    countryCode?: boolean
    badPasswordTime?: boolean
    lastLogoff?: boolean
    lastLogon?: boolean
    primaryGroupID?: boolean
    objectSid?: boolean
    accountExpires?: boolean
    logonCount?: boolean
    sAMAccountName?: boolean
    sAMAccountType?: boolean
    userPrincipalName?: boolean
    objectCategory?: boolean
    pwdLastSet?: boolean
    userAccountControl?: boolean
    whenChanged?: boolean
    uSNChanged?: boolean
    distinguishedName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminCount?: boolean
    description?: boolean
    isCriticalSystemObject?: boolean
    memberOf?: boolean
    servicePrincipalName?: boolean
    showInAdvancedViewOnly?: boolean
    id?: boolean
  }, ExtArgs["result"]["ldapuser"]>

  export type ldapuserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dn?: boolean
    objectClass?: boolean
    cn?: boolean
    sn?: boolean
    givenName?: boolean
    instanceType?: boolean
    whenCreated?: boolean
    displayName?: boolean
    uSNCreated?: boolean
    name?: boolean
    objectGUID?: boolean
    badPwdCount?: boolean
    codePage?: boolean
    countryCode?: boolean
    badPasswordTime?: boolean
    lastLogoff?: boolean
    lastLogon?: boolean
    primaryGroupID?: boolean
    objectSid?: boolean
    accountExpires?: boolean
    logonCount?: boolean
    sAMAccountName?: boolean
    sAMAccountType?: boolean
    userPrincipalName?: boolean
    objectCategory?: boolean
    pwdLastSet?: boolean
    userAccountControl?: boolean
    whenChanged?: boolean
    uSNChanged?: boolean
    distinguishedName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminCount?: boolean
    description?: boolean
    isCriticalSystemObject?: boolean
    memberOf?: boolean
    servicePrincipalName?: boolean
    showInAdvancedViewOnly?: boolean
    id?: boolean
  }, ExtArgs["result"]["ldapuser"]>

  export type ldapuserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dn?: boolean
    objectClass?: boolean
    cn?: boolean
    sn?: boolean
    givenName?: boolean
    instanceType?: boolean
    whenCreated?: boolean
    displayName?: boolean
    uSNCreated?: boolean
    name?: boolean
    objectGUID?: boolean
    badPwdCount?: boolean
    codePage?: boolean
    countryCode?: boolean
    badPasswordTime?: boolean
    lastLogoff?: boolean
    lastLogon?: boolean
    primaryGroupID?: boolean
    objectSid?: boolean
    accountExpires?: boolean
    logonCount?: boolean
    sAMAccountName?: boolean
    sAMAccountType?: boolean
    userPrincipalName?: boolean
    objectCategory?: boolean
    pwdLastSet?: boolean
    userAccountControl?: boolean
    whenChanged?: boolean
    uSNChanged?: boolean
    distinguishedName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminCount?: boolean
    description?: boolean
    isCriticalSystemObject?: boolean
    memberOf?: boolean
    servicePrincipalName?: boolean
    showInAdvancedViewOnly?: boolean
    id?: boolean
  }, ExtArgs["result"]["ldapuser"]>

  export type ldapuserSelectScalar = {
    dn?: boolean
    objectClass?: boolean
    cn?: boolean
    sn?: boolean
    givenName?: boolean
    instanceType?: boolean
    whenCreated?: boolean
    displayName?: boolean
    uSNCreated?: boolean
    name?: boolean
    objectGUID?: boolean
    badPwdCount?: boolean
    codePage?: boolean
    countryCode?: boolean
    badPasswordTime?: boolean
    lastLogoff?: boolean
    lastLogon?: boolean
    primaryGroupID?: boolean
    objectSid?: boolean
    accountExpires?: boolean
    logonCount?: boolean
    sAMAccountName?: boolean
    sAMAccountType?: boolean
    userPrincipalName?: boolean
    objectCategory?: boolean
    pwdLastSet?: boolean
    userAccountControl?: boolean
    whenChanged?: boolean
    uSNChanged?: boolean
    distinguishedName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminCount?: boolean
    description?: boolean
    isCriticalSystemObject?: boolean
    memberOf?: boolean
    servicePrincipalName?: boolean
    showInAdvancedViewOnly?: boolean
    id?: boolean
  }

  export type ldapuserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dn" | "objectClass" | "cn" | "sn" | "givenName" | "instanceType" | "whenCreated" | "displayName" | "uSNCreated" | "name" | "objectGUID" | "badPwdCount" | "codePage" | "countryCode" | "badPasswordTime" | "lastLogoff" | "lastLogon" | "primaryGroupID" | "objectSid" | "accountExpires" | "logonCount" | "sAMAccountName" | "sAMAccountType" | "userPrincipalName" | "objectCategory" | "pwdLastSet" | "userAccountControl" | "whenChanged" | "uSNChanged" | "distinguishedName" | "createdAt" | "updatedAt" | "adminCount" | "description" | "isCriticalSystemObject" | "memberOf" | "servicePrincipalName" | "showInAdvancedViewOnly" | "id", ExtArgs["result"]["ldapuser"]>

  export type $ldapuserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ldapuser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      dn: string
      objectClass: string[]
      cn: string
      sn: string | null
      givenName: string | null
      instanceType: number
      whenCreated: bigint
      displayName: string | null
      uSNCreated: number
      name: string
      objectGUID: string
      badPwdCount: number | null
      codePage: number
      countryCode: number
      badPasswordTime: bigint | null
      lastLogoff: bigint | null
      lastLogon: bigint | null
      primaryGroupID: number
      objectSid: string
      accountExpires: bigint
      logonCount: number | null
      sAMAccountName: string
      sAMAccountType: number
      userPrincipalName: string | null
      objectCategory: string
      pwdLastSet: bigint
      userAccountControl: number
      whenChanged: bigint
      uSNChanged: number
      distinguishedName: string
      createdAt: Date
      updatedAt: Date
      adminCount: number | null
      description: string | null
      isCriticalSystemObject: boolean | null
      memberOf: string | null
      servicePrincipalName: string | null
      showInAdvancedViewOnly: boolean | null
      id: number
    }, ExtArgs["result"]["ldapuser"]>
    composites: {}
  }

  type ldapuserGetPayload<S extends boolean | null | undefined | ldapuserDefaultArgs> = $Result.GetResult<Prisma.$ldapuserPayload, S>

  type ldapuserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ldapuserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LdapuserCountAggregateInputType | true
    }

  export interface ldapuserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ldapuser'], meta: { name: 'ldapuser' } }
    /**
     * Find zero or one Ldapuser that matches the filter.
     * @param {ldapuserFindUniqueArgs} args - Arguments to find a Ldapuser
     * @example
     * // Get one Ldapuser
     * const ldapuser = await prisma.ldapuser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ldapuserFindUniqueArgs>(args: SelectSubset<T, ldapuserFindUniqueArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ldapuser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ldapuserFindUniqueOrThrowArgs} args - Arguments to find a Ldapuser
     * @example
     * // Get one Ldapuser
     * const ldapuser = await prisma.ldapuser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ldapuserFindUniqueOrThrowArgs>(args: SelectSubset<T, ldapuserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ldapuser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ldapuserFindFirstArgs} args - Arguments to find a Ldapuser
     * @example
     * // Get one Ldapuser
     * const ldapuser = await prisma.ldapuser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ldapuserFindFirstArgs>(args?: SelectSubset<T, ldapuserFindFirstArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ldapuser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ldapuserFindFirstOrThrowArgs} args - Arguments to find a Ldapuser
     * @example
     * // Get one Ldapuser
     * const ldapuser = await prisma.ldapuser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ldapuserFindFirstOrThrowArgs>(args?: SelectSubset<T, ldapuserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ldapusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ldapuserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ldapusers
     * const ldapusers = await prisma.ldapuser.findMany()
     * 
     * // Get first 10 Ldapusers
     * const ldapusers = await prisma.ldapuser.findMany({ take: 10 })
     * 
     * // Only select the `dn`
     * const ldapuserWithDnOnly = await prisma.ldapuser.findMany({ select: { dn: true } })
     * 
     */
    findMany<T extends ldapuserFindManyArgs>(args?: SelectSubset<T, ldapuserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ldapuser.
     * @param {ldapuserCreateArgs} args - Arguments to create a Ldapuser.
     * @example
     * // Create one Ldapuser
     * const Ldapuser = await prisma.ldapuser.create({
     *   data: {
     *     // ... data to create a Ldapuser
     *   }
     * })
     * 
     */
    create<T extends ldapuserCreateArgs>(args: SelectSubset<T, ldapuserCreateArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ldapusers.
     * @param {ldapuserCreateManyArgs} args - Arguments to create many Ldapusers.
     * @example
     * // Create many Ldapusers
     * const ldapuser = await prisma.ldapuser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ldapuserCreateManyArgs>(args?: SelectSubset<T, ldapuserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ldapusers and returns the data saved in the database.
     * @param {ldapuserCreateManyAndReturnArgs} args - Arguments to create many Ldapusers.
     * @example
     * // Create many Ldapusers
     * const ldapuser = await prisma.ldapuser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ldapusers and only return the `dn`
     * const ldapuserWithDnOnly = await prisma.ldapuser.createManyAndReturn({
     *   select: { dn: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ldapuserCreateManyAndReturnArgs>(args?: SelectSubset<T, ldapuserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ldapuser.
     * @param {ldapuserDeleteArgs} args - Arguments to delete one Ldapuser.
     * @example
     * // Delete one Ldapuser
     * const Ldapuser = await prisma.ldapuser.delete({
     *   where: {
     *     // ... filter to delete one Ldapuser
     *   }
     * })
     * 
     */
    delete<T extends ldapuserDeleteArgs>(args: SelectSubset<T, ldapuserDeleteArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ldapuser.
     * @param {ldapuserUpdateArgs} args - Arguments to update one Ldapuser.
     * @example
     * // Update one Ldapuser
     * const ldapuser = await prisma.ldapuser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ldapuserUpdateArgs>(args: SelectSubset<T, ldapuserUpdateArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ldapusers.
     * @param {ldapuserDeleteManyArgs} args - Arguments to filter Ldapusers to delete.
     * @example
     * // Delete a few Ldapusers
     * const { count } = await prisma.ldapuser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ldapuserDeleteManyArgs>(args?: SelectSubset<T, ldapuserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ldapusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ldapuserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ldapusers
     * const ldapuser = await prisma.ldapuser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ldapuserUpdateManyArgs>(args: SelectSubset<T, ldapuserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ldapusers and returns the data updated in the database.
     * @param {ldapuserUpdateManyAndReturnArgs} args - Arguments to update many Ldapusers.
     * @example
     * // Update many Ldapusers
     * const ldapuser = await prisma.ldapuser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ldapusers and only return the `dn`
     * const ldapuserWithDnOnly = await prisma.ldapuser.updateManyAndReturn({
     *   select: { dn: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ldapuserUpdateManyAndReturnArgs>(args: SelectSubset<T, ldapuserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ldapuser.
     * @param {ldapuserUpsertArgs} args - Arguments to update or create a Ldapuser.
     * @example
     * // Update or create a Ldapuser
     * const ldapuser = await prisma.ldapuser.upsert({
     *   create: {
     *     // ... data to create a Ldapuser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ldapuser we want to update
     *   }
     * })
     */
    upsert<T extends ldapuserUpsertArgs>(args: SelectSubset<T, ldapuserUpsertArgs<ExtArgs>>): Prisma__ldapuserClient<$Result.GetResult<Prisma.$ldapuserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ldapusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ldapuserCountArgs} args - Arguments to filter Ldapusers to count.
     * @example
     * // Count the number of Ldapusers
     * const count = await prisma.ldapuser.count({
     *   where: {
     *     // ... the filter for the Ldapusers we want to count
     *   }
     * })
    **/
    count<T extends ldapuserCountArgs>(
      args?: Subset<T, ldapuserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LdapuserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ldapuser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LdapuserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LdapuserAggregateArgs>(args: Subset<T, LdapuserAggregateArgs>): Prisma.PrismaPromise<GetLdapuserAggregateType<T>>

    /**
     * Group by Ldapuser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ldapuserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ldapuserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ldapuserGroupByArgs['orderBy'] }
        : { orderBy?: ldapuserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ldapuserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLdapuserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ldapuser model
   */
  readonly fields: ldapuserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ldapuser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ldapuserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ldapuser model
   */ 
  interface ldapuserFieldRefs {
    readonly dn: FieldRef<"ldapuser", 'String'>
    readonly objectClass: FieldRef<"ldapuser", 'String[]'>
    readonly cn: FieldRef<"ldapuser", 'String'>
    readonly sn: FieldRef<"ldapuser", 'String'>
    readonly givenName: FieldRef<"ldapuser", 'String'>
    readonly instanceType: FieldRef<"ldapuser", 'Int'>
    readonly whenCreated: FieldRef<"ldapuser", 'BigInt'>
    readonly displayName: FieldRef<"ldapuser", 'String'>
    readonly uSNCreated: FieldRef<"ldapuser", 'Int'>
    readonly name: FieldRef<"ldapuser", 'String'>
    readonly objectGUID: FieldRef<"ldapuser", 'String'>
    readonly badPwdCount: FieldRef<"ldapuser", 'Int'>
    readonly codePage: FieldRef<"ldapuser", 'Int'>
    readonly countryCode: FieldRef<"ldapuser", 'Int'>
    readonly badPasswordTime: FieldRef<"ldapuser", 'BigInt'>
    readonly lastLogoff: FieldRef<"ldapuser", 'BigInt'>
    readonly lastLogon: FieldRef<"ldapuser", 'BigInt'>
    readonly primaryGroupID: FieldRef<"ldapuser", 'Int'>
    readonly objectSid: FieldRef<"ldapuser", 'String'>
    readonly accountExpires: FieldRef<"ldapuser", 'BigInt'>
    readonly logonCount: FieldRef<"ldapuser", 'Int'>
    readonly sAMAccountName: FieldRef<"ldapuser", 'String'>
    readonly sAMAccountType: FieldRef<"ldapuser", 'Int'>
    readonly userPrincipalName: FieldRef<"ldapuser", 'String'>
    readonly objectCategory: FieldRef<"ldapuser", 'String'>
    readonly pwdLastSet: FieldRef<"ldapuser", 'BigInt'>
    readonly userAccountControl: FieldRef<"ldapuser", 'Int'>
    readonly whenChanged: FieldRef<"ldapuser", 'BigInt'>
    readonly uSNChanged: FieldRef<"ldapuser", 'Int'>
    readonly distinguishedName: FieldRef<"ldapuser", 'String'>
    readonly createdAt: FieldRef<"ldapuser", 'DateTime'>
    readonly updatedAt: FieldRef<"ldapuser", 'DateTime'>
    readonly adminCount: FieldRef<"ldapuser", 'Int'>
    readonly description: FieldRef<"ldapuser", 'String'>
    readonly isCriticalSystemObject: FieldRef<"ldapuser", 'Boolean'>
    readonly memberOf: FieldRef<"ldapuser", 'String'>
    readonly servicePrincipalName: FieldRef<"ldapuser", 'String'>
    readonly showInAdvancedViewOnly: FieldRef<"ldapuser", 'Boolean'>
    readonly id: FieldRef<"ldapuser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ldapuser findUnique
   */
  export type ldapuserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * Filter, which ldapuser to fetch.
     */
    where: ldapuserWhereUniqueInput
  }

  /**
   * ldapuser findUniqueOrThrow
   */
  export type ldapuserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * Filter, which ldapuser to fetch.
     */
    where: ldapuserWhereUniqueInput
  }

  /**
   * ldapuser findFirst
   */
  export type ldapuserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * Filter, which ldapuser to fetch.
     */
    where?: ldapuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ldapusers to fetch.
     */
    orderBy?: ldapuserOrderByWithRelationInput | ldapuserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ldapusers.
     */
    cursor?: ldapuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ldapusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ldapusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ldapusers.
     */
    distinct?: LdapuserScalarFieldEnum | LdapuserScalarFieldEnum[]
  }

  /**
   * ldapuser findFirstOrThrow
   */
  export type ldapuserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * Filter, which ldapuser to fetch.
     */
    where?: ldapuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ldapusers to fetch.
     */
    orderBy?: ldapuserOrderByWithRelationInput | ldapuserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ldapusers.
     */
    cursor?: ldapuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ldapusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ldapusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ldapusers.
     */
    distinct?: LdapuserScalarFieldEnum | LdapuserScalarFieldEnum[]
  }

  /**
   * ldapuser findMany
   */
  export type ldapuserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * Filter, which ldapusers to fetch.
     */
    where?: ldapuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ldapusers to fetch.
     */
    orderBy?: ldapuserOrderByWithRelationInput | ldapuserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ldapusers.
     */
    cursor?: ldapuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ldapusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ldapusers.
     */
    skip?: number
    distinct?: LdapuserScalarFieldEnum | LdapuserScalarFieldEnum[]
  }

  /**
   * ldapuser create
   */
  export type ldapuserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * The data needed to create a ldapuser.
     */
    data: XOR<ldapuserCreateInput, ldapuserUncheckedCreateInput>
  }

  /**
   * ldapuser createMany
   */
  export type ldapuserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ldapusers.
     */
    data: ldapuserCreateManyInput | ldapuserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ldapuser createManyAndReturn
   */
  export type ldapuserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * The data used to create many ldapusers.
     */
    data: ldapuserCreateManyInput | ldapuserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ldapuser update
   */
  export type ldapuserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * The data needed to update a ldapuser.
     */
    data: XOR<ldapuserUpdateInput, ldapuserUncheckedUpdateInput>
    /**
     * Choose, which ldapuser to update.
     */
    where: ldapuserWhereUniqueInput
  }

  /**
   * ldapuser updateMany
   */
  export type ldapuserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ldapusers.
     */
    data: XOR<ldapuserUpdateManyMutationInput, ldapuserUncheckedUpdateManyInput>
    /**
     * Filter which ldapusers to update
     */
    where?: ldapuserWhereInput
    /**
     * Limit how many ldapusers to update.
     */
    limit?: number
  }

  /**
   * ldapuser updateManyAndReturn
   */
  export type ldapuserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * The data used to update ldapusers.
     */
    data: XOR<ldapuserUpdateManyMutationInput, ldapuserUncheckedUpdateManyInput>
    /**
     * Filter which ldapusers to update
     */
    where?: ldapuserWhereInput
    /**
     * Limit how many ldapusers to update.
     */
    limit?: number
  }

  /**
   * ldapuser upsert
   */
  export type ldapuserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * The filter to search for the ldapuser to update in case it exists.
     */
    where: ldapuserWhereUniqueInput
    /**
     * In case the ldapuser found by the `where` argument doesn't exist, create a new ldapuser with this data.
     */
    create: XOR<ldapuserCreateInput, ldapuserUncheckedCreateInput>
    /**
     * In case the ldapuser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ldapuserUpdateInput, ldapuserUncheckedUpdateInput>
  }

  /**
   * ldapuser delete
   */
  export type ldapuserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
    /**
     * Filter which ldapuser to delete.
     */
    where: ldapuserWhereUniqueInput
  }

  /**
   * ldapuser deleteMany
   */
  export type ldapuserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ldapusers to delete
     */
    where?: ldapuserWhereInput
    /**
     * Limit how many ldapusers to delete.
     */
    limit?: number
  }

  /**
   * ldapuser without action
   */
  export type ldapuserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ldapuser
     */
    select?: ldapuserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ldapuser
     */
    omit?: ldapuserOmit<ExtArgs> | null
  }


  /**
   * Model DriveFolder
   */

  export type AggregateDriveFolder = {
    _count: DriveFolderCountAggregateOutputType | null
    _avg: DriveFolderAvgAggregateOutputType | null
    _sum: DriveFolderSumAggregateOutputType | null
    _min: DriveFolderMinAggregateOutputType | null
    _max: DriveFolderMaxAggregateOutputType | null
  }

  export type DriveFolderAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    ownerId: number | null
  }

  export type DriveFolderSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    ownerId: number | null
  }

  export type DriveFolderMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    ownerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriveFolderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    ownerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriveFolderCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriveFolderAvgAggregateInputType = {
    id?: true
    parentId?: true
    ownerId?: true
  }

  export type DriveFolderSumAggregateInputType = {
    id?: true
    parentId?: true
    ownerId?: true
  }

  export type DriveFolderMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriveFolderMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriveFolderCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriveFolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriveFolder to aggregate.
     */
    where?: DriveFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFolders to fetch.
     */
    orderBy?: DriveFolderOrderByWithRelationInput | DriveFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriveFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriveFolders
    **/
    _count?: true | DriveFolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriveFolderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriveFolderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriveFolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriveFolderMaxAggregateInputType
  }

  export type GetDriveFolderAggregateType<T extends DriveFolderAggregateArgs> = {
        [P in keyof T & keyof AggregateDriveFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriveFolder[P]>
      : GetScalarType<T[P], AggregateDriveFolder[P]>
  }




  export type DriveFolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFolderWhereInput
    orderBy?: DriveFolderOrderByWithAggregationInput | DriveFolderOrderByWithAggregationInput[]
    by: DriveFolderScalarFieldEnum[] | DriveFolderScalarFieldEnum
    having?: DriveFolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriveFolderCountAggregateInputType | true
    _avg?: DriveFolderAvgAggregateInputType
    _sum?: DriveFolderSumAggregateInputType
    _min?: DriveFolderMinAggregateInputType
    _max?: DriveFolderMaxAggregateInputType
  }

  export type DriveFolderGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    ownerId: number
    createdAt: Date
    updatedAt: Date
    _count: DriveFolderCountAggregateOutputType | null
    _avg: DriveFolderAvgAggregateOutputType | null
    _sum: DriveFolderSumAggregateOutputType | null
    _min: DriveFolderMinAggregateOutputType | null
    _max: DriveFolderMaxAggregateOutputType | null
  }

  type GetDriveFolderGroupByPayload<T extends DriveFolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriveFolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriveFolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriveFolderGroupByOutputType[P]>
            : GetScalarType<T[P], DriveFolderGroupByOutputType[P]>
        }
      >
    >


  export type DriveFolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    files?: boolean | DriveFolder$filesArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | DriveFolder$parentArgs<ExtArgs>
    children?: boolean | DriveFolder$childrenArgs<ExtArgs>
    _count?: boolean | DriveFolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFolder"]>

  export type DriveFolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | DriveFolder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["driveFolder"]>

  export type DriveFolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | DriveFolder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["driveFolder"]>

  export type DriveFolderSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriveFolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["driveFolder"]>
  export type DriveFolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | DriveFolder$filesArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | DriveFolder$parentArgs<ExtArgs>
    children?: boolean | DriveFolder$childrenArgs<ExtArgs>
    _count?: boolean | DriveFolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriveFolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | DriveFolder$parentArgs<ExtArgs>
  }
  export type DriveFolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | DriveFolder$parentArgs<ExtArgs>
  }

  export type $DriveFolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriveFolder"
    objects: {
      files: Prisma.$DriveFilePayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$DriveFolderPayload<ExtArgs> | null
      children: Prisma.$DriveFolderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parentId: number | null
      ownerId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driveFolder"]>
    composites: {}
  }

  type DriveFolderGetPayload<S extends boolean | null | undefined | DriveFolderDefaultArgs> = $Result.GetResult<Prisma.$DriveFolderPayload, S>

  type DriveFolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriveFolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriveFolderCountAggregateInputType | true
    }

  export interface DriveFolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriveFolder'], meta: { name: 'DriveFolder' } }
    /**
     * Find zero or one DriveFolder that matches the filter.
     * @param {DriveFolderFindUniqueArgs} args - Arguments to find a DriveFolder
     * @example
     * // Get one DriveFolder
     * const driveFolder = await prisma.driveFolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriveFolderFindUniqueArgs>(args: SelectSubset<T, DriveFolderFindUniqueArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DriveFolder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriveFolderFindUniqueOrThrowArgs} args - Arguments to find a DriveFolder
     * @example
     * // Get one DriveFolder
     * const driveFolder = await prisma.driveFolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriveFolderFindUniqueOrThrowArgs>(args: SelectSubset<T, DriveFolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DriveFolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderFindFirstArgs} args - Arguments to find a DriveFolder
     * @example
     * // Get one DriveFolder
     * const driveFolder = await prisma.driveFolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriveFolderFindFirstArgs>(args?: SelectSubset<T, DriveFolderFindFirstArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DriveFolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderFindFirstOrThrowArgs} args - Arguments to find a DriveFolder
     * @example
     * // Get one DriveFolder
     * const driveFolder = await prisma.driveFolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriveFolderFindFirstOrThrowArgs>(args?: SelectSubset<T, DriveFolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DriveFolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriveFolders
     * const driveFolders = await prisma.driveFolder.findMany()
     * 
     * // Get first 10 DriveFolders
     * const driveFolders = await prisma.driveFolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driveFolderWithIdOnly = await prisma.driveFolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriveFolderFindManyArgs>(args?: SelectSubset<T, DriveFolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DriveFolder.
     * @param {DriveFolderCreateArgs} args - Arguments to create a DriveFolder.
     * @example
     * // Create one DriveFolder
     * const DriveFolder = await prisma.driveFolder.create({
     *   data: {
     *     // ... data to create a DriveFolder
     *   }
     * })
     * 
     */
    create<T extends DriveFolderCreateArgs>(args: SelectSubset<T, DriveFolderCreateArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DriveFolders.
     * @param {DriveFolderCreateManyArgs} args - Arguments to create many DriveFolders.
     * @example
     * // Create many DriveFolders
     * const driveFolder = await prisma.driveFolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriveFolderCreateManyArgs>(args?: SelectSubset<T, DriveFolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriveFolders and returns the data saved in the database.
     * @param {DriveFolderCreateManyAndReturnArgs} args - Arguments to create many DriveFolders.
     * @example
     * // Create many DriveFolders
     * const driveFolder = await prisma.driveFolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriveFolders and only return the `id`
     * const driveFolderWithIdOnly = await prisma.driveFolder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriveFolderCreateManyAndReturnArgs>(args?: SelectSubset<T, DriveFolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DriveFolder.
     * @param {DriveFolderDeleteArgs} args - Arguments to delete one DriveFolder.
     * @example
     * // Delete one DriveFolder
     * const DriveFolder = await prisma.driveFolder.delete({
     *   where: {
     *     // ... filter to delete one DriveFolder
     *   }
     * })
     * 
     */
    delete<T extends DriveFolderDeleteArgs>(args: SelectSubset<T, DriveFolderDeleteArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DriveFolder.
     * @param {DriveFolderUpdateArgs} args - Arguments to update one DriveFolder.
     * @example
     * // Update one DriveFolder
     * const driveFolder = await prisma.driveFolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriveFolderUpdateArgs>(args: SelectSubset<T, DriveFolderUpdateArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DriveFolders.
     * @param {DriveFolderDeleteManyArgs} args - Arguments to filter DriveFolders to delete.
     * @example
     * // Delete a few DriveFolders
     * const { count } = await prisma.driveFolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriveFolderDeleteManyArgs>(args?: SelectSubset<T, DriveFolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriveFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriveFolders
     * const driveFolder = await prisma.driveFolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriveFolderUpdateManyArgs>(args: SelectSubset<T, DriveFolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriveFolders and returns the data updated in the database.
     * @param {DriveFolderUpdateManyAndReturnArgs} args - Arguments to update many DriveFolders.
     * @example
     * // Update many DriveFolders
     * const driveFolder = await prisma.driveFolder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriveFolders and only return the `id`
     * const driveFolderWithIdOnly = await prisma.driveFolder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriveFolderUpdateManyAndReturnArgs>(args: SelectSubset<T, DriveFolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DriveFolder.
     * @param {DriveFolderUpsertArgs} args - Arguments to update or create a DriveFolder.
     * @example
     * // Update or create a DriveFolder
     * const driveFolder = await prisma.driveFolder.upsert({
     *   create: {
     *     // ... data to create a DriveFolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriveFolder we want to update
     *   }
     * })
     */
    upsert<T extends DriveFolderUpsertArgs>(args: SelectSubset<T, DriveFolderUpsertArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DriveFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderCountArgs} args - Arguments to filter DriveFolders to count.
     * @example
     * // Count the number of DriveFolders
     * const count = await prisma.driveFolder.count({
     *   where: {
     *     // ... the filter for the DriveFolders we want to count
     *   }
     * })
    **/
    count<T extends DriveFolderCountArgs>(
      args?: Subset<T, DriveFolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriveFolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriveFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriveFolderAggregateArgs>(args: Subset<T, DriveFolderAggregateArgs>): Prisma.PrismaPromise<GetDriveFolderAggregateType<T>>

    /**
     * Group by DriveFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriveFolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriveFolderGroupByArgs['orderBy'] }
        : { orderBy?: DriveFolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriveFolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriveFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriveFolder model
   */
  readonly fields: DriveFolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriveFolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriveFolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends DriveFolder$filesArgs<ExtArgs> = {}>(args?: Subset<T, DriveFolder$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    parent<T extends DriveFolder$parentArgs<ExtArgs> = {}>(args?: Subset<T, DriveFolder$parentArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    children<T extends DriveFolder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, DriveFolder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriveFolder model
   */ 
  interface DriveFolderFieldRefs {
    readonly id: FieldRef<"DriveFolder", 'Int'>
    readonly name: FieldRef<"DriveFolder", 'String'>
    readonly parentId: FieldRef<"DriveFolder", 'Int'>
    readonly ownerId: FieldRef<"DriveFolder", 'Int'>
    readonly createdAt: FieldRef<"DriveFolder", 'DateTime'>
    readonly updatedAt: FieldRef<"DriveFolder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriveFolder findUnique
   */
  export type DriveFolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * Filter, which DriveFolder to fetch.
     */
    where: DriveFolderWhereUniqueInput
  }

  /**
   * DriveFolder findUniqueOrThrow
   */
  export type DriveFolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * Filter, which DriveFolder to fetch.
     */
    where: DriveFolderWhereUniqueInput
  }

  /**
   * DriveFolder findFirst
   */
  export type DriveFolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * Filter, which DriveFolder to fetch.
     */
    where?: DriveFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFolders to fetch.
     */
    orderBy?: DriveFolderOrderByWithRelationInput | DriveFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriveFolders.
     */
    cursor?: DriveFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriveFolders.
     */
    distinct?: DriveFolderScalarFieldEnum | DriveFolderScalarFieldEnum[]
  }

  /**
   * DriveFolder findFirstOrThrow
   */
  export type DriveFolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * Filter, which DriveFolder to fetch.
     */
    where?: DriveFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFolders to fetch.
     */
    orderBy?: DriveFolderOrderByWithRelationInput | DriveFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriveFolders.
     */
    cursor?: DriveFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriveFolders.
     */
    distinct?: DriveFolderScalarFieldEnum | DriveFolderScalarFieldEnum[]
  }

  /**
   * DriveFolder findMany
   */
  export type DriveFolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * Filter, which DriveFolders to fetch.
     */
    where?: DriveFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFolders to fetch.
     */
    orderBy?: DriveFolderOrderByWithRelationInput | DriveFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriveFolders.
     */
    cursor?: DriveFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFolders.
     */
    skip?: number
    distinct?: DriveFolderScalarFieldEnum | DriveFolderScalarFieldEnum[]
  }

  /**
   * DriveFolder create
   */
  export type DriveFolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * The data needed to create a DriveFolder.
     */
    data: XOR<DriveFolderCreateInput, DriveFolderUncheckedCreateInput>
  }

  /**
   * DriveFolder createMany
   */
  export type DriveFolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriveFolders.
     */
    data: DriveFolderCreateManyInput | DriveFolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriveFolder createManyAndReturn
   */
  export type DriveFolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * The data used to create many DriveFolders.
     */
    data: DriveFolderCreateManyInput | DriveFolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriveFolder update
   */
  export type DriveFolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * The data needed to update a DriveFolder.
     */
    data: XOR<DriveFolderUpdateInput, DriveFolderUncheckedUpdateInput>
    /**
     * Choose, which DriveFolder to update.
     */
    where: DriveFolderWhereUniqueInput
  }

  /**
   * DriveFolder updateMany
   */
  export type DriveFolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriveFolders.
     */
    data: XOR<DriveFolderUpdateManyMutationInput, DriveFolderUncheckedUpdateManyInput>
    /**
     * Filter which DriveFolders to update
     */
    where?: DriveFolderWhereInput
    /**
     * Limit how many DriveFolders to update.
     */
    limit?: number
  }

  /**
   * DriveFolder updateManyAndReturn
   */
  export type DriveFolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * The data used to update DriveFolders.
     */
    data: XOR<DriveFolderUpdateManyMutationInput, DriveFolderUncheckedUpdateManyInput>
    /**
     * Filter which DriveFolders to update
     */
    where?: DriveFolderWhereInput
    /**
     * Limit how many DriveFolders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriveFolder upsert
   */
  export type DriveFolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * The filter to search for the DriveFolder to update in case it exists.
     */
    where: DriveFolderWhereUniqueInput
    /**
     * In case the DriveFolder found by the `where` argument doesn't exist, create a new DriveFolder with this data.
     */
    create: XOR<DriveFolderCreateInput, DriveFolderUncheckedCreateInput>
    /**
     * In case the DriveFolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriveFolderUpdateInput, DriveFolderUncheckedUpdateInput>
  }

  /**
   * DriveFolder delete
   */
  export type DriveFolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    /**
     * Filter which DriveFolder to delete.
     */
    where: DriveFolderWhereUniqueInput
  }

  /**
   * DriveFolder deleteMany
   */
  export type DriveFolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriveFolders to delete
     */
    where?: DriveFolderWhereInput
    /**
     * Limit how many DriveFolders to delete.
     */
    limit?: number
  }

  /**
   * DriveFolder.files
   */
  export type DriveFolder$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    where?: DriveFileWhereInput
    orderBy?: DriveFileOrderByWithRelationInput | DriveFileOrderByWithRelationInput[]
    cursor?: DriveFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFileScalarFieldEnum | DriveFileScalarFieldEnum[]
  }

  /**
   * DriveFolder.parent
   */
  export type DriveFolder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    where?: DriveFolderWhereInput
  }

  /**
   * DriveFolder.children
   */
  export type DriveFolder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    where?: DriveFolderWhereInput
    orderBy?: DriveFolderOrderByWithRelationInput | DriveFolderOrderByWithRelationInput[]
    cursor?: DriveFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFolderScalarFieldEnum | DriveFolderScalarFieldEnum[]
  }

  /**
   * DriveFolder without action
   */
  export type DriveFolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
  }


  /**
   * Model DriveFile
   */

  export type AggregateDriveFile = {
    _count: DriveFileCountAggregateOutputType | null
    _avg: DriveFileAvgAggregateOutputType | null
    _sum: DriveFileSumAggregateOutputType | null
    _min: DriveFileMinAggregateOutputType | null
    _max: DriveFileMaxAggregateOutputType | null
  }

  export type DriveFileAvgAggregateOutputType = {
    id: number | null
    size: number | null
    order: number | null
    folderId: number | null
    ownerId: number | null
  }

  export type DriveFileSumAggregateOutputType = {
    id: number | null
    size: number | null
    order: number | null
    folderId: number | null
    ownerId: number | null
  }

  export type DriveFileMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    size: number | null
    order: number | null
    folderId: number | null
    ownerId: number | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriveFileMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    size: number | null
    order: number | null
    folderId: number | null
    ownerId: number | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriveFileCountAggregateOutputType = {
    id: number
    name: number
    type: number
    size: number
    order: number
    folderId: number
    ownerId: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriveFileAvgAggregateInputType = {
    id?: true
    size?: true
    order?: true
    folderId?: true
    ownerId?: true
  }

  export type DriveFileSumAggregateInputType = {
    id?: true
    size?: true
    order?: true
    folderId?: true
    ownerId?: true
  }

  export type DriveFileMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    size?: true
    order?: true
    folderId?: true
    ownerId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriveFileMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    size?: true
    order?: true
    folderId?: true
    ownerId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriveFileCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    size?: true
    order?: true
    folderId?: true
    ownerId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriveFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriveFile to aggregate.
     */
    where?: DriveFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFiles to fetch.
     */
    orderBy?: DriveFileOrderByWithRelationInput | DriveFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriveFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriveFiles
    **/
    _count?: true | DriveFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriveFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriveFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriveFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriveFileMaxAggregateInputType
  }

  export type GetDriveFileAggregateType<T extends DriveFileAggregateArgs> = {
        [P in keyof T & keyof AggregateDriveFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriveFile[P]>
      : GetScalarType<T[P], AggregateDriveFile[P]>
  }




  export type DriveFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFileWhereInput
    orderBy?: DriveFileOrderByWithAggregationInput | DriveFileOrderByWithAggregationInput[]
    by: DriveFileScalarFieldEnum[] | DriveFileScalarFieldEnum
    having?: DriveFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriveFileCountAggregateInputType | true
    _avg?: DriveFileAvgAggregateInputType
    _sum?: DriveFileSumAggregateInputType
    _min?: DriveFileMinAggregateInputType
    _max?: DriveFileMaxAggregateInputType
  }

  export type DriveFileGroupByOutputType = {
    id: number
    name: string
    type: string
    size: number
    order: number
    folderId: number | null
    ownerId: number
    url: string
    createdAt: Date
    updatedAt: Date
    _count: DriveFileCountAggregateOutputType | null
    _avg: DriveFileAvgAggregateOutputType | null
    _sum: DriveFileSumAggregateOutputType | null
    _min: DriveFileMinAggregateOutputType | null
    _max: DriveFileMaxAggregateOutputType | null
  }

  type GetDriveFileGroupByPayload<T extends DriveFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriveFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriveFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriveFileGroupByOutputType[P]>
            : GetScalarType<T[P], DriveFileGroupByOutputType[P]>
        }
      >
    >


  export type DriveFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    order?: boolean
    folderId?: boolean
    ownerId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folder?: boolean | DriveFile$folderArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    permissions?: boolean | DriveFile$permissionsArgs<ExtArgs>
    _count?: boolean | DriveFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFile"]>

  export type DriveFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    order?: boolean
    folderId?: boolean
    ownerId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folder?: boolean | DriveFile$folderArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFile"]>

  export type DriveFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    order?: boolean
    folderId?: boolean
    ownerId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folder?: boolean | DriveFile$folderArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFile"]>

  export type DriveFileSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    order?: boolean
    folderId?: boolean
    ownerId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriveFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "size" | "order" | "folderId" | "ownerId" | "url" | "createdAt" | "updatedAt", ExtArgs["result"]["driveFile"]>
  export type DriveFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | DriveFile$folderArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    permissions?: boolean | DriveFile$permissionsArgs<ExtArgs>
    _count?: boolean | DriveFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriveFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | DriveFile$folderArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DriveFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | DriveFile$folderArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DriveFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriveFile"
    objects: {
      folder: Prisma.$DriveFolderPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      permissions: Prisma.$DriveFilePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      size: number
      order: number
      folderId: number | null
      ownerId: number
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driveFile"]>
    composites: {}
  }

  type DriveFileGetPayload<S extends boolean | null | undefined | DriveFileDefaultArgs> = $Result.GetResult<Prisma.$DriveFilePayload, S>

  type DriveFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriveFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriveFileCountAggregateInputType | true
    }

  export interface DriveFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriveFile'], meta: { name: 'DriveFile' } }
    /**
     * Find zero or one DriveFile that matches the filter.
     * @param {DriveFileFindUniqueArgs} args - Arguments to find a DriveFile
     * @example
     * // Get one DriveFile
     * const driveFile = await prisma.driveFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriveFileFindUniqueArgs>(args: SelectSubset<T, DriveFileFindUniqueArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DriveFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriveFileFindUniqueOrThrowArgs} args - Arguments to find a DriveFile
     * @example
     * // Get one DriveFile
     * const driveFile = await prisma.driveFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriveFileFindUniqueOrThrowArgs>(args: SelectSubset<T, DriveFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DriveFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileFindFirstArgs} args - Arguments to find a DriveFile
     * @example
     * // Get one DriveFile
     * const driveFile = await prisma.driveFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriveFileFindFirstArgs>(args?: SelectSubset<T, DriveFileFindFirstArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DriveFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileFindFirstOrThrowArgs} args - Arguments to find a DriveFile
     * @example
     * // Get one DriveFile
     * const driveFile = await prisma.driveFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriveFileFindFirstOrThrowArgs>(args?: SelectSubset<T, DriveFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DriveFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriveFiles
     * const driveFiles = await prisma.driveFile.findMany()
     * 
     * // Get first 10 DriveFiles
     * const driveFiles = await prisma.driveFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driveFileWithIdOnly = await prisma.driveFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriveFileFindManyArgs>(args?: SelectSubset<T, DriveFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DriveFile.
     * @param {DriveFileCreateArgs} args - Arguments to create a DriveFile.
     * @example
     * // Create one DriveFile
     * const DriveFile = await prisma.driveFile.create({
     *   data: {
     *     // ... data to create a DriveFile
     *   }
     * })
     * 
     */
    create<T extends DriveFileCreateArgs>(args: SelectSubset<T, DriveFileCreateArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DriveFiles.
     * @param {DriveFileCreateManyArgs} args - Arguments to create many DriveFiles.
     * @example
     * // Create many DriveFiles
     * const driveFile = await prisma.driveFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriveFileCreateManyArgs>(args?: SelectSubset<T, DriveFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriveFiles and returns the data saved in the database.
     * @param {DriveFileCreateManyAndReturnArgs} args - Arguments to create many DriveFiles.
     * @example
     * // Create many DriveFiles
     * const driveFile = await prisma.driveFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriveFiles and only return the `id`
     * const driveFileWithIdOnly = await prisma.driveFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriveFileCreateManyAndReturnArgs>(args?: SelectSubset<T, DriveFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DriveFile.
     * @param {DriveFileDeleteArgs} args - Arguments to delete one DriveFile.
     * @example
     * // Delete one DriveFile
     * const DriveFile = await prisma.driveFile.delete({
     *   where: {
     *     // ... filter to delete one DriveFile
     *   }
     * })
     * 
     */
    delete<T extends DriveFileDeleteArgs>(args: SelectSubset<T, DriveFileDeleteArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DriveFile.
     * @param {DriveFileUpdateArgs} args - Arguments to update one DriveFile.
     * @example
     * // Update one DriveFile
     * const driveFile = await prisma.driveFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriveFileUpdateArgs>(args: SelectSubset<T, DriveFileUpdateArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DriveFiles.
     * @param {DriveFileDeleteManyArgs} args - Arguments to filter DriveFiles to delete.
     * @example
     * // Delete a few DriveFiles
     * const { count } = await prisma.driveFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriveFileDeleteManyArgs>(args?: SelectSubset<T, DriveFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriveFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriveFiles
     * const driveFile = await prisma.driveFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriveFileUpdateManyArgs>(args: SelectSubset<T, DriveFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriveFiles and returns the data updated in the database.
     * @param {DriveFileUpdateManyAndReturnArgs} args - Arguments to update many DriveFiles.
     * @example
     * // Update many DriveFiles
     * const driveFile = await prisma.driveFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriveFiles and only return the `id`
     * const driveFileWithIdOnly = await prisma.driveFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriveFileUpdateManyAndReturnArgs>(args: SelectSubset<T, DriveFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DriveFile.
     * @param {DriveFileUpsertArgs} args - Arguments to update or create a DriveFile.
     * @example
     * // Update or create a DriveFile
     * const driveFile = await prisma.driveFile.upsert({
     *   create: {
     *     // ... data to create a DriveFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriveFile we want to update
     *   }
     * })
     */
    upsert<T extends DriveFileUpsertArgs>(args: SelectSubset<T, DriveFileUpsertArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DriveFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileCountArgs} args - Arguments to filter DriveFiles to count.
     * @example
     * // Count the number of DriveFiles
     * const count = await prisma.driveFile.count({
     *   where: {
     *     // ... the filter for the DriveFiles we want to count
     *   }
     * })
    **/
    count<T extends DriveFileCountArgs>(
      args?: Subset<T, DriveFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriveFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriveFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriveFileAggregateArgs>(args: Subset<T, DriveFileAggregateArgs>): Prisma.PrismaPromise<GetDriveFileAggregateType<T>>

    /**
     * Group by DriveFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriveFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriveFileGroupByArgs['orderBy'] }
        : { orderBy?: DriveFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriveFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriveFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriveFile model
   */
  readonly fields: DriveFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriveFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriveFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends DriveFile$folderArgs<ExtArgs> = {}>(args?: Subset<T, DriveFile$folderArgs<ExtArgs>>): Prisma__DriveFolderClient<$Result.GetResult<Prisma.$DriveFolderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    permissions<T extends DriveFile$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, DriveFile$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriveFile model
   */ 
  interface DriveFileFieldRefs {
    readonly id: FieldRef<"DriveFile", 'Int'>
    readonly name: FieldRef<"DriveFile", 'String'>
    readonly type: FieldRef<"DriveFile", 'String'>
    readonly size: FieldRef<"DriveFile", 'Int'>
    readonly order: FieldRef<"DriveFile", 'Int'>
    readonly folderId: FieldRef<"DriveFile", 'Int'>
    readonly ownerId: FieldRef<"DriveFile", 'Int'>
    readonly url: FieldRef<"DriveFile", 'String'>
    readonly createdAt: FieldRef<"DriveFile", 'DateTime'>
    readonly updatedAt: FieldRef<"DriveFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriveFile findUnique
   */
  export type DriveFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * Filter, which DriveFile to fetch.
     */
    where: DriveFileWhereUniqueInput
  }

  /**
   * DriveFile findUniqueOrThrow
   */
  export type DriveFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * Filter, which DriveFile to fetch.
     */
    where: DriveFileWhereUniqueInput
  }

  /**
   * DriveFile findFirst
   */
  export type DriveFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * Filter, which DriveFile to fetch.
     */
    where?: DriveFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFiles to fetch.
     */
    orderBy?: DriveFileOrderByWithRelationInput | DriveFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriveFiles.
     */
    cursor?: DriveFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriveFiles.
     */
    distinct?: DriveFileScalarFieldEnum | DriveFileScalarFieldEnum[]
  }

  /**
   * DriveFile findFirstOrThrow
   */
  export type DriveFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * Filter, which DriveFile to fetch.
     */
    where?: DriveFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFiles to fetch.
     */
    orderBy?: DriveFileOrderByWithRelationInput | DriveFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriveFiles.
     */
    cursor?: DriveFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriveFiles.
     */
    distinct?: DriveFileScalarFieldEnum | DriveFileScalarFieldEnum[]
  }

  /**
   * DriveFile findMany
   */
  export type DriveFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * Filter, which DriveFiles to fetch.
     */
    where?: DriveFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFiles to fetch.
     */
    orderBy?: DriveFileOrderByWithRelationInput | DriveFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriveFiles.
     */
    cursor?: DriveFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFiles.
     */
    skip?: number
    distinct?: DriveFileScalarFieldEnum | DriveFileScalarFieldEnum[]
  }

  /**
   * DriveFile create
   */
  export type DriveFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * The data needed to create a DriveFile.
     */
    data: XOR<DriveFileCreateInput, DriveFileUncheckedCreateInput>
  }

  /**
   * DriveFile createMany
   */
  export type DriveFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriveFiles.
     */
    data: DriveFileCreateManyInput | DriveFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriveFile createManyAndReturn
   */
  export type DriveFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * The data used to create many DriveFiles.
     */
    data: DriveFileCreateManyInput | DriveFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriveFile update
   */
  export type DriveFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * The data needed to update a DriveFile.
     */
    data: XOR<DriveFileUpdateInput, DriveFileUncheckedUpdateInput>
    /**
     * Choose, which DriveFile to update.
     */
    where: DriveFileWhereUniqueInput
  }

  /**
   * DriveFile updateMany
   */
  export type DriveFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriveFiles.
     */
    data: XOR<DriveFileUpdateManyMutationInput, DriveFileUncheckedUpdateManyInput>
    /**
     * Filter which DriveFiles to update
     */
    where?: DriveFileWhereInput
    /**
     * Limit how many DriveFiles to update.
     */
    limit?: number
  }

  /**
   * DriveFile updateManyAndReturn
   */
  export type DriveFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * The data used to update DriveFiles.
     */
    data: XOR<DriveFileUpdateManyMutationInput, DriveFileUncheckedUpdateManyInput>
    /**
     * Filter which DriveFiles to update
     */
    where?: DriveFileWhereInput
    /**
     * Limit how many DriveFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriveFile upsert
   */
  export type DriveFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * The filter to search for the DriveFile to update in case it exists.
     */
    where: DriveFileWhereUniqueInput
    /**
     * In case the DriveFile found by the `where` argument doesn't exist, create a new DriveFile with this data.
     */
    create: XOR<DriveFileCreateInput, DriveFileUncheckedCreateInput>
    /**
     * In case the DriveFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriveFileUpdateInput, DriveFileUncheckedUpdateInput>
  }

  /**
   * DriveFile delete
   */
  export type DriveFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
    /**
     * Filter which DriveFile to delete.
     */
    where: DriveFileWhereUniqueInput
  }

  /**
   * DriveFile deleteMany
   */
  export type DriveFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriveFiles to delete
     */
    where?: DriveFileWhereInput
    /**
     * Limit how many DriveFiles to delete.
     */
    limit?: number
  }

  /**
   * DriveFile.folder
   */
  export type DriveFile$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFolder
     */
    select?: DriveFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFolder
     */
    omit?: DriveFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFolderInclude<ExtArgs> | null
    where?: DriveFolderWhereInput
  }

  /**
   * DriveFile.permissions
   */
  export type DriveFile$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    where?: DriveFilePermissionWhereInput
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    cursor?: DriveFilePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * DriveFile without action
   */
  export type DriveFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFile
     */
    select?: DriveFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFile
     */
    omit?: DriveFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFileInclude<ExtArgs> | null
  }


  /**
   * Model DriveFilePermission
   */

  export type AggregateDriveFilePermission = {
    _count: DriveFilePermissionCountAggregateOutputType | null
    _avg: DriveFilePermissionAvgAggregateOutputType | null
    _sum: DriveFilePermissionSumAggregateOutputType | null
    _min: DriveFilePermissionMinAggregateOutputType | null
    _max: DriveFilePermissionMaxAggregateOutputType | null
  }

  export type DriveFilePermissionAvgAggregateOutputType = {
    id: number | null
    fileId: number | null
    userId: number | null
    grantedBy: number | null
  }

  export type DriveFilePermissionSumAggregateOutputType = {
    id: number | null
    fileId: number | null
    userId: number | null
    grantedBy: number | null
  }

  export type DriveFilePermissionMinAggregateOutputType = {
    id: number | null
    fileId: number | null
    userId: number | null
    access: string | null
    grantedBy: number | null
    grantedAt: Date | null
  }

  export type DriveFilePermissionMaxAggregateOutputType = {
    id: number | null
    fileId: number | null
    userId: number | null
    access: string | null
    grantedBy: number | null
    grantedAt: Date | null
  }

  export type DriveFilePermissionCountAggregateOutputType = {
    id: number
    fileId: number
    userId: number
    access: number
    grantedBy: number
    grantedAt: number
    _all: number
  }


  export type DriveFilePermissionAvgAggregateInputType = {
    id?: true
    fileId?: true
    userId?: true
    grantedBy?: true
  }

  export type DriveFilePermissionSumAggregateInputType = {
    id?: true
    fileId?: true
    userId?: true
    grantedBy?: true
  }

  export type DriveFilePermissionMinAggregateInputType = {
    id?: true
    fileId?: true
    userId?: true
    access?: true
    grantedBy?: true
    grantedAt?: true
  }

  export type DriveFilePermissionMaxAggregateInputType = {
    id?: true
    fileId?: true
    userId?: true
    access?: true
    grantedBy?: true
    grantedAt?: true
  }

  export type DriveFilePermissionCountAggregateInputType = {
    id?: true
    fileId?: true
    userId?: true
    access?: true
    grantedBy?: true
    grantedAt?: true
    _all?: true
  }

  export type DriveFilePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriveFilePermission to aggregate.
     */
    where?: DriveFilePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFilePermissions to fetch.
     */
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriveFilePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFilePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFilePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriveFilePermissions
    **/
    _count?: true | DriveFilePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriveFilePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriveFilePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriveFilePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriveFilePermissionMaxAggregateInputType
  }

  export type GetDriveFilePermissionAggregateType<T extends DriveFilePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateDriveFilePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriveFilePermission[P]>
      : GetScalarType<T[P], AggregateDriveFilePermission[P]>
  }




  export type DriveFilePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriveFilePermissionWhereInput
    orderBy?: DriveFilePermissionOrderByWithAggregationInput | DriveFilePermissionOrderByWithAggregationInput[]
    by: DriveFilePermissionScalarFieldEnum[] | DriveFilePermissionScalarFieldEnum
    having?: DriveFilePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriveFilePermissionCountAggregateInputType | true
    _avg?: DriveFilePermissionAvgAggregateInputType
    _sum?: DriveFilePermissionSumAggregateInputType
    _min?: DriveFilePermissionMinAggregateInputType
    _max?: DriveFilePermissionMaxAggregateInputType
  }

  export type DriveFilePermissionGroupByOutputType = {
    id: number
    fileId: number
    userId: number
    access: string
    grantedBy: number
    grantedAt: Date
    _count: DriveFilePermissionCountAggregateOutputType | null
    _avg: DriveFilePermissionAvgAggregateOutputType | null
    _sum: DriveFilePermissionSumAggregateOutputType | null
    _min: DriveFilePermissionMinAggregateOutputType | null
    _max: DriveFilePermissionMaxAggregateOutputType | null
  }

  type GetDriveFilePermissionGroupByPayload<T extends DriveFilePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriveFilePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriveFilePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriveFilePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], DriveFilePermissionGroupByOutputType[P]>
        }
      >
    >


  export type DriveFilePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    userId?: boolean
    access?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    file?: boolean | DriveFileDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DriveFilePermission$UserArgs<ExtArgs>
    _count?: boolean | DriveFilePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFilePermission"]>

  export type DriveFilePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    userId?: boolean
    access?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    file?: boolean | DriveFileDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFilePermission"]>

  export type DriveFilePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    userId?: boolean
    access?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    file?: boolean | DriveFileDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driveFilePermission"]>

  export type DriveFilePermissionSelectScalar = {
    id?: boolean
    fileId?: boolean
    userId?: boolean
    access?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
  }

  export type DriveFilePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileId" | "userId" | "access" | "grantedBy" | "grantedAt", ExtArgs["result"]["driveFilePermission"]>
  export type DriveFilePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | DriveFileDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DriveFilePermission$UserArgs<ExtArgs>
    _count?: boolean | DriveFilePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriveFilePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | DriveFileDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DriveFilePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | DriveFileDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DriveFilePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriveFilePermission"
    objects: {
      file: Prisma.$DriveFilePayload<ExtArgs>
      granter: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fileId: number
      userId: number
      access: string
      grantedBy: number
      grantedAt: Date
    }, ExtArgs["result"]["driveFilePermission"]>
    composites: {}
  }

  type DriveFilePermissionGetPayload<S extends boolean | null | undefined | DriveFilePermissionDefaultArgs> = $Result.GetResult<Prisma.$DriveFilePermissionPayload, S>

  type DriveFilePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriveFilePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriveFilePermissionCountAggregateInputType | true
    }

  export interface DriveFilePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriveFilePermission'], meta: { name: 'DriveFilePermission' } }
    /**
     * Find zero or one DriveFilePermission that matches the filter.
     * @param {DriveFilePermissionFindUniqueArgs} args - Arguments to find a DriveFilePermission
     * @example
     * // Get one DriveFilePermission
     * const driveFilePermission = await prisma.driveFilePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriveFilePermissionFindUniqueArgs>(args: SelectSubset<T, DriveFilePermissionFindUniqueArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DriveFilePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriveFilePermissionFindUniqueOrThrowArgs} args - Arguments to find a DriveFilePermission
     * @example
     * // Get one DriveFilePermission
     * const driveFilePermission = await prisma.driveFilePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriveFilePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, DriveFilePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DriveFilePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionFindFirstArgs} args - Arguments to find a DriveFilePermission
     * @example
     * // Get one DriveFilePermission
     * const driveFilePermission = await prisma.driveFilePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriveFilePermissionFindFirstArgs>(args?: SelectSubset<T, DriveFilePermissionFindFirstArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DriveFilePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionFindFirstOrThrowArgs} args - Arguments to find a DriveFilePermission
     * @example
     * // Get one DriveFilePermission
     * const driveFilePermission = await prisma.driveFilePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriveFilePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, DriveFilePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DriveFilePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriveFilePermissions
     * const driveFilePermissions = await prisma.driveFilePermission.findMany()
     * 
     * // Get first 10 DriveFilePermissions
     * const driveFilePermissions = await prisma.driveFilePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driveFilePermissionWithIdOnly = await prisma.driveFilePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriveFilePermissionFindManyArgs>(args?: SelectSubset<T, DriveFilePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DriveFilePermission.
     * @param {DriveFilePermissionCreateArgs} args - Arguments to create a DriveFilePermission.
     * @example
     * // Create one DriveFilePermission
     * const DriveFilePermission = await prisma.driveFilePermission.create({
     *   data: {
     *     // ... data to create a DriveFilePermission
     *   }
     * })
     * 
     */
    create<T extends DriveFilePermissionCreateArgs>(args: SelectSubset<T, DriveFilePermissionCreateArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DriveFilePermissions.
     * @param {DriveFilePermissionCreateManyArgs} args - Arguments to create many DriveFilePermissions.
     * @example
     * // Create many DriveFilePermissions
     * const driveFilePermission = await prisma.driveFilePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriveFilePermissionCreateManyArgs>(args?: SelectSubset<T, DriveFilePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriveFilePermissions and returns the data saved in the database.
     * @param {DriveFilePermissionCreateManyAndReturnArgs} args - Arguments to create many DriveFilePermissions.
     * @example
     * // Create many DriveFilePermissions
     * const driveFilePermission = await prisma.driveFilePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriveFilePermissions and only return the `id`
     * const driveFilePermissionWithIdOnly = await prisma.driveFilePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriveFilePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, DriveFilePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DriveFilePermission.
     * @param {DriveFilePermissionDeleteArgs} args - Arguments to delete one DriveFilePermission.
     * @example
     * // Delete one DriveFilePermission
     * const DriveFilePermission = await prisma.driveFilePermission.delete({
     *   where: {
     *     // ... filter to delete one DriveFilePermission
     *   }
     * })
     * 
     */
    delete<T extends DriveFilePermissionDeleteArgs>(args: SelectSubset<T, DriveFilePermissionDeleteArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DriveFilePermission.
     * @param {DriveFilePermissionUpdateArgs} args - Arguments to update one DriveFilePermission.
     * @example
     * // Update one DriveFilePermission
     * const driveFilePermission = await prisma.driveFilePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriveFilePermissionUpdateArgs>(args: SelectSubset<T, DriveFilePermissionUpdateArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DriveFilePermissions.
     * @param {DriveFilePermissionDeleteManyArgs} args - Arguments to filter DriveFilePermissions to delete.
     * @example
     * // Delete a few DriveFilePermissions
     * const { count } = await prisma.driveFilePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriveFilePermissionDeleteManyArgs>(args?: SelectSubset<T, DriveFilePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriveFilePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriveFilePermissions
     * const driveFilePermission = await prisma.driveFilePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriveFilePermissionUpdateManyArgs>(args: SelectSubset<T, DriveFilePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriveFilePermissions and returns the data updated in the database.
     * @param {DriveFilePermissionUpdateManyAndReturnArgs} args - Arguments to update many DriveFilePermissions.
     * @example
     * // Update many DriveFilePermissions
     * const driveFilePermission = await prisma.driveFilePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriveFilePermissions and only return the `id`
     * const driveFilePermissionWithIdOnly = await prisma.driveFilePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriveFilePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, DriveFilePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DriveFilePermission.
     * @param {DriveFilePermissionUpsertArgs} args - Arguments to update or create a DriveFilePermission.
     * @example
     * // Update or create a DriveFilePermission
     * const driveFilePermission = await prisma.driveFilePermission.upsert({
     *   create: {
     *     // ... data to create a DriveFilePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriveFilePermission we want to update
     *   }
     * })
     */
    upsert<T extends DriveFilePermissionUpsertArgs>(args: SelectSubset<T, DriveFilePermissionUpsertArgs<ExtArgs>>): Prisma__DriveFilePermissionClient<$Result.GetResult<Prisma.$DriveFilePermissionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DriveFilePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionCountArgs} args - Arguments to filter DriveFilePermissions to count.
     * @example
     * // Count the number of DriveFilePermissions
     * const count = await prisma.driveFilePermission.count({
     *   where: {
     *     // ... the filter for the DriveFilePermissions we want to count
     *   }
     * })
    **/
    count<T extends DriveFilePermissionCountArgs>(
      args?: Subset<T, DriveFilePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriveFilePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriveFilePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriveFilePermissionAggregateArgs>(args: Subset<T, DriveFilePermissionAggregateArgs>): Prisma.PrismaPromise<GetDriveFilePermissionAggregateType<T>>

    /**
     * Group by DriveFilePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveFilePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriveFilePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriveFilePermissionGroupByArgs['orderBy'] }
        : { orderBy?: DriveFilePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriveFilePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriveFilePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriveFilePermission model
   */
  readonly fields: DriveFilePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriveFilePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriveFilePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends DriveFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriveFileDefaultArgs<ExtArgs>>): Prisma__DriveFileClient<$Result.GetResult<Prisma.$DriveFilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    granter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends DriveFilePermission$UserArgs<ExtArgs> = {}>(args?: Subset<T, DriveFilePermission$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriveFilePermission model
   */ 
  interface DriveFilePermissionFieldRefs {
    readonly id: FieldRef<"DriveFilePermission", 'Int'>
    readonly fileId: FieldRef<"DriveFilePermission", 'Int'>
    readonly userId: FieldRef<"DriveFilePermission", 'Int'>
    readonly access: FieldRef<"DriveFilePermission", 'String'>
    readonly grantedBy: FieldRef<"DriveFilePermission", 'Int'>
    readonly grantedAt: FieldRef<"DriveFilePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriveFilePermission findUnique
   */
  export type DriveFilePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * Filter, which DriveFilePermission to fetch.
     */
    where: DriveFilePermissionWhereUniqueInput
  }

  /**
   * DriveFilePermission findUniqueOrThrow
   */
  export type DriveFilePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * Filter, which DriveFilePermission to fetch.
     */
    where: DriveFilePermissionWhereUniqueInput
  }

  /**
   * DriveFilePermission findFirst
   */
  export type DriveFilePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * Filter, which DriveFilePermission to fetch.
     */
    where?: DriveFilePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFilePermissions to fetch.
     */
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriveFilePermissions.
     */
    cursor?: DriveFilePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFilePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFilePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriveFilePermissions.
     */
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * DriveFilePermission findFirstOrThrow
   */
  export type DriveFilePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * Filter, which DriveFilePermission to fetch.
     */
    where?: DriveFilePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFilePermissions to fetch.
     */
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriveFilePermissions.
     */
    cursor?: DriveFilePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFilePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFilePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriveFilePermissions.
     */
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * DriveFilePermission findMany
   */
  export type DriveFilePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * Filter, which DriveFilePermissions to fetch.
     */
    where?: DriveFilePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriveFilePermissions to fetch.
     */
    orderBy?: DriveFilePermissionOrderByWithRelationInput | DriveFilePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriveFilePermissions.
     */
    cursor?: DriveFilePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriveFilePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriveFilePermissions.
     */
    skip?: number
    distinct?: DriveFilePermissionScalarFieldEnum | DriveFilePermissionScalarFieldEnum[]
  }

  /**
   * DriveFilePermission create
   */
  export type DriveFilePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a DriveFilePermission.
     */
    data: XOR<DriveFilePermissionCreateInput, DriveFilePermissionUncheckedCreateInput>
  }

  /**
   * DriveFilePermission createMany
   */
  export type DriveFilePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriveFilePermissions.
     */
    data: DriveFilePermissionCreateManyInput | DriveFilePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriveFilePermission createManyAndReturn
   */
  export type DriveFilePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many DriveFilePermissions.
     */
    data: DriveFilePermissionCreateManyInput | DriveFilePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriveFilePermission update
   */
  export type DriveFilePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a DriveFilePermission.
     */
    data: XOR<DriveFilePermissionUpdateInput, DriveFilePermissionUncheckedUpdateInput>
    /**
     * Choose, which DriveFilePermission to update.
     */
    where: DriveFilePermissionWhereUniqueInput
  }

  /**
   * DriveFilePermission updateMany
   */
  export type DriveFilePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriveFilePermissions.
     */
    data: XOR<DriveFilePermissionUpdateManyMutationInput, DriveFilePermissionUncheckedUpdateManyInput>
    /**
     * Filter which DriveFilePermissions to update
     */
    where?: DriveFilePermissionWhereInput
    /**
     * Limit how many DriveFilePermissions to update.
     */
    limit?: number
  }

  /**
   * DriveFilePermission updateManyAndReturn
   */
  export type DriveFilePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * The data used to update DriveFilePermissions.
     */
    data: XOR<DriveFilePermissionUpdateManyMutationInput, DriveFilePermissionUncheckedUpdateManyInput>
    /**
     * Filter which DriveFilePermissions to update
     */
    where?: DriveFilePermissionWhereInput
    /**
     * Limit how many DriveFilePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriveFilePermission upsert
   */
  export type DriveFilePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the DriveFilePermission to update in case it exists.
     */
    where: DriveFilePermissionWhereUniqueInput
    /**
     * In case the DriveFilePermission found by the `where` argument doesn't exist, create a new DriveFilePermission with this data.
     */
    create: XOR<DriveFilePermissionCreateInput, DriveFilePermissionUncheckedCreateInput>
    /**
     * In case the DriveFilePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriveFilePermissionUpdateInput, DriveFilePermissionUncheckedUpdateInput>
  }

  /**
   * DriveFilePermission delete
   */
  export type DriveFilePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
    /**
     * Filter which DriveFilePermission to delete.
     */
    where: DriveFilePermissionWhereUniqueInput
  }

  /**
   * DriveFilePermission deleteMany
   */
  export type DriveFilePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriveFilePermissions to delete
     */
    where?: DriveFilePermissionWhereInput
    /**
     * Limit how many DriveFilePermissions to delete.
     */
    limit?: number
  }

  /**
   * DriveFilePermission.User
   */
  export type DriveFilePermission$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * DriveFilePermission without action
   */
  export type DriveFilePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriveFilePermission
     */
    select?: DriveFilePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriveFilePermission
     */
    omit?: DriveFilePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriveFilePermissionInclude<ExtArgs> | null
  }


  /**
   * Model JobTitle
   */

  export type AggregateJobTitle = {
    _count: JobTitleCountAggregateOutputType | null
    _avg: JobTitleAvgAggregateOutputType | null
    _sum: JobTitleSumAggregateOutputType | null
    _min: JobTitleMinAggregateOutputType | null
    _max: JobTitleMaxAggregateOutputType | null
  }

  export type JobTitleAvgAggregateOutputType = {
    id: number | null
  }

  export type JobTitleSumAggregateOutputType = {
    id: number | null
  }

  export type JobTitleMinAggregateOutputType = {
    id: number | null
    sn: string | null
    jobTitle: string | null
    abbreviation: string | null
    grade: string | null
    seniorityLevel: string | null
    selectableInStaffCV: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobTitleMaxAggregateOutputType = {
    id: number | null
    sn: string | null
    jobTitle: string | null
    abbreviation: string | null
    grade: string | null
    seniorityLevel: string | null
    selectableInStaffCV: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobTitleCountAggregateOutputType = {
    id: number
    sn: number
    jobTitle: number
    abbreviation: number
    grade: number
    seniorityLevel: number
    selectableInStaffCV: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobTitleAvgAggregateInputType = {
    id?: true
  }

  export type JobTitleSumAggregateInputType = {
    id?: true
  }

  export type JobTitleMinAggregateInputType = {
    id?: true
    sn?: true
    jobTitle?: true
    abbreviation?: true
    grade?: true
    seniorityLevel?: true
    selectableInStaffCV?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobTitleMaxAggregateInputType = {
    id?: true
    sn?: true
    jobTitle?: true
    abbreviation?: true
    grade?: true
    seniorityLevel?: true
    selectableInStaffCV?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobTitleCountAggregateInputType = {
    id?: true
    sn?: true
    jobTitle?: true
    abbreviation?: true
    grade?: true
    seniorityLevel?: true
    selectableInStaffCV?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobTitleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobTitle to aggregate.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobTitles
    **/
    _count?: true | JobTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobTitleMaxAggregateInputType
  }

  export type GetJobTitleAggregateType<T extends JobTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateJobTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobTitle[P]>
      : GetScalarType<T[P], AggregateJobTitle[P]>
  }




  export type JobTitleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobTitleWhereInput
    orderBy?: JobTitleOrderByWithAggregationInput | JobTitleOrderByWithAggregationInput[]
    by: JobTitleScalarFieldEnum[] | JobTitleScalarFieldEnum
    having?: JobTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobTitleCountAggregateInputType | true
    _avg?: JobTitleAvgAggregateInputType
    _sum?: JobTitleSumAggregateInputType
    _min?: JobTitleMinAggregateInputType
    _max?: JobTitleMaxAggregateInputType
  }

  export type JobTitleGroupByOutputType = {
    id: number
    sn: string
    jobTitle: string
    abbreviation: string
    grade: string
    seniorityLevel: string
    selectableInStaffCV: string
    createdAt: Date
    updatedAt: Date
    _count: JobTitleCountAggregateOutputType | null
    _avg: JobTitleAvgAggregateOutputType | null
    _sum: JobTitleSumAggregateOutputType | null
    _min: JobTitleMinAggregateOutputType | null
    _max: JobTitleMaxAggregateOutputType | null
  }

  type GetJobTitleGroupByPayload<T extends JobTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobTitleGroupByOutputType[P]>
            : GetScalarType<T[P], JobTitleGroupByOutputType[P]>
        }
      >
    >


  export type JobTitleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sn?: boolean
    jobTitle?: boolean
    abbreviation?: boolean
    grade?: boolean
    seniorityLevel?: boolean
    selectableInStaffCV?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobTitle"]>

  export type JobTitleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sn?: boolean
    jobTitle?: boolean
    abbreviation?: boolean
    grade?: boolean
    seniorityLevel?: boolean
    selectableInStaffCV?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobTitle"]>

  export type JobTitleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sn?: boolean
    jobTitle?: boolean
    abbreviation?: boolean
    grade?: boolean
    seniorityLevel?: boolean
    selectableInStaffCV?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jobTitle"]>

  export type JobTitleSelectScalar = {
    id?: boolean
    sn?: boolean
    jobTitle?: boolean
    abbreviation?: boolean
    grade?: boolean
    seniorityLevel?: boolean
    selectableInStaffCV?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobTitleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sn" | "jobTitle" | "abbreviation" | "grade" | "seniorityLevel" | "selectableInStaffCV" | "createdAt" | "updatedAt", ExtArgs["result"]["jobTitle"]>

  export type $JobTitlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobTitle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sn: string
      jobTitle: string
      abbreviation: string
      grade: string
      seniorityLevel: string
      selectableInStaffCV: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobTitle"]>
    composites: {}
  }

  type JobTitleGetPayload<S extends boolean | null | undefined | JobTitleDefaultArgs> = $Result.GetResult<Prisma.$JobTitlePayload, S>

  type JobTitleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobTitleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobTitleCountAggregateInputType | true
    }

  export interface JobTitleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobTitle'], meta: { name: 'JobTitle' } }
    /**
     * Find zero or one JobTitle that matches the filter.
     * @param {JobTitleFindUniqueArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobTitleFindUniqueArgs>(args: SelectSubset<T, JobTitleFindUniqueArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JobTitle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobTitleFindUniqueOrThrowArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobTitleFindUniqueOrThrowArgs>(args: SelectSubset<T, JobTitleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JobTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleFindFirstArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobTitleFindFirstArgs>(args?: SelectSubset<T, JobTitleFindFirstArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JobTitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleFindFirstOrThrowArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobTitleFindFirstOrThrowArgs>(args?: SelectSubset<T, JobTitleFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JobTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobTitles
     * const jobTitles = await prisma.jobTitle.findMany()
     * 
     * // Get first 10 JobTitles
     * const jobTitles = await prisma.jobTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobTitleWithIdOnly = await prisma.jobTitle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobTitleFindManyArgs>(args?: SelectSubset<T, JobTitleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JobTitle.
     * @param {JobTitleCreateArgs} args - Arguments to create a JobTitle.
     * @example
     * // Create one JobTitle
     * const JobTitle = await prisma.jobTitle.create({
     *   data: {
     *     // ... data to create a JobTitle
     *   }
     * })
     * 
     */
    create<T extends JobTitleCreateArgs>(args: SelectSubset<T, JobTitleCreateArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JobTitles.
     * @param {JobTitleCreateManyArgs} args - Arguments to create many JobTitles.
     * @example
     * // Create many JobTitles
     * const jobTitle = await prisma.jobTitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobTitleCreateManyArgs>(args?: SelectSubset<T, JobTitleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobTitles and returns the data saved in the database.
     * @param {JobTitleCreateManyAndReturnArgs} args - Arguments to create many JobTitles.
     * @example
     * // Create many JobTitles
     * const jobTitle = await prisma.jobTitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobTitles and only return the `id`
     * const jobTitleWithIdOnly = await prisma.jobTitle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobTitleCreateManyAndReturnArgs>(args?: SelectSubset<T, JobTitleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JobTitle.
     * @param {JobTitleDeleteArgs} args - Arguments to delete one JobTitle.
     * @example
     * // Delete one JobTitle
     * const JobTitle = await prisma.jobTitle.delete({
     *   where: {
     *     // ... filter to delete one JobTitle
     *   }
     * })
     * 
     */
    delete<T extends JobTitleDeleteArgs>(args: SelectSubset<T, JobTitleDeleteArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JobTitle.
     * @param {JobTitleUpdateArgs} args - Arguments to update one JobTitle.
     * @example
     * // Update one JobTitle
     * const jobTitle = await prisma.jobTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobTitleUpdateArgs>(args: SelectSubset<T, JobTitleUpdateArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JobTitles.
     * @param {JobTitleDeleteManyArgs} args - Arguments to filter JobTitles to delete.
     * @example
     * // Delete a few JobTitles
     * const { count } = await prisma.jobTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobTitleDeleteManyArgs>(args?: SelectSubset<T, JobTitleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobTitles
     * const jobTitle = await prisma.jobTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobTitleUpdateManyArgs>(args: SelectSubset<T, JobTitleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobTitles and returns the data updated in the database.
     * @param {JobTitleUpdateManyAndReturnArgs} args - Arguments to update many JobTitles.
     * @example
     * // Update many JobTitles
     * const jobTitle = await prisma.jobTitle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobTitles and only return the `id`
     * const jobTitleWithIdOnly = await prisma.jobTitle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobTitleUpdateManyAndReturnArgs>(args: SelectSubset<T, JobTitleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JobTitle.
     * @param {JobTitleUpsertArgs} args - Arguments to update or create a JobTitle.
     * @example
     * // Update or create a JobTitle
     * const jobTitle = await prisma.jobTitle.upsert({
     *   create: {
     *     // ... data to create a JobTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobTitle we want to update
     *   }
     * })
     */
    upsert<T extends JobTitleUpsertArgs>(args: SelectSubset<T, JobTitleUpsertArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleCountArgs} args - Arguments to filter JobTitles to count.
     * @example
     * // Count the number of JobTitles
     * const count = await prisma.jobTitle.count({
     *   where: {
     *     // ... the filter for the JobTitles we want to count
     *   }
     * })
    **/
    count<T extends JobTitleCountArgs>(
      args?: Subset<T, JobTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobTitleAggregateArgs>(args: Subset<T, JobTitleAggregateArgs>): Prisma.PrismaPromise<GetJobTitleAggregateType<T>>

    /**
     * Group by JobTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobTitleGroupByArgs['orderBy'] }
        : { orderBy?: JobTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobTitle model
   */
  readonly fields: JobTitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobTitleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobTitle model
   */ 
  interface JobTitleFieldRefs {
    readonly id: FieldRef<"JobTitle", 'Int'>
    readonly sn: FieldRef<"JobTitle", 'String'>
    readonly jobTitle: FieldRef<"JobTitle", 'String'>
    readonly abbreviation: FieldRef<"JobTitle", 'String'>
    readonly grade: FieldRef<"JobTitle", 'String'>
    readonly seniorityLevel: FieldRef<"JobTitle", 'String'>
    readonly selectableInStaffCV: FieldRef<"JobTitle", 'String'>
    readonly createdAt: FieldRef<"JobTitle", 'DateTime'>
    readonly updatedAt: FieldRef<"JobTitle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobTitle findUnique
   */
  export type JobTitleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle findUniqueOrThrow
   */
  export type JobTitleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle findFirst
   */
  export type JobTitleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobTitles.
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobTitles.
     */
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * JobTitle findFirstOrThrow
   */
  export type JobTitleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobTitles.
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobTitles.
     */
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * JobTitle findMany
   */
  export type JobTitleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobTitles.
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * JobTitle create
   */
  export type JobTitleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * The data needed to create a JobTitle.
     */
    data: XOR<JobTitleCreateInput, JobTitleUncheckedCreateInput>
  }

  /**
   * JobTitle createMany
   */
  export type JobTitleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobTitles.
     */
    data: JobTitleCreateManyInput | JobTitleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobTitle createManyAndReturn
   */
  export type JobTitleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * The data used to create many JobTitles.
     */
    data: JobTitleCreateManyInput | JobTitleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobTitle update
   */
  export type JobTitleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * The data needed to update a JobTitle.
     */
    data: XOR<JobTitleUpdateInput, JobTitleUncheckedUpdateInput>
    /**
     * Choose, which JobTitle to update.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle updateMany
   */
  export type JobTitleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobTitles.
     */
    data: XOR<JobTitleUpdateManyMutationInput, JobTitleUncheckedUpdateManyInput>
    /**
     * Filter which JobTitles to update
     */
    where?: JobTitleWhereInput
    /**
     * Limit how many JobTitles to update.
     */
    limit?: number
  }

  /**
   * JobTitle updateManyAndReturn
   */
  export type JobTitleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * The data used to update JobTitles.
     */
    data: XOR<JobTitleUpdateManyMutationInput, JobTitleUncheckedUpdateManyInput>
    /**
     * Filter which JobTitles to update
     */
    where?: JobTitleWhereInput
    /**
     * Limit how many JobTitles to update.
     */
    limit?: number
  }

  /**
   * JobTitle upsert
   */
  export type JobTitleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * The filter to search for the JobTitle to update in case it exists.
     */
    where: JobTitleWhereUniqueInput
    /**
     * In case the JobTitle found by the `where` argument doesn't exist, create a new JobTitle with this data.
     */
    create: XOR<JobTitleCreateInput, JobTitleUncheckedCreateInput>
    /**
     * In case the JobTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobTitleUpdateInput, JobTitleUncheckedUpdateInput>
  }

  /**
   * JobTitle delete
   */
  export type JobTitleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
    /**
     * Filter which JobTitle to delete.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle deleteMany
   */
  export type JobTitleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobTitles to delete
     */
    where?: JobTitleWhereInput
    /**
     * Limit how many JobTitles to delete.
     */
    limit?: number
  }

  /**
   * JobTitle without action
   */
  export type JobTitleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitle
     */
    omit?: JobTitleOmit<ExtArgs> | null
  }


  /**
   * Model UserActivity
   */

  export type AggregateUserActivity = {
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  export type UserActivityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserActivitySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserActivityMinAggregateOutputType = {
    id: number | null
    userId: number | null
    username: string | null
    page: string | null
    loginTime: Date | null
  }

  export type UserActivityMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    username: string | null
    page: string | null
    loginTime: Date | null
  }

  export type UserActivityCountAggregateOutputType = {
    id: number
    userId: number
    username: number
    page: number
    loginTime: number
    _all: number
  }


  export type UserActivityAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserActivitySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserActivityMinAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    page?: true
    loginTime?: true
  }

  export type UserActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    page?: true
    loginTime?: true
  }

  export type UserActivityCountAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    page?: true
    loginTime?: true
    _all?: true
  }

  export type UserActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivity to aggregate.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivities
    **/
    _count?: true | UserActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityMaxAggregateInputType
  }

  export type GetUserActivityAggregateType<T extends UserActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivity[P]>
      : GetScalarType<T[P], AggregateUserActivity[P]>
  }




  export type UserActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithAggregationInput | UserActivityOrderByWithAggregationInput[]
    by: UserActivityScalarFieldEnum[] | UserActivityScalarFieldEnum
    having?: UserActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityCountAggregateInputType | true
    _avg?: UserActivityAvgAggregateInputType
    _sum?: UserActivitySumAggregateInputType
    _min?: UserActivityMinAggregateInputType
    _max?: UserActivityMaxAggregateInputType
  }

  export type UserActivityGroupByOutputType = {
    id: number
    userId: number
    username: string
    page: string
    loginTime: Date
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  type GetUserActivityGroupByPayload<T extends UserActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
        }
      >
    >


  export type UserActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    page?: boolean
    loginTime?: boolean
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    page?: boolean
    loginTime?: boolean
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    page?: boolean
    loginTime?: boolean
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    username?: boolean
    page?: boolean
    loginTime?: boolean
  }

  export type UserActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "username" | "page" | "loginTime", ExtArgs["result"]["userActivity"]>

  export type $UserActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      username: string
      page: string
      loginTime: Date
    }, ExtArgs["result"]["userActivity"]>
    composites: {}
  }

  type UserActivityGetPayload<S extends boolean | null | undefined | UserActivityDefaultArgs> = $Result.GetResult<Prisma.$UserActivityPayload, S>

  type UserActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserActivityCountAggregateInputType | true
    }

  export interface UserActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivity'], meta: { name: 'UserActivity' } }
    /**
     * Find zero or one UserActivity that matches the filter.
     * @param {UserActivityFindUniqueArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivityFindUniqueArgs>(args: SelectSubset<T, UserActivityFindUniqueArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserActivityFindUniqueOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivityFindFirstArgs>(args?: SelectSubset<T, UserActivityFindFirstArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivities
     * const userActivities = await prisma.userActivity.findMany()
     * 
     * // Get first 10 UserActivities
     * const userActivities = await prisma.userActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActivityFindManyArgs>(args?: SelectSubset<T, UserActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserActivity.
     * @param {UserActivityCreateArgs} args - Arguments to create a UserActivity.
     * @example
     * // Create one UserActivity
     * const UserActivity = await prisma.userActivity.create({
     *   data: {
     *     // ... data to create a UserActivity
     *   }
     * })
     * 
     */
    create<T extends UserActivityCreateArgs>(args: SelectSubset<T, UserActivityCreateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserActivities.
     * @param {UserActivityCreateManyArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivityCreateManyArgs>(args?: SelectSubset<T, UserActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivities and returns the data saved in the database.
     * @param {UserActivityCreateManyAndReturnArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, UserActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserActivity.
     * @param {UserActivityDeleteArgs} args - Arguments to delete one UserActivity.
     * @example
     * // Delete one UserActivity
     * const UserActivity = await prisma.userActivity.delete({
     *   where: {
     *     // ... filter to delete one UserActivity
     *   }
     * })
     * 
     */
    delete<T extends UserActivityDeleteArgs>(args: SelectSubset<T, UserActivityDeleteArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserActivity.
     * @param {UserActivityUpdateArgs} args - Arguments to update one UserActivity.
     * @example
     * // Update one UserActivity
     * const userActivity = await prisma.userActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivityUpdateArgs>(args: SelectSubset<T, UserActivityUpdateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserActivities.
     * @param {UserActivityDeleteManyArgs} args - Arguments to filter UserActivities to delete.
     * @example
     * // Delete a few UserActivities
     * const { count } = await prisma.userActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivityDeleteManyArgs>(args?: SelectSubset<T, UserActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivityUpdateManyArgs>(args: SelectSubset<T, UserActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities and returns the data updated in the database.
     * @param {UserActivityUpdateManyAndReturnArgs} args - Arguments to update many UserActivities.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, UserActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserActivity.
     * @param {UserActivityUpsertArgs} args - Arguments to update or create a UserActivity.
     * @example
     * // Update or create a UserActivity
     * const userActivity = await prisma.userActivity.upsert({
     *   create: {
     *     // ... data to create a UserActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivity we want to update
     *   }
     * })
     */
    upsert<T extends UserActivityUpsertArgs>(args: SelectSubset<T, UserActivityUpsertArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityCountArgs} args - Arguments to filter UserActivities to count.
     * @example
     * // Count the number of UserActivities
     * const count = await prisma.userActivity.count({
     *   where: {
     *     // ... the filter for the UserActivities we want to count
     *   }
     * })
    **/
    count<T extends UserActivityCountArgs>(
      args?: Subset<T, UserActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityAggregateArgs>(args: Subset<T, UserActivityAggregateArgs>): Prisma.PrismaPromise<GetUserActivityAggregateType<T>>

    /**
     * Group by UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivity model
   */
  readonly fields: UserActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivity model
   */ 
  interface UserActivityFieldRefs {
    readonly id: FieldRef<"UserActivity", 'Int'>
    readonly userId: FieldRef<"UserActivity", 'Int'>
    readonly username: FieldRef<"UserActivity", 'String'>
    readonly page: FieldRef<"UserActivity", 'String'>
    readonly loginTime: FieldRef<"UserActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivity findUnique
   */
  export type UserActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findUniqueOrThrow
   */
  export type UserActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findFirst
   */
  export type UserActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findFirstOrThrow
   */
  export type UserActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findMany
   */
  export type UserActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Filter, which UserActivities to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity create
   */
  export type UserActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The data needed to create a UserActivity.
     */
    data: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
  }

  /**
   * UserActivity createMany
   */
  export type UserActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivity createManyAndReturn
   */
  export type UserActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivity update
   */
  export type UserActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The data needed to update a UserActivity.
     */
    data: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
    /**
     * Choose, which UserActivity to update.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity updateMany
   */
  export type UserActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivities.
     */
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyInput>
    /**
     * Filter which UserActivities to update
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to update.
     */
    limit?: number
  }

  /**
   * UserActivity updateManyAndReturn
   */
  export type UserActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The data used to update UserActivities.
     */
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyInput>
    /**
     * Filter which UserActivities to update
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to update.
     */
    limit?: number
  }

  /**
   * UserActivity upsert
   */
  export type UserActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The filter to search for the UserActivity to update in case it exists.
     */
    where: UserActivityWhereUniqueInput
    /**
     * In case the UserActivity found by the `where` argument doesn't exist, create a new UserActivity with this data.
     */
    create: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
    /**
     * In case the UserActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
  }

  /**
   * UserActivity delete
   */
  export type UserActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Filter which UserActivity to delete.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity deleteMany
   */
  export type UserActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivities to delete
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to delete.
     */
    limit?: number
  }

  /**
   * UserActivity without action
   */
  export type UserActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    sequence: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    sequence: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    sequence: number | null
    remarks: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    sequence: number | null
    remarks: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    sequence: number
    remarks: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    sequence?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    sequence?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    sequence?: true
    remarks?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    sequence?: true
    remarks?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    sequence?: true
    remarks?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    sequence: number
    remarks: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    remarks?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leaders?: boolean | Team$leadersArgs<ExtArgs>
    locations?: boolean | Team$locationsArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    remarks?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    remarks?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    sequence?: boolean
    remarks?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sequence" | "remarks" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaders?: boolean | Team$leadersArgs<ExtArgs>
    locations?: boolean | Team$locationsArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      leaders: Prisma.$TeamLeaderPayload<ExtArgs>[]
      locations: Prisma.$TeamLocationPayload<ExtArgs>[]
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sequence: number
      remarks: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leaders<T extends Team$leadersArgs<ExtArgs> = {}>(args?: Subset<T, Team$leadersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    locations<T extends Team$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly sequence: FieldRef<"Team", 'Int'>
    readonly remarks: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.leaders
   */
  export type Team$leadersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    where?: TeamLeaderWhereInput
    orderBy?: TeamLeaderOrderByWithRelationInput | TeamLeaderOrderByWithRelationInput[]
    cursor?: TeamLeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamLeaderScalarFieldEnum | TeamLeaderScalarFieldEnum[]
  }

  /**
   * Team.locations
   */
  export type Team$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    where?: TeamLocationWhereInput
    orderBy?: TeamLocationOrderByWithRelationInput | TeamLocationOrderByWithRelationInput[]
    cursor?: TeamLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamLocationScalarFieldEnum | TeamLocationScalarFieldEnum[]
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamLeader
   */

  export type AggregateTeamLeader = {
    _count: TeamLeaderCountAggregateOutputType | null
    _avg: TeamLeaderAvgAggregateOutputType | null
    _sum: TeamLeaderSumAggregateOutputType | null
    _min: TeamLeaderMinAggregateOutputType | null
    _max: TeamLeaderMaxAggregateOutputType | null
  }

  export type TeamLeaderAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamLeaderSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamLeaderMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamLeaderMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamLeaderCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    _all: number
  }


  export type TeamLeaderAvgAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamLeaderSumAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamLeaderMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamLeaderMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamLeaderCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    _all?: true
  }

  export type TeamLeaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamLeader to aggregate.
     */
    where?: TeamLeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLeaders to fetch.
     */
    orderBy?: TeamLeaderOrderByWithRelationInput | TeamLeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamLeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamLeaders
    **/
    _count?: true | TeamLeaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamLeaderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamLeaderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamLeaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamLeaderMaxAggregateInputType
  }

  export type GetTeamLeaderAggregateType<T extends TeamLeaderAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamLeader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamLeader[P]>
      : GetScalarType<T[P], AggregateTeamLeader[P]>
  }




  export type TeamLeaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLeaderWhereInput
    orderBy?: TeamLeaderOrderByWithAggregationInput | TeamLeaderOrderByWithAggregationInput[]
    by: TeamLeaderScalarFieldEnum[] | TeamLeaderScalarFieldEnum
    having?: TeamLeaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamLeaderCountAggregateInputType | true
    _avg?: TeamLeaderAvgAggregateInputType
    _sum?: TeamLeaderSumAggregateInputType
    _min?: TeamLeaderMinAggregateInputType
    _max?: TeamLeaderMaxAggregateInputType
  }

  export type TeamLeaderGroupByOutputType = {
    id: number
    teamId: number
    userId: number
    _count: TeamLeaderCountAggregateOutputType | null
    _avg: TeamLeaderAvgAggregateOutputType | null
    _sum: TeamLeaderSumAggregateOutputType | null
    _min: TeamLeaderMinAggregateOutputType | null
    _max: TeamLeaderMaxAggregateOutputType | null
  }

  type GetTeamLeaderGroupByPayload<T extends TeamLeaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamLeaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamLeaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamLeaderGroupByOutputType[P]>
            : GetScalarType<T[P], TeamLeaderGroupByOutputType[P]>
        }
      >
    >


  export type TeamLeaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLeader"]>

  export type TeamLeaderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLeader"]>

  export type TeamLeaderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLeader"]>

  export type TeamLeaderSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
  }

  export type TeamLeaderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId", ExtArgs["result"]["teamLeader"]>
  export type TeamLeaderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamLeaderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamLeaderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamLeaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamLeader"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      userId: number
    }, ExtArgs["result"]["teamLeader"]>
    composites: {}
  }

  type TeamLeaderGetPayload<S extends boolean | null | undefined | TeamLeaderDefaultArgs> = $Result.GetResult<Prisma.$TeamLeaderPayload, S>

  type TeamLeaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamLeaderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamLeaderCountAggregateInputType | true
    }

  export interface TeamLeaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamLeader'], meta: { name: 'TeamLeader' } }
    /**
     * Find zero or one TeamLeader that matches the filter.
     * @param {TeamLeaderFindUniqueArgs} args - Arguments to find a TeamLeader
     * @example
     * // Get one TeamLeader
     * const teamLeader = await prisma.teamLeader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamLeaderFindUniqueArgs>(args: SelectSubset<T, TeamLeaderFindUniqueArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TeamLeader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamLeaderFindUniqueOrThrowArgs} args - Arguments to find a TeamLeader
     * @example
     * // Get one TeamLeader
     * const teamLeader = await prisma.teamLeader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamLeaderFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamLeaderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TeamLeader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderFindFirstArgs} args - Arguments to find a TeamLeader
     * @example
     * // Get one TeamLeader
     * const teamLeader = await prisma.teamLeader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamLeaderFindFirstArgs>(args?: SelectSubset<T, TeamLeaderFindFirstArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TeamLeader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderFindFirstOrThrowArgs} args - Arguments to find a TeamLeader
     * @example
     * // Get one TeamLeader
     * const teamLeader = await prisma.teamLeader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamLeaderFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamLeaderFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TeamLeaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamLeaders
     * const teamLeaders = await prisma.teamLeader.findMany()
     * 
     * // Get first 10 TeamLeaders
     * const teamLeaders = await prisma.teamLeader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamLeaderWithIdOnly = await prisma.teamLeader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamLeaderFindManyArgs>(args?: SelectSubset<T, TeamLeaderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TeamLeader.
     * @param {TeamLeaderCreateArgs} args - Arguments to create a TeamLeader.
     * @example
     * // Create one TeamLeader
     * const TeamLeader = await prisma.teamLeader.create({
     *   data: {
     *     // ... data to create a TeamLeader
     *   }
     * })
     * 
     */
    create<T extends TeamLeaderCreateArgs>(args: SelectSubset<T, TeamLeaderCreateArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TeamLeaders.
     * @param {TeamLeaderCreateManyArgs} args - Arguments to create many TeamLeaders.
     * @example
     * // Create many TeamLeaders
     * const teamLeader = await prisma.teamLeader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamLeaderCreateManyArgs>(args?: SelectSubset<T, TeamLeaderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamLeaders and returns the data saved in the database.
     * @param {TeamLeaderCreateManyAndReturnArgs} args - Arguments to create many TeamLeaders.
     * @example
     * // Create many TeamLeaders
     * const teamLeader = await prisma.teamLeader.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamLeaders and only return the `id`
     * const teamLeaderWithIdOnly = await prisma.teamLeader.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamLeaderCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamLeaderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TeamLeader.
     * @param {TeamLeaderDeleteArgs} args - Arguments to delete one TeamLeader.
     * @example
     * // Delete one TeamLeader
     * const TeamLeader = await prisma.teamLeader.delete({
     *   where: {
     *     // ... filter to delete one TeamLeader
     *   }
     * })
     * 
     */
    delete<T extends TeamLeaderDeleteArgs>(args: SelectSubset<T, TeamLeaderDeleteArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TeamLeader.
     * @param {TeamLeaderUpdateArgs} args - Arguments to update one TeamLeader.
     * @example
     * // Update one TeamLeader
     * const teamLeader = await prisma.teamLeader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamLeaderUpdateArgs>(args: SelectSubset<T, TeamLeaderUpdateArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TeamLeaders.
     * @param {TeamLeaderDeleteManyArgs} args - Arguments to filter TeamLeaders to delete.
     * @example
     * // Delete a few TeamLeaders
     * const { count } = await prisma.teamLeader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamLeaderDeleteManyArgs>(args?: SelectSubset<T, TeamLeaderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamLeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamLeaders
     * const teamLeader = await prisma.teamLeader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamLeaderUpdateManyArgs>(args: SelectSubset<T, TeamLeaderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamLeaders and returns the data updated in the database.
     * @param {TeamLeaderUpdateManyAndReturnArgs} args - Arguments to update many TeamLeaders.
     * @example
     * // Update many TeamLeaders
     * const teamLeader = await prisma.teamLeader.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamLeaders and only return the `id`
     * const teamLeaderWithIdOnly = await prisma.teamLeader.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamLeaderUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamLeaderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TeamLeader.
     * @param {TeamLeaderUpsertArgs} args - Arguments to update or create a TeamLeader.
     * @example
     * // Update or create a TeamLeader
     * const teamLeader = await prisma.teamLeader.upsert({
     *   create: {
     *     // ... data to create a TeamLeader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamLeader we want to update
     *   }
     * })
     */
    upsert<T extends TeamLeaderUpsertArgs>(args: SelectSubset<T, TeamLeaderUpsertArgs<ExtArgs>>): Prisma__TeamLeaderClient<$Result.GetResult<Prisma.$TeamLeaderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TeamLeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderCountArgs} args - Arguments to filter TeamLeaders to count.
     * @example
     * // Count the number of TeamLeaders
     * const count = await prisma.teamLeader.count({
     *   where: {
     *     // ... the filter for the TeamLeaders we want to count
     *   }
     * })
    **/
    count<T extends TeamLeaderCountArgs>(
      args?: Subset<T, TeamLeaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamLeaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamLeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamLeaderAggregateArgs>(args: Subset<T, TeamLeaderAggregateArgs>): Prisma.PrismaPromise<GetTeamLeaderAggregateType<T>>

    /**
     * Group by TeamLeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLeaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamLeaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamLeaderGroupByArgs['orderBy'] }
        : { orderBy?: TeamLeaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamLeaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamLeaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamLeader model
   */
  readonly fields: TeamLeaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamLeader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamLeaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamLeader model
   */ 
  interface TeamLeaderFieldRefs {
    readonly id: FieldRef<"TeamLeader", 'Int'>
    readonly teamId: FieldRef<"TeamLeader", 'Int'>
    readonly userId: FieldRef<"TeamLeader", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamLeader findUnique
   */
  export type TeamLeaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * Filter, which TeamLeader to fetch.
     */
    where: TeamLeaderWhereUniqueInput
  }

  /**
   * TeamLeader findUniqueOrThrow
   */
  export type TeamLeaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * Filter, which TeamLeader to fetch.
     */
    where: TeamLeaderWhereUniqueInput
  }

  /**
   * TeamLeader findFirst
   */
  export type TeamLeaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * Filter, which TeamLeader to fetch.
     */
    where?: TeamLeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLeaders to fetch.
     */
    orderBy?: TeamLeaderOrderByWithRelationInput | TeamLeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamLeaders.
     */
    cursor?: TeamLeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamLeaders.
     */
    distinct?: TeamLeaderScalarFieldEnum | TeamLeaderScalarFieldEnum[]
  }

  /**
   * TeamLeader findFirstOrThrow
   */
  export type TeamLeaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * Filter, which TeamLeader to fetch.
     */
    where?: TeamLeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLeaders to fetch.
     */
    orderBy?: TeamLeaderOrderByWithRelationInput | TeamLeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamLeaders.
     */
    cursor?: TeamLeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamLeaders.
     */
    distinct?: TeamLeaderScalarFieldEnum | TeamLeaderScalarFieldEnum[]
  }

  /**
   * TeamLeader findMany
   */
  export type TeamLeaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * Filter, which TeamLeaders to fetch.
     */
    where?: TeamLeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLeaders to fetch.
     */
    orderBy?: TeamLeaderOrderByWithRelationInput | TeamLeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamLeaders.
     */
    cursor?: TeamLeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLeaders.
     */
    skip?: number
    distinct?: TeamLeaderScalarFieldEnum | TeamLeaderScalarFieldEnum[]
  }

  /**
   * TeamLeader create
   */
  export type TeamLeaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamLeader.
     */
    data: XOR<TeamLeaderCreateInput, TeamLeaderUncheckedCreateInput>
  }

  /**
   * TeamLeader createMany
   */
  export type TeamLeaderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamLeaders.
     */
    data: TeamLeaderCreateManyInput | TeamLeaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamLeader createManyAndReturn
   */
  export type TeamLeaderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * The data used to create many TeamLeaders.
     */
    data: TeamLeaderCreateManyInput | TeamLeaderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamLeader update
   */
  export type TeamLeaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamLeader.
     */
    data: XOR<TeamLeaderUpdateInput, TeamLeaderUncheckedUpdateInput>
    /**
     * Choose, which TeamLeader to update.
     */
    where: TeamLeaderWhereUniqueInput
  }

  /**
   * TeamLeader updateMany
   */
  export type TeamLeaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamLeaders.
     */
    data: XOR<TeamLeaderUpdateManyMutationInput, TeamLeaderUncheckedUpdateManyInput>
    /**
     * Filter which TeamLeaders to update
     */
    where?: TeamLeaderWhereInput
    /**
     * Limit how many TeamLeaders to update.
     */
    limit?: number
  }

  /**
   * TeamLeader updateManyAndReturn
   */
  export type TeamLeaderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * The data used to update TeamLeaders.
     */
    data: XOR<TeamLeaderUpdateManyMutationInput, TeamLeaderUncheckedUpdateManyInput>
    /**
     * Filter which TeamLeaders to update
     */
    where?: TeamLeaderWhereInput
    /**
     * Limit how many TeamLeaders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamLeader upsert
   */
  export type TeamLeaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamLeader to update in case it exists.
     */
    where: TeamLeaderWhereUniqueInput
    /**
     * In case the TeamLeader found by the `where` argument doesn't exist, create a new TeamLeader with this data.
     */
    create: XOR<TeamLeaderCreateInput, TeamLeaderUncheckedCreateInput>
    /**
     * In case the TeamLeader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamLeaderUpdateInput, TeamLeaderUncheckedUpdateInput>
  }

  /**
   * TeamLeader delete
   */
  export type TeamLeaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
    /**
     * Filter which TeamLeader to delete.
     */
    where: TeamLeaderWhereUniqueInput
  }

  /**
   * TeamLeader deleteMany
   */
  export type TeamLeaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamLeaders to delete
     */
    where?: TeamLeaderWhereInput
    /**
     * Limit how many TeamLeaders to delete.
     */
    limit?: number
  }

  /**
   * TeamLeader without action
   */
  export type TeamLeaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLeader
     */
    select?: TeamLeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLeader
     */
    omit?: TeamLeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLeaderInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberSumAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: number
    teamId: number
    userId: number
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      userId: number
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'Int'>
    readonly teamId: FieldRef<"TeamMember", 'Int'>
    readonly userId: FieldRef<"TeamMember", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model TeamLocation
   */

  export type AggregateTeamLocation = {
    _count: TeamLocationCountAggregateOutputType | null
    _avg: TeamLocationAvgAggregateOutputType | null
    _sum: TeamLocationSumAggregateOutputType | null
    _min: TeamLocationMinAggregateOutputType | null
    _max: TeamLocationMaxAggregateOutputType | null
  }

  export type TeamLocationAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    locationId: number | null
  }

  export type TeamLocationSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    locationId: number | null
  }

  export type TeamLocationMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    locationId: number | null
  }

  export type TeamLocationMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    locationId: number | null
  }

  export type TeamLocationCountAggregateOutputType = {
    id: number
    teamId: number
    locationId: number
    _all: number
  }


  export type TeamLocationAvgAggregateInputType = {
    id?: true
    teamId?: true
    locationId?: true
  }

  export type TeamLocationSumAggregateInputType = {
    id?: true
    teamId?: true
    locationId?: true
  }

  export type TeamLocationMinAggregateInputType = {
    id?: true
    teamId?: true
    locationId?: true
  }

  export type TeamLocationMaxAggregateInputType = {
    id?: true
    teamId?: true
    locationId?: true
  }

  export type TeamLocationCountAggregateInputType = {
    id?: true
    teamId?: true
    locationId?: true
    _all?: true
  }

  export type TeamLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamLocation to aggregate.
     */
    where?: TeamLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLocations to fetch.
     */
    orderBy?: TeamLocationOrderByWithRelationInput | TeamLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamLocations
    **/
    _count?: true | TeamLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamLocationMaxAggregateInputType
  }

  export type GetTeamLocationAggregateType<T extends TeamLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamLocation[P]>
      : GetScalarType<T[P], AggregateTeamLocation[P]>
  }




  export type TeamLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamLocationWhereInput
    orderBy?: TeamLocationOrderByWithAggregationInput | TeamLocationOrderByWithAggregationInput[]
    by: TeamLocationScalarFieldEnum[] | TeamLocationScalarFieldEnum
    having?: TeamLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamLocationCountAggregateInputType | true
    _avg?: TeamLocationAvgAggregateInputType
    _sum?: TeamLocationSumAggregateInputType
    _min?: TeamLocationMinAggregateInputType
    _max?: TeamLocationMaxAggregateInputType
  }

  export type TeamLocationGroupByOutputType = {
    id: number
    teamId: number
    locationId: number
    _count: TeamLocationCountAggregateOutputType | null
    _avg: TeamLocationAvgAggregateOutputType | null
    _sum: TeamLocationSumAggregateOutputType | null
    _min: TeamLocationMinAggregateOutputType | null
    _max: TeamLocationMaxAggregateOutputType | null
  }

  type GetTeamLocationGroupByPayload<T extends TeamLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamLocationGroupByOutputType[P]>
            : GetScalarType<T[P], TeamLocationGroupByOutputType[P]>
        }
      >
    >


  export type TeamLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    locationId?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLocation"]>

  export type TeamLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    locationId?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLocation"]>

  export type TeamLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    locationId?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamLocation"]>

  export type TeamLocationSelectScalar = {
    id?: boolean
    teamId?: boolean
    locationId?: boolean
  }

  export type TeamLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "locationId", ExtArgs["result"]["teamLocation"]>
  export type TeamLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamLocation"
    objects: {
      location: Prisma.$locationPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      locationId: number
    }, ExtArgs["result"]["teamLocation"]>
    composites: {}
  }

  type TeamLocationGetPayload<S extends boolean | null | undefined | TeamLocationDefaultArgs> = $Result.GetResult<Prisma.$TeamLocationPayload, S>

  type TeamLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamLocationCountAggregateInputType | true
    }

  export interface TeamLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamLocation'], meta: { name: 'TeamLocation' } }
    /**
     * Find zero or one TeamLocation that matches the filter.
     * @param {TeamLocationFindUniqueArgs} args - Arguments to find a TeamLocation
     * @example
     * // Get one TeamLocation
     * const teamLocation = await prisma.teamLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamLocationFindUniqueArgs>(args: SelectSubset<T, TeamLocationFindUniqueArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TeamLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamLocationFindUniqueOrThrowArgs} args - Arguments to find a TeamLocation
     * @example
     * // Get one TeamLocation
     * const teamLocation = await prisma.teamLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TeamLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationFindFirstArgs} args - Arguments to find a TeamLocation
     * @example
     * // Get one TeamLocation
     * const teamLocation = await prisma.teamLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamLocationFindFirstArgs>(args?: SelectSubset<T, TeamLocationFindFirstArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TeamLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationFindFirstOrThrowArgs} args - Arguments to find a TeamLocation
     * @example
     * // Get one TeamLocation
     * const teamLocation = await prisma.teamLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TeamLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamLocations
     * const teamLocations = await prisma.teamLocation.findMany()
     * 
     * // Get first 10 TeamLocations
     * const teamLocations = await prisma.teamLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamLocationWithIdOnly = await prisma.teamLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamLocationFindManyArgs>(args?: SelectSubset<T, TeamLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TeamLocation.
     * @param {TeamLocationCreateArgs} args - Arguments to create a TeamLocation.
     * @example
     * // Create one TeamLocation
     * const TeamLocation = await prisma.teamLocation.create({
     *   data: {
     *     // ... data to create a TeamLocation
     *   }
     * })
     * 
     */
    create<T extends TeamLocationCreateArgs>(args: SelectSubset<T, TeamLocationCreateArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TeamLocations.
     * @param {TeamLocationCreateManyArgs} args - Arguments to create many TeamLocations.
     * @example
     * // Create many TeamLocations
     * const teamLocation = await prisma.teamLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamLocationCreateManyArgs>(args?: SelectSubset<T, TeamLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamLocations and returns the data saved in the database.
     * @param {TeamLocationCreateManyAndReturnArgs} args - Arguments to create many TeamLocations.
     * @example
     * // Create many TeamLocations
     * const teamLocation = await prisma.teamLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamLocations and only return the `id`
     * const teamLocationWithIdOnly = await prisma.teamLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TeamLocation.
     * @param {TeamLocationDeleteArgs} args - Arguments to delete one TeamLocation.
     * @example
     * // Delete one TeamLocation
     * const TeamLocation = await prisma.teamLocation.delete({
     *   where: {
     *     // ... filter to delete one TeamLocation
     *   }
     * })
     * 
     */
    delete<T extends TeamLocationDeleteArgs>(args: SelectSubset<T, TeamLocationDeleteArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TeamLocation.
     * @param {TeamLocationUpdateArgs} args - Arguments to update one TeamLocation.
     * @example
     * // Update one TeamLocation
     * const teamLocation = await prisma.teamLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamLocationUpdateArgs>(args: SelectSubset<T, TeamLocationUpdateArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TeamLocations.
     * @param {TeamLocationDeleteManyArgs} args - Arguments to filter TeamLocations to delete.
     * @example
     * // Delete a few TeamLocations
     * const { count } = await prisma.teamLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamLocationDeleteManyArgs>(args?: SelectSubset<T, TeamLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamLocations
     * const teamLocation = await prisma.teamLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamLocationUpdateManyArgs>(args: SelectSubset<T, TeamLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamLocations and returns the data updated in the database.
     * @param {TeamLocationUpdateManyAndReturnArgs} args - Arguments to update many TeamLocations.
     * @example
     * // Update many TeamLocations
     * const teamLocation = await prisma.teamLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamLocations and only return the `id`
     * const teamLocationWithIdOnly = await prisma.teamLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TeamLocation.
     * @param {TeamLocationUpsertArgs} args - Arguments to update or create a TeamLocation.
     * @example
     * // Update or create a TeamLocation
     * const teamLocation = await prisma.teamLocation.upsert({
     *   create: {
     *     // ... data to create a TeamLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamLocation we want to update
     *   }
     * })
     */
    upsert<T extends TeamLocationUpsertArgs>(args: SelectSubset<T, TeamLocationUpsertArgs<ExtArgs>>): Prisma__TeamLocationClient<$Result.GetResult<Prisma.$TeamLocationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TeamLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationCountArgs} args - Arguments to filter TeamLocations to count.
     * @example
     * // Count the number of TeamLocations
     * const count = await prisma.teamLocation.count({
     *   where: {
     *     // ... the filter for the TeamLocations we want to count
     *   }
     * })
    **/
    count<T extends TeamLocationCountArgs>(
      args?: Subset<T, TeamLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamLocationAggregateArgs>(args: Subset<T, TeamLocationAggregateArgs>): Prisma.PrismaPromise<GetTeamLocationAggregateType<T>>

    /**
     * Group by TeamLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamLocationGroupByArgs['orderBy'] }
        : { orderBy?: TeamLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamLocation model
   */
  readonly fields: TeamLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends locationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationDefaultArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamLocation model
   */ 
  interface TeamLocationFieldRefs {
    readonly id: FieldRef<"TeamLocation", 'Int'>
    readonly teamId: FieldRef<"TeamLocation", 'Int'>
    readonly locationId: FieldRef<"TeamLocation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamLocation findUnique
   */
  export type TeamLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * Filter, which TeamLocation to fetch.
     */
    where: TeamLocationWhereUniqueInput
  }

  /**
   * TeamLocation findUniqueOrThrow
   */
  export type TeamLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * Filter, which TeamLocation to fetch.
     */
    where: TeamLocationWhereUniqueInput
  }

  /**
   * TeamLocation findFirst
   */
  export type TeamLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * Filter, which TeamLocation to fetch.
     */
    where?: TeamLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLocations to fetch.
     */
    orderBy?: TeamLocationOrderByWithRelationInput | TeamLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamLocations.
     */
    cursor?: TeamLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamLocations.
     */
    distinct?: TeamLocationScalarFieldEnum | TeamLocationScalarFieldEnum[]
  }

  /**
   * TeamLocation findFirstOrThrow
   */
  export type TeamLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * Filter, which TeamLocation to fetch.
     */
    where?: TeamLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLocations to fetch.
     */
    orderBy?: TeamLocationOrderByWithRelationInput | TeamLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamLocations.
     */
    cursor?: TeamLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamLocations.
     */
    distinct?: TeamLocationScalarFieldEnum | TeamLocationScalarFieldEnum[]
  }

  /**
   * TeamLocation findMany
   */
  export type TeamLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * Filter, which TeamLocations to fetch.
     */
    where?: TeamLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamLocations to fetch.
     */
    orderBy?: TeamLocationOrderByWithRelationInput | TeamLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamLocations.
     */
    cursor?: TeamLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamLocations.
     */
    skip?: number
    distinct?: TeamLocationScalarFieldEnum | TeamLocationScalarFieldEnum[]
  }

  /**
   * TeamLocation create
   */
  export type TeamLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamLocation.
     */
    data: XOR<TeamLocationCreateInput, TeamLocationUncheckedCreateInput>
  }

  /**
   * TeamLocation createMany
   */
  export type TeamLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamLocations.
     */
    data: TeamLocationCreateManyInput | TeamLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamLocation createManyAndReturn
   */
  export type TeamLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * The data used to create many TeamLocations.
     */
    data: TeamLocationCreateManyInput | TeamLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamLocation update
   */
  export type TeamLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamLocation.
     */
    data: XOR<TeamLocationUpdateInput, TeamLocationUncheckedUpdateInput>
    /**
     * Choose, which TeamLocation to update.
     */
    where: TeamLocationWhereUniqueInput
  }

  /**
   * TeamLocation updateMany
   */
  export type TeamLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamLocations.
     */
    data: XOR<TeamLocationUpdateManyMutationInput, TeamLocationUncheckedUpdateManyInput>
    /**
     * Filter which TeamLocations to update
     */
    where?: TeamLocationWhereInput
    /**
     * Limit how many TeamLocations to update.
     */
    limit?: number
  }

  /**
   * TeamLocation updateManyAndReturn
   */
  export type TeamLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * The data used to update TeamLocations.
     */
    data: XOR<TeamLocationUpdateManyMutationInput, TeamLocationUncheckedUpdateManyInput>
    /**
     * Filter which TeamLocations to update
     */
    where?: TeamLocationWhereInput
    /**
     * Limit how many TeamLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamLocation upsert
   */
  export type TeamLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamLocation to update in case it exists.
     */
    where: TeamLocationWhereUniqueInput
    /**
     * In case the TeamLocation found by the `where` argument doesn't exist, create a new TeamLocation with this data.
     */
    create: XOR<TeamLocationCreateInput, TeamLocationUncheckedCreateInput>
    /**
     * In case the TeamLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamLocationUpdateInput, TeamLocationUncheckedUpdateInput>
  }

  /**
   * TeamLocation delete
   */
  export type TeamLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
    /**
     * Filter which TeamLocation to delete.
     */
    where: TeamLocationWhereUniqueInput
  }

  /**
   * TeamLocation deleteMany
   */
  export type TeamLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamLocations to delete
     */
    where?: TeamLocationWhereInput
    /**
     * Limit how many TeamLocations to delete.
     */
    limit?: number
  }

  /**
   * TeamLocation without action
   */
  export type TeamLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamLocation
     */
    select?: TeamLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamLocation
     */
    omit?: TeamLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamLocationInclude<ExtArgs> | null
  }


  /**
   * Model AuditWorkflow
   */

  export type AggregateAuditWorkflow = {
    _count: AuditWorkflowCountAggregateOutputType | null
    _avg: AuditWorkflowAvgAggregateOutputType | null
    _sum: AuditWorkflowSumAggregateOutputType | null
    _min: AuditWorkflowMinAggregateOutputType | null
    _max: AuditWorkflowMaxAggregateOutputType | null
  }

  export type AuditWorkflowAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditWorkflowSumAggregateOutputType = {
    id: number | null
  }

  export type AuditWorkflowMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditWorkflowMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditWorkflowCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditWorkflowAvgAggregateInputType = {
    id?: true
  }

  export type AuditWorkflowSumAggregateInputType = {
    id?: true
  }

  export type AuditWorkflowMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditWorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditWorkflowCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditWorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditWorkflow to aggregate.
     */
    where?: AuditWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditWorkflows to fetch.
     */
    orderBy?: AuditWorkflowOrderByWithRelationInput | AuditWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditWorkflows
    **/
    _count?: true | AuditWorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditWorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditWorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditWorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditWorkflowMaxAggregateInputType
  }

  export type GetAuditWorkflowAggregateType<T extends AuditWorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditWorkflow[P]>
      : GetScalarType<T[P], AggregateAuditWorkflow[P]>
  }




  export type AuditWorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWorkflowWhereInput
    orderBy?: AuditWorkflowOrderByWithAggregationInput | AuditWorkflowOrderByWithAggregationInput[]
    by: AuditWorkflowScalarFieldEnum[] | AuditWorkflowScalarFieldEnum
    having?: AuditWorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditWorkflowCountAggregateInputType | true
    _avg?: AuditWorkflowAvgAggregateInputType
    _sum?: AuditWorkflowSumAggregateInputType
    _min?: AuditWorkflowMinAggregateInputType
    _max?: AuditWorkflowMaxAggregateInputType
  }

  export type AuditWorkflowGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuditWorkflowCountAggregateOutputType | null
    _avg: AuditWorkflowAvgAggregateOutputType | null
    _sum: AuditWorkflowSumAggregateOutputType | null
    _min: AuditWorkflowMinAggregateOutputType | null
    _max: AuditWorkflowMaxAggregateOutputType | null
  }

  type GetAuditWorkflowGroupByPayload<T extends AuditWorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditWorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditWorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditWorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], AuditWorkflowGroupByOutputType[P]>
        }
      >
    >


  export type AuditWorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steps?: boolean | AuditWorkflow$stepsArgs<ExtArgs>
    _count?: boolean | AuditWorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditWorkflow"]>

  export type AuditWorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["auditWorkflow"]>

  export type AuditWorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["auditWorkflow"]>

  export type AuditWorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditWorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["auditWorkflow"]>
  export type AuditWorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | AuditWorkflow$stepsArgs<ExtArgs>
    _count?: boolean | AuditWorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditWorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AuditWorkflowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuditWorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditWorkflow"
    objects: {
      steps: Prisma.$AuditStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditWorkflow"]>
    composites: {}
  }

  type AuditWorkflowGetPayload<S extends boolean | null | undefined | AuditWorkflowDefaultArgs> = $Result.GetResult<Prisma.$AuditWorkflowPayload, S>

  type AuditWorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditWorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditWorkflowCountAggregateInputType | true
    }

  export interface AuditWorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditWorkflow'], meta: { name: 'AuditWorkflow' } }
    /**
     * Find zero or one AuditWorkflow that matches the filter.
     * @param {AuditWorkflowFindUniqueArgs} args - Arguments to find a AuditWorkflow
     * @example
     * // Get one AuditWorkflow
     * const auditWorkflow = await prisma.auditWorkflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditWorkflowFindUniqueArgs>(args: SelectSubset<T, AuditWorkflowFindUniqueArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AuditWorkflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditWorkflowFindUniqueOrThrowArgs} args - Arguments to find a AuditWorkflow
     * @example
     * // Get one AuditWorkflow
     * const auditWorkflow = await prisma.auditWorkflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditWorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditWorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AuditWorkflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowFindFirstArgs} args - Arguments to find a AuditWorkflow
     * @example
     * // Get one AuditWorkflow
     * const auditWorkflow = await prisma.auditWorkflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditWorkflowFindFirstArgs>(args?: SelectSubset<T, AuditWorkflowFindFirstArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AuditWorkflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowFindFirstOrThrowArgs} args - Arguments to find a AuditWorkflow
     * @example
     * // Get one AuditWorkflow
     * const auditWorkflow = await prisma.auditWorkflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditWorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditWorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AuditWorkflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditWorkflows
     * const auditWorkflows = await prisma.auditWorkflow.findMany()
     * 
     * // Get first 10 AuditWorkflows
     * const auditWorkflows = await prisma.auditWorkflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWorkflowWithIdOnly = await prisma.auditWorkflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditWorkflowFindManyArgs>(args?: SelectSubset<T, AuditWorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AuditWorkflow.
     * @param {AuditWorkflowCreateArgs} args - Arguments to create a AuditWorkflow.
     * @example
     * // Create one AuditWorkflow
     * const AuditWorkflow = await prisma.auditWorkflow.create({
     *   data: {
     *     // ... data to create a AuditWorkflow
     *   }
     * })
     * 
     */
    create<T extends AuditWorkflowCreateArgs>(args: SelectSubset<T, AuditWorkflowCreateArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AuditWorkflows.
     * @param {AuditWorkflowCreateManyArgs} args - Arguments to create many AuditWorkflows.
     * @example
     * // Create many AuditWorkflows
     * const auditWorkflow = await prisma.auditWorkflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditWorkflowCreateManyArgs>(args?: SelectSubset<T, AuditWorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditWorkflows and returns the data saved in the database.
     * @param {AuditWorkflowCreateManyAndReturnArgs} args - Arguments to create many AuditWorkflows.
     * @example
     * // Create many AuditWorkflows
     * const auditWorkflow = await prisma.auditWorkflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditWorkflows and only return the `id`
     * const auditWorkflowWithIdOnly = await prisma.auditWorkflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditWorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditWorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AuditWorkflow.
     * @param {AuditWorkflowDeleteArgs} args - Arguments to delete one AuditWorkflow.
     * @example
     * // Delete one AuditWorkflow
     * const AuditWorkflow = await prisma.auditWorkflow.delete({
     *   where: {
     *     // ... filter to delete one AuditWorkflow
     *   }
     * })
     * 
     */
    delete<T extends AuditWorkflowDeleteArgs>(args: SelectSubset<T, AuditWorkflowDeleteArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AuditWorkflow.
     * @param {AuditWorkflowUpdateArgs} args - Arguments to update one AuditWorkflow.
     * @example
     * // Update one AuditWorkflow
     * const auditWorkflow = await prisma.auditWorkflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditWorkflowUpdateArgs>(args: SelectSubset<T, AuditWorkflowUpdateArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AuditWorkflows.
     * @param {AuditWorkflowDeleteManyArgs} args - Arguments to filter AuditWorkflows to delete.
     * @example
     * // Delete a few AuditWorkflows
     * const { count } = await prisma.auditWorkflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditWorkflowDeleteManyArgs>(args?: SelectSubset<T, AuditWorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditWorkflows
     * const auditWorkflow = await prisma.auditWorkflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditWorkflowUpdateManyArgs>(args: SelectSubset<T, AuditWorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditWorkflows and returns the data updated in the database.
     * @param {AuditWorkflowUpdateManyAndReturnArgs} args - Arguments to update many AuditWorkflows.
     * @example
     * // Update many AuditWorkflows
     * const auditWorkflow = await prisma.auditWorkflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditWorkflows and only return the `id`
     * const auditWorkflowWithIdOnly = await prisma.auditWorkflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditWorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditWorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AuditWorkflow.
     * @param {AuditWorkflowUpsertArgs} args - Arguments to update or create a AuditWorkflow.
     * @example
     * // Update or create a AuditWorkflow
     * const auditWorkflow = await prisma.auditWorkflow.upsert({
     *   create: {
     *     // ... data to create a AuditWorkflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditWorkflow we want to update
     *   }
     * })
     */
    upsert<T extends AuditWorkflowUpsertArgs>(args: SelectSubset<T, AuditWorkflowUpsertArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AuditWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowCountArgs} args - Arguments to filter AuditWorkflows to count.
     * @example
     * // Count the number of AuditWorkflows
     * const count = await prisma.auditWorkflow.count({
     *   where: {
     *     // ... the filter for the AuditWorkflows we want to count
     *   }
     * })
    **/
    count<T extends AuditWorkflowCountArgs>(
      args?: Subset<T, AuditWorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditWorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditWorkflowAggregateArgs>(args: Subset<T, AuditWorkflowAggregateArgs>): Prisma.PrismaPromise<GetAuditWorkflowAggregateType<T>>

    /**
     * Group by AuditWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditWorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditWorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditWorkflowGroupByArgs['orderBy'] }
        : { orderBy?: AuditWorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditWorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditWorkflow model
   */
  readonly fields: AuditWorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditWorkflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditWorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steps<T extends AuditWorkflow$stepsArgs<ExtArgs> = {}>(args?: Subset<T, AuditWorkflow$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditWorkflow model
   */ 
  interface AuditWorkflowFieldRefs {
    readonly id: FieldRef<"AuditWorkflow", 'Int'>
    readonly name: FieldRef<"AuditWorkflow", 'String'>
    readonly description: FieldRef<"AuditWorkflow", 'String'>
    readonly createdAt: FieldRef<"AuditWorkflow", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditWorkflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditWorkflow findUnique
   */
  export type AuditWorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which AuditWorkflow to fetch.
     */
    where: AuditWorkflowWhereUniqueInput
  }

  /**
   * AuditWorkflow findUniqueOrThrow
   */
  export type AuditWorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which AuditWorkflow to fetch.
     */
    where: AuditWorkflowWhereUniqueInput
  }

  /**
   * AuditWorkflow findFirst
   */
  export type AuditWorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which AuditWorkflow to fetch.
     */
    where?: AuditWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditWorkflows to fetch.
     */
    orderBy?: AuditWorkflowOrderByWithRelationInput | AuditWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditWorkflows.
     */
    cursor?: AuditWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditWorkflows.
     */
    distinct?: AuditWorkflowScalarFieldEnum | AuditWorkflowScalarFieldEnum[]
  }

  /**
   * AuditWorkflow findFirstOrThrow
   */
  export type AuditWorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which AuditWorkflow to fetch.
     */
    where?: AuditWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditWorkflows to fetch.
     */
    orderBy?: AuditWorkflowOrderByWithRelationInput | AuditWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditWorkflows.
     */
    cursor?: AuditWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditWorkflows.
     */
    distinct?: AuditWorkflowScalarFieldEnum | AuditWorkflowScalarFieldEnum[]
  }

  /**
   * AuditWorkflow findMany
   */
  export type AuditWorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which AuditWorkflows to fetch.
     */
    where?: AuditWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditWorkflows to fetch.
     */
    orderBy?: AuditWorkflowOrderByWithRelationInput | AuditWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditWorkflows.
     */
    cursor?: AuditWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditWorkflows.
     */
    skip?: number
    distinct?: AuditWorkflowScalarFieldEnum | AuditWorkflowScalarFieldEnum[]
  }

  /**
   * AuditWorkflow create
   */
  export type AuditWorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditWorkflow.
     */
    data: XOR<AuditWorkflowCreateInput, AuditWorkflowUncheckedCreateInput>
  }

  /**
   * AuditWorkflow createMany
   */
  export type AuditWorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditWorkflows.
     */
    data: AuditWorkflowCreateManyInput | AuditWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditWorkflow createManyAndReturn
   */
  export type AuditWorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many AuditWorkflows.
     */
    data: AuditWorkflowCreateManyInput | AuditWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditWorkflow update
   */
  export type AuditWorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditWorkflow.
     */
    data: XOR<AuditWorkflowUpdateInput, AuditWorkflowUncheckedUpdateInput>
    /**
     * Choose, which AuditWorkflow to update.
     */
    where: AuditWorkflowWhereUniqueInput
  }

  /**
   * AuditWorkflow updateMany
   */
  export type AuditWorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditWorkflows.
     */
    data: XOR<AuditWorkflowUpdateManyMutationInput, AuditWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which AuditWorkflows to update
     */
    where?: AuditWorkflowWhereInput
    /**
     * Limit how many AuditWorkflows to update.
     */
    limit?: number
  }

  /**
   * AuditWorkflow updateManyAndReturn
   */
  export type AuditWorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * The data used to update AuditWorkflows.
     */
    data: XOR<AuditWorkflowUpdateManyMutationInput, AuditWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which AuditWorkflows to update
     */
    where?: AuditWorkflowWhereInput
    /**
     * Limit how many AuditWorkflows to update.
     */
    limit?: number
  }

  /**
   * AuditWorkflow upsert
   */
  export type AuditWorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditWorkflow to update in case it exists.
     */
    where: AuditWorkflowWhereUniqueInput
    /**
     * In case the AuditWorkflow found by the `where` argument doesn't exist, create a new AuditWorkflow with this data.
     */
    create: XOR<AuditWorkflowCreateInput, AuditWorkflowUncheckedCreateInput>
    /**
     * In case the AuditWorkflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditWorkflowUpdateInput, AuditWorkflowUncheckedUpdateInput>
  }

  /**
   * AuditWorkflow delete
   */
  export type AuditWorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
    /**
     * Filter which AuditWorkflow to delete.
     */
    where: AuditWorkflowWhereUniqueInput
  }

  /**
   * AuditWorkflow deleteMany
   */
  export type AuditWorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditWorkflows to delete
     */
    where?: AuditWorkflowWhereInput
    /**
     * Limit how many AuditWorkflows to delete.
     */
    limit?: number
  }

  /**
   * AuditWorkflow.steps
   */
  export type AuditWorkflow$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    where?: AuditStepWhereInput
    orderBy?: AuditStepOrderByWithRelationInput | AuditStepOrderByWithRelationInput[]
    cursor?: AuditStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditStepScalarFieldEnum | AuditStepScalarFieldEnum[]
  }

  /**
   * AuditWorkflow without action
   */
  export type AuditWorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditWorkflow
     */
    select?: AuditWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditWorkflow
     */
    omit?: AuditWorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditWorkflowInclude<ExtArgs> | null
  }


  /**
   * Model AuditStep
   */

  export type AggregateAuditStep = {
    _count: AuditStepCountAggregateOutputType | null
    _avg: AuditStepAvgAggregateOutputType | null
    _sum: AuditStepSumAggregateOutputType | null
    _min: AuditStepMinAggregateOutputType | null
    _max: AuditStepMaxAggregateOutputType | null
  }

  export type AuditStepAvgAggregateOutputType = {
    id: number | null
    position: number | null
    assignedToId: number | null
    workflowId: number | null
  }

  export type AuditStepSumAggregateOutputType = {
    id: number | null
    position: number | null
    assignedToId: number | null
    workflowId: number | null
  }

  export type AuditStepMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    position: number | null
    status: $Enums.StepStatus | null
    assignedToId: number | null
    dueDate: Date | null
    workflowId: number | null
  }

  export type AuditStepMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    position: number | null
    status: $Enums.StepStatus | null
    assignedToId: number | null
    dueDate: Date | null
    workflowId: number | null
  }

  export type AuditStepCountAggregateOutputType = {
    id: number
    title: number
    description: number
    position: number
    status: number
    assignedToId: number
    dueDate: number
    workflowId: number
    _all: number
  }


  export type AuditStepAvgAggregateInputType = {
    id?: true
    position?: true
    assignedToId?: true
    workflowId?: true
  }

  export type AuditStepSumAggregateInputType = {
    id?: true
    position?: true
    assignedToId?: true
    workflowId?: true
  }

  export type AuditStepMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    position?: true
    status?: true
    assignedToId?: true
    dueDate?: true
    workflowId?: true
  }

  export type AuditStepMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    position?: true
    status?: true
    assignedToId?: true
    dueDate?: true
    workflowId?: true
  }

  export type AuditStepCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    position?: true
    status?: true
    assignedToId?: true
    dueDate?: true
    workflowId?: true
    _all?: true
  }

  export type AuditStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditStep to aggregate.
     */
    where?: AuditStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditSteps to fetch.
     */
    orderBy?: AuditStepOrderByWithRelationInput | AuditStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditSteps
    **/
    _count?: true | AuditStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditStepMaxAggregateInputType
  }

  export type GetAuditStepAggregateType<T extends AuditStepAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditStep[P]>
      : GetScalarType<T[P], AggregateAuditStep[P]>
  }




  export type AuditStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditStepWhereInput
    orderBy?: AuditStepOrderByWithAggregationInput | AuditStepOrderByWithAggregationInput[]
    by: AuditStepScalarFieldEnum[] | AuditStepScalarFieldEnum
    having?: AuditStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditStepCountAggregateInputType | true
    _avg?: AuditStepAvgAggregateInputType
    _sum?: AuditStepSumAggregateInputType
    _min?: AuditStepMinAggregateInputType
    _max?: AuditStepMaxAggregateInputType
  }

  export type AuditStepGroupByOutputType = {
    id: number
    title: string
    description: string | null
    position: number
    status: $Enums.StepStatus
    assignedToId: number | null
    dueDate: Date | null
    workflowId: number
    _count: AuditStepCountAggregateOutputType | null
    _avg: AuditStepAvgAggregateOutputType | null
    _sum: AuditStepSumAggregateOutputType | null
    _min: AuditStepMinAggregateOutputType | null
    _max: AuditStepMaxAggregateOutputType | null
  }

  type GetAuditStepGroupByPayload<T extends AuditStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditStepGroupByOutputType[P]>
            : GetScalarType<T[P], AuditStepGroupByOutputType[P]>
        }
      >
    >


  export type AuditStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    workflowId?: boolean
    workflow?: boolean | AuditWorkflowDefaultArgs<ExtArgs>
    assignedTo?: boolean | AuditStep$assignedToArgs<ExtArgs>
    logs?: boolean | AuditStep$logsArgs<ExtArgs>
    _count?: boolean | AuditStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditStep"]>

  export type AuditStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    workflowId?: boolean
    workflow?: boolean | AuditWorkflowDefaultArgs<ExtArgs>
    assignedTo?: boolean | AuditStep$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["auditStep"]>

  export type AuditStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    workflowId?: boolean
    workflow?: boolean | AuditWorkflowDefaultArgs<ExtArgs>
    assignedTo?: boolean | AuditStep$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["auditStep"]>

  export type AuditStepSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    workflowId?: boolean
  }

  export type AuditStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "position" | "status" | "assignedToId" | "dueDate" | "workflowId", ExtArgs["result"]["auditStep"]>
  export type AuditStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | AuditWorkflowDefaultArgs<ExtArgs>
    assignedTo?: boolean | AuditStep$assignedToArgs<ExtArgs>
    logs?: boolean | AuditStep$logsArgs<ExtArgs>
    _count?: boolean | AuditStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | AuditWorkflowDefaultArgs<ExtArgs>
    assignedTo?: boolean | AuditStep$assignedToArgs<ExtArgs>
  }
  export type AuditStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | AuditWorkflowDefaultArgs<ExtArgs>
    assignedTo?: boolean | AuditStep$assignedToArgs<ExtArgs>
  }

  export type $AuditStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditStep"
    objects: {
      workflow: Prisma.$AuditWorkflowPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      logs: Prisma.$StepLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      position: number
      status: $Enums.StepStatus
      assignedToId: number | null
      dueDate: Date | null
      workflowId: number
    }, ExtArgs["result"]["auditStep"]>
    composites: {}
  }

  type AuditStepGetPayload<S extends boolean | null | undefined | AuditStepDefaultArgs> = $Result.GetResult<Prisma.$AuditStepPayload, S>

  type AuditStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditStepCountAggregateInputType | true
    }

  export interface AuditStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditStep'], meta: { name: 'AuditStep' } }
    /**
     * Find zero or one AuditStep that matches the filter.
     * @param {AuditStepFindUniqueArgs} args - Arguments to find a AuditStep
     * @example
     * // Get one AuditStep
     * const auditStep = await prisma.auditStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditStepFindUniqueArgs>(args: SelectSubset<T, AuditStepFindUniqueArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AuditStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditStepFindUniqueOrThrowArgs} args - Arguments to find a AuditStep
     * @example
     * // Get one AuditStep
     * const auditStep = await prisma.auditStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditStepFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AuditStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepFindFirstArgs} args - Arguments to find a AuditStep
     * @example
     * // Get one AuditStep
     * const auditStep = await prisma.auditStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditStepFindFirstArgs>(args?: SelectSubset<T, AuditStepFindFirstArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AuditStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepFindFirstOrThrowArgs} args - Arguments to find a AuditStep
     * @example
     * // Get one AuditStep
     * const auditStep = await prisma.auditStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditStepFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AuditSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditSteps
     * const auditSteps = await prisma.auditStep.findMany()
     * 
     * // Get first 10 AuditSteps
     * const auditSteps = await prisma.auditStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditStepWithIdOnly = await prisma.auditStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditStepFindManyArgs>(args?: SelectSubset<T, AuditStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AuditStep.
     * @param {AuditStepCreateArgs} args - Arguments to create a AuditStep.
     * @example
     * // Create one AuditStep
     * const AuditStep = await prisma.auditStep.create({
     *   data: {
     *     // ... data to create a AuditStep
     *   }
     * })
     * 
     */
    create<T extends AuditStepCreateArgs>(args: SelectSubset<T, AuditStepCreateArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AuditSteps.
     * @param {AuditStepCreateManyArgs} args - Arguments to create many AuditSteps.
     * @example
     * // Create many AuditSteps
     * const auditStep = await prisma.auditStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditStepCreateManyArgs>(args?: SelectSubset<T, AuditStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditSteps and returns the data saved in the database.
     * @param {AuditStepCreateManyAndReturnArgs} args - Arguments to create many AuditSteps.
     * @example
     * // Create many AuditSteps
     * const auditStep = await prisma.auditStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditSteps and only return the `id`
     * const auditStepWithIdOnly = await prisma.auditStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditStepCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AuditStep.
     * @param {AuditStepDeleteArgs} args - Arguments to delete one AuditStep.
     * @example
     * // Delete one AuditStep
     * const AuditStep = await prisma.auditStep.delete({
     *   where: {
     *     // ... filter to delete one AuditStep
     *   }
     * })
     * 
     */
    delete<T extends AuditStepDeleteArgs>(args: SelectSubset<T, AuditStepDeleteArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AuditStep.
     * @param {AuditStepUpdateArgs} args - Arguments to update one AuditStep.
     * @example
     * // Update one AuditStep
     * const auditStep = await prisma.auditStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditStepUpdateArgs>(args: SelectSubset<T, AuditStepUpdateArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AuditSteps.
     * @param {AuditStepDeleteManyArgs} args - Arguments to filter AuditSteps to delete.
     * @example
     * // Delete a few AuditSteps
     * const { count } = await prisma.auditStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditStepDeleteManyArgs>(args?: SelectSubset<T, AuditStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditSteps
     * const auditStep = await prisma.auditStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditStepUpdateManyArgs>(args: SelectSubset<T, AuditStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditSteps and returns the data updated in the database.
     * @param {AuditStepUpdateManyAndReturnArgs} args - Arguments to update many AuditSteps.
     * @example
     * // Update many AuditSteps
     * const auditStep = await prisma.auditStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditSteps and only return the `id`
     * const auditStepWithIdOnly = await prisma.auditStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditStepUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AuditStep.
     * @param {AuditStepUpsertArgs} args - Arguments to update or create a AuditStep.
     * @example
     * // Update or create a AuditStep
     * const auditStep = await prisma.auditStep.upsert({
     *   create: {
     *     // ... data to create a AuditStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditStep we want to update
     *   }
     * })
     */
    upsert<T extends AuditStepUpsertArgs>(args: SelectSubset<T, AuditStepUpsertArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AuditSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepCountArgs} args - Arguments to filter AuditSteps to count.
     * @example
     * // Count the number of AuditSteps
     * const count = await prisma.auditStep.count({
     *   where: {
     *     // ... the filter for the AuditSteps we want to count
     *   }
     * })
    **/
    count<T extends AuditStepCountArgs>(
      args?: Subset<T, AuditStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditStepAggregateArgs>(args: Subset<T, AuditStepAggregateArgs>): Prisma.PrismaPromise<GetAuditStepAggregateType<T>>

    /**
     * Group by AuditStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditStepGroupByArgs['orderBy'] }
        : { orderBy?: AuditStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditStep model
   */
  readonly fields: AuditStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends AuditWorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditWorkflowDefaultArgs<ExtArgs>>): Prisma__AuditWorkflowClient<$Result.GetResult<Prisma.$AuditWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    assignedTo<T extends AuditStep$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, AuditStep$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    logs<T extends AuditStep$logsArgs<ExtArgs> = {}>(args?: Subset<T, AuditStep$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditStep model
   */ 
  interface AuditStepFieldRefs {
    readonly id: FieldRef<"AuditStep", 'Int'>
    readonly title: FieldRef<"AuditStep", 'String'>
    readonly description: FieldRef<"AuditStep", 'String'>
    readonly position: FieldRef<"AuditStep", 'Int'>
    readonly status: FieldRef<"AuditStep", 'StepStatus'>
    readonly assignedToId: FieldRef<"AuditStep", 'Int'>
    readonly dueDate: FieldRef<"AuditStep", 'DateTime'>
    readonly workflowId: FieldRef<"AuditStep", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AuditStep findUnique
   */
  export type AuditStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * Filter, which AuditStep to fetch.
     */
    where: AuditStepWhereUniqueInput
  }

  /**
   * AuditStep findUniqueOrThrow
   */
  export type AuditStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * Filter, which AuditStep to fetch.
     */
    where: AuditStepWhereUniqueInput
  }

  /**
   * AuditStep findFirst
   */
  export type AuditStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * Filter, which AuditStep to fetch.
     */
    where?: AuditStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditSteps to fetch.
     */
    orderBy?: AuditStepOrderByWithRelationInput | AuditStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditSteps.
     */
    cursor?: AuditStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditSteps.
     */
    distinct?: AuditStepScalarFieldEnum | AuditStepScalarFieldEnum[]
  }

  /**
   * AuditStep findFirstOrThrow
   */
  export type AuditStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * Filter, which AuditStep to fetch.
     */
    where?: AuditStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditSteps to fetch.
     */
    orderBy?: AuditStepOrderByWithRelationInput | AuditStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditSteps.
     */
    cursor?: AuditStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditSteps.
     */
    distinct?: AuditStepScalarFieldEnum | AuditStepScalarFieldEnum[]
  }

  /**
   * AuditStep findMany
   */
  export type AuditStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * Filter, which AuditSteps to fetch.
     */
    where?: AuditStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditSteps to fetch.
     */
    orderBy?: AuditStepOrderByWithRelationInput | AuditStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditSteps.
     */
    cursor?: AuditStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditSteps.
     */
    skip?: number
    distinct?: AuditStepScalarFieldEnum | AuditStepScalarFieldEnum[]
  }

  /**
   * AuditStep create
   */
  export type AuditStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditStep.
     */
    data: XOR<AuditStepCreateInput, AuditStepUncheckedCreateInput>
  }

  /**
   * AuditStep createMany
   */
  export type AuditStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditSteps.
     */
    data: AuditStepCreateManyInput | AuditStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditStep createManyAndReturn
   */
  export type AuditStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * The data used to create many AuditSteps.
     */
    data: AuditStepCreateManyInput | AuditStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditStep update
   */
  export type AuditStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditStep.
     */
    data: XOR<AuditStepUpdateInput, AuditStepUncheckedUpdateInput>
    /**
     * Choose, which AuditStep to update.
     */
    where: AuditStepWhereUniqueInput
  }

  /**
   * AuditStep updateMany
   */
  export type AuditStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditSteps.
     */
    data: XOR<AuditStepUpdateManyMutationInput, AuditStepUncheckedUpdateManyInput>
    /**
     * Filter which AuditSteps to update
     */
    where?: AuditStepWhereInput
    /**
     * Limit how many AuditSteps to update.
     */
    limit?: number
  }

  /**
   * AuditStep updateManyAndReturn
   */
  export type AuditStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * The data used to update AuditSteps.
     */
    data: XOR<AuditStepUpdateManyMutationInput, AuditStepUncheckedUpdateManyInput>
    /**
     * Filter which AuditSteps to update
     */
    where?: AuditStepWhereInput
    /**
     * Limit how many AuditSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditStep upsert
   */
  export type AuditStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditStep to update in case it exists.
     */
    where: AuditStepWhereUniqueInput
    /**
     * In case the AuditStep found by the `where` argument doesn't exist, create a new AuditStep with this data.
     */
    create: XOR<AuditStepCreateInput, AuditStepUncheckedCreateInput>
    /**
     * In case the AuditStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditStepUpdateInput, AuditStepUncheckedUpdateInput>
  }

  /**
   * AuditStep delete
   */
  export type AuditStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
    /**
     * Filter which AuditStep to delete.
     */
    where: AuditStepWhereUniqueInput
  }

  /**
   * AuditStep deleteMany
   */
  export type AuditStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditSteps to delete
     */
    where?: AuditStepWhereInput
    /**
     * Limit how many AuditSteps to delete.
     */
    limit?: number
  }

  /**
   * AuditStep.assignedTo
   */
  export type AuditStep$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditStep.logs
   */
  export type AuditStep$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    where?: StepLogWhereInput
    orderBy?: StepLogOrderByWithRelationInput | StepLogOrderByWithRelationInput[]
    cursor?: StepLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepLogScalarFieldEnum | StepLogScalarFieldEnum[]
  }

  /**
   * AuditStep without action
   */
  export type AuditStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStep
     */
    select?: AuditStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditStep
     */
    omit?: AuditStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStepInclude<ExtArgs> | null
  }


  /**
   * Model StepLog
   */

  export type AggregateStepLog = {
    _count: StepLogCountAggregateOutputType | null
    _avg: StepLogAvgAggregateOutputType | null
    _sum: StepLogSumAggregateOutputType | null
    _min: StepLogMinAggregateOutputType | null
    _max: StepLogMaxAggregateOutputType | null
  }

  export type StepLogAvgAggregateOutputType = {
    id: number | null
    stepId: number | null
  }

  export type StepLogSumAggregateOutputType = {
    id: number | null
    stepId: number | null
  }

  export type StepLogMinAggregateOutputType = {
    id: number | null
    stepId: number | null
    message: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type StepLogMaxAggregateOutputType = {
    id: number | null
    stepId: number | null
    message: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type StepLogCountAggregateOutputType = {
    id: number
    stepId: number
    message: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type StepLogAvgAggregateInputType = {
    id?: true
    stepId?: true
  }

  export type StepLogSumAggregateInputType = {
    id?: true
    stepId?: true
  }

  export type StepLogMinAggregateInputType = {
    id?: true
    stepId?: true
    message?: true
    createdBy?: true
    createdAt?: true
  }

  export type StepLogMaxAggregateInputType = {
    id?: true
    stepId?: true
    message?: true
    createdBy?: true
    createdAt?: true
  }

  export type StepLogCountAggregateInputType = {
    id?: true
    stepId?: true
    message?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type StepLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepLog to aggregate.
     */
    where?: StepLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepLogs to fetch.
     */
    orderBy?: StepLogOrderByWithRelationInput | StepLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StepLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StepLogs
    **/
    _count?: true | StepLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StepLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StepLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StepLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StepLogMaxAggregateInputType
  }

  export type GetStepLogAggregateType<T extends StepLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStepLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStepLog[P]>
      : GetScalarType<T[P], AggregateStepLog[P]>
  }




  export type StepLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepLogWhereInput
    orderBy?: StepLogOrderByWithAggregationInput | StepLogOrderByWithAggregationInput[]
    by: StepLogScalarFieldEnum[] | StepLogScalarFieldEnum
    having?: StepLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StepLogCountAggregateInputType | true
    _avg?: StepLogAvgAggregateInputType
    _sum?: StepLogSumAggregateInputType
    _min?: StepLogMinAggregateInputType
    _max?: StepLogMaxAggregateInputType
  }

  export type StepLogGroupByOutputType = {
    id: number
    stepId: number
    message: string
    createdBy: string
    createdAt: Date
    _count: StepLogCountAggregateOutputType | null
    _avg: StepLogAvgAggregateOutputType | null
    _sum: StepLogSumAggregateOutputType | null
    _min: StepLogMinAggregateOutputType | null
    _max: StepLogMaxAggregateOutputType | null
  }

  type GetStepLogGroupByPayload<T extends StepLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StepLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StepLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StepLogGroupByOutputType[P]>
            : GetScalarType<T[P], StepLogGroupByOutputType[P]>
        }
      >
    >


  export type StepLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    message?: boolean
    createdBy?: boolean
    createdAt?: boolean
    step?: boolean | AuditStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stepLog"]>

  export type StepLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    message?: boolean
    createdBy?: boolean
    createdAt?: boolean
    step?: boolean | AuditStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stepLog"]>

  export type StepLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    message?: boolean
    createdBy?: boolean
    createdAt?: boolean
    step?: boolean | AuditStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stepLog"]>

  export type StepLogSelectScalar = {
    id?: boolean
    stepId?: boolean
    message?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type StepLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stepId" | "message" | "createdBy" | "createdAt", ExtArgs["result"]["stepLog"]>
  export type StepLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | AuditStepDefaultArgs<ExtArgs>
  }
  export type StepLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | AuditStepDefaultArgs<ExtArgs>
  }
  export type StepLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | AuditStepDefaultArgs<ExtArgs>
  }

  export type $StepLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StepLog"
    objects: {
      step: Prisma.$AuditStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stepId: number
      message: string
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["stepLog"]>
    composites: {}
  }

  type StepLogGetPayload<S extends boolean | null | undefined | StepLogDefaultArgs> = $Result.GetResult<Prisma.$StepLogPayload, S>

  type StepLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StepLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StepLogCountAggregateInputType | true
    }

  export interface StepLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StepLog'], meta: { name: 'StepLog' } }
    /**
     * Find zero or one StepLog that matches the filter.
     * @param {StepLogFindUniqueArgs} args - Arguments to find a StepLog
     * @example
     * // Get one StepLog
     * const stepLog = await prisma.stepLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StepLogFindUniqueArgs>(args: SelectSubset<T, StepLogFindUniqueArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one StepLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StepLogFindUniqueOrThrowArgs} args - Arguments to find a StepLog
     * @example
     * // Get one StepLog
     * const stepLog = await prisma.stepLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StepLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StepLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first StepLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogFindFirstArgs} args - Arguments to find a StepLog
     * @example
     * // Get one StepLog
     * const stepLog = await prisma.stepLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StepLogFindFirstArgs>(args?: SelectSubset<T, StepLogFindFirstArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first StepLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogFindFirstOrThrowArgs} args - Arguments to find a StepLog
     * @example
     * // Get one StepLog
     * const stepLog = await prisma.stepLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StepLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StepLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more StepLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StepLogs
     * const stepLogs = await prisma.stepLog.findMany()
     * 
     * // Get first 10 StepLogs
     * const stepLogs = await prisma.stepLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stepLogWithIdOnly = await prisma.stepLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StepLogFindManyArgs>(args?: SelectSubset<T, StepLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a StepLog.
     * @param {StepLogCreateArgs} args - Arguments to create a StepLog.
     * @example
     * // Create one StepLog
     * const StepLog = await prisma.stepLog.create({
     *   data: {
     *     // ... data to create a StepLog
     *   }
     * })
     * 
     */
    create<T extends StepLogCreateArgs>(args: SelectSubset<T, StepLogCreateArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many StepLogs.
     * @param {StepLogCreateManyArgs} args - Arguments to create many StepLogs.
     * @example
     * // Create many StepLogs
     * const stepLog = await prisma.stepLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StepLogCreateManyArgs>(args?: SelectSubset<T, StepLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StepLogs and returns the data saved in the database.
     * @param {StepLogCreateManyAndReturnArgs} args - Arguments to create many StepLogs.
     * @example
     * // Create many StepLogs
     * const stepLog = await prisma.stepLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StepLogs and only return the `id`
     * const stepLogWithIdOnly = await prisma.stepLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StepLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StepLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a StepLog.
     * @param {StepLogDeleteArgs} args - Arguments to delete one StepLog.
     * @example
     * // Delete one StepLog
     * const StepLog = await prisma.stepLog.delete({
     *   where: {
     *     // ... filter to delete one StepLog
     *   }
     * })
     * 
     */
    delete<T extends StepLogDeleteArgs>(args: SelectSubset<T, StepLogDeleteArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one StepLog.
     * @param {StepLogUpdateArgs} args - Arguments to update one StepLog.
     * @example
     * // Update one StepLog
     * const stepLog = await prisma.stepLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StepLogUpdateArgs>(args: SelectSubset<T, StepLogUpdateArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more StepLogs.
     * @param {StepLogDeleteManyArgs} args - Arguments to filter StepLogs to delete.
     * @example
     * // Delete a few StepLogs
     * const { count } = await prisma.stepLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StepLogDeleteManyArgs>(args?: SelectSubset<T, StepLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StepLogs
     * const stepLog = await prisma.stepLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StepLogUpdateManyArgs>(args: SelectSubset<T, StepLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepLogs and returns the data updated in the database.
     * @param {StepLogUpdateManyAndReturnArgs} args - Arguments to update many StepLogs.
     * @example
     * // Update many StepLogs
     * const stepLog = await prisma.stepLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StepLogs and only return the `id`
     * const stepLogWithIdOnly = await prisma.stepLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StepLogUpdateManyAndReturnArgs>(args: SelectSubset<T, StepLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one StepLog.
     * @param {StepLogUpsertArgs} args - Arguments to update or create a StepLog.
     * @example
     * // Update or create a StepLog
     * const stepLog = await prisma.stepLog.upsert({
     *   create: {
     *     // ... data to create a StepLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StepLog we want to update
     *   }
     * })
     */
    upsert<T extends StepLogUpsertArgs>(args: SelectSubset<T, StepLogUpsertArgs<ExtArgs>>): Prisma__StepLogClient<$Result.GetResult<Prisma.$StepLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of StepLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogCountArgs} args - Arguments to filter StepLogs to count.
     * @example
     * // Count the number of StepLogs
     * const count = await prisma.stepLog.count({
     *   where: {
     *     // ... the filter for the StepLogs we want to count
     *   }
     * })
    **/
    count<T extends StepLogCountArgs>(
      args?: Subset<T, StepLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StepLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StepLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StepLogAggregateArgs>(args: Subset<T, StepLogAggregateArgs>): Prisma.PrismaPromise<GetStepLogAggregateType<T>>

    /**
     * Group by StepLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StepLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StepLogGroupByArgs['orderBy'] }
        : { orderBy?: StepLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StepLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStepLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StepLog model
   */
  readonly fields: StepLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StepLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StepLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    step<T extends AuditStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditStepDefaultArgs<ExtArgs>>): Prisma__AuditStepClient<$Result.GetResult<Prisma.$AuditStepPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StepLog model
   */ 
  interface StepLogFieldRefs {
    readonly id: FieldRef<"StepLog", 'Int'>
    readonly stepId: FieldRef<"StepLog", 'Int'>
    readonly message: FieldRef<"StepLog", 'String'>
    readonly createdBy: FieldRef<"StepLog", 'String'>
    readonly createdAt: FieldRef<"StepLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StepLog findUnique
   */
  export type StepLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * Filter, which StepLog to fetch.
     */
    where: StepLogWhereUniqueInput
  }

  /**
   * StepLog findUniqueOrThrow
   */
  export type StepLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * Filter, which StepLog to fetch.
     */
    where: StepLogWhereUniqueInput
  }

  /**
   * StepLog findFirst
   */
  export type StepLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * Filter, which StepLog to fetch.
     */
    where?: StepLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepLogs to fetch.
     */
    orderBy?: StepLogOrderByWithRelationInput | StepLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepLogs.
     */
    cursor?: StepLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepLogs.
     */
    distinct?: StepLogScalarFieldEnum | StepLogScalarFieldEnum[]
  }

  /**
   * StepLog findFirstOrThrow
   */
  export type StepLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * Filter, which StepLog to fetch.
     */
    where?: StepLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepLogs to fetch.
     */
    orderBy?: StepLogOrderByWithRelationInput | StepLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepLogs.
     */
    cursor?: StepLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepLogs.
     */
    distinct?: StepLogScalarFieldEnum | StepLogScalarFieldEnum[]
  }

  /**
   * StepLog findMany
   */
  export type StepLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * Filter, which StepLogs to fetch.
     */
    where?: StepLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepLogs to fetch.
     */
    orderBy?: StepLogOrderByWithRelationInput | StepLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StepLogs.
     */
    cursor?: StepLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepLogs.
     */
    skip?: number
    distinct?: StepLogScalarFieldEnum | StepLogScalarFieldEnum[]
  }

  /**
   * StepLog create
   */
  export type StepLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StepLog.
     */
    data: XOR<StepLogCreateInput, StepLogUncheckedCreateInput>
  }

  /**
   * StepLog createMany
   */
  export type StepLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StepLogs.
     */
    data: StepLogCreateManyInput | StepLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StepLog createManyAndReturn
   */
  export type StepLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * The data used to create many StepLogs.
     */
    data: StepLogCreateManyInput | StepLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StepLog update
   */
  export type StepLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StepLog.
     */
    data: XOR<StepLogUpdateInput, StepLogUncheckedUpdateInput>
    /**
     * Choose, which StepLog to update.
     */
    where: StepLogWhereUniqueInput
  }

  /**
   * StepLog updateMany
   */
  export type StepLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StepLogs.
     */
    data: XOR<StepLogUpdateManyMutationInput, StepLogUncheckedUpdateManyInput>
    /**
     * Filter which StepLogs to update
     */
    where?: StepLogWhereInput
    /**
     * Limit how many StepLogs to update.
     */
    limit?: number
  }

  /**
   * StepLog updateManyAndReturn
   */
  export type StepLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * The data used to update StepLogs.
     */
    data: XOR<StepLogUpdateManyMutationInput, StepLogUncheckedUpdateManyInput>
    /**
     * Filter which StepLogs to update
     */
    where?: StepLogWhereInput
    /**
     * Limit how many StepLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StepLog upsert
   */
  export type StepLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StepLog to update in case it exists.
     */
    where: StepLogWhereUniqueInput
    /**
     * In case the StepLog found by the `where` argument doesn't exist, create a new StepLog with this data.
     */
    create: XOR<StepLogCreateInput, StepLogUncheckedCreateInput>
    /**
     * In case the StepLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StepLogUpdateInput, StepLogUncheckedUpdateInput>
  }

  /**
   * StepLog delete
   */
  export type StepLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
    /**
     * Filter which StepLog to delete.
     */
    where: StepLogWhereUniqueInput
  }

  /**
   * StepLog deleteMany
   */
  export type StepLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepLogs to delete
     */
    where?: StepLogWhereInput
    /**
     * Limit how many StepLogs to delete.
     */
    limit?: number
  }

  /**
   * StepLog without action
   */
  export type StepLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepLog
     */
    select?: StepLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepLog
     */
    omit?: StepLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const LogsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    host: 'host',
    timestamp: 'timestamp',
    piuser: 'piuser',
    pid: 'pid',
    action: 'action',
    cpu: 'cpu',
    mem: 'mem',
    command: 'command',
    port: 'port',
    ipAddress: 'ipAddress'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const AuthScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    username: 'username',
    log_entry: 'log_entry'
  };

  export type AuthScalarFieldEnum = (typeof AuthScalarFieldEnum)[keyof typeof AuthScalarFieldEnum]


  export const Memory_usageScalarFieldEnum: {
    id: 'id',
    total_memory: 'total_memory',
    used_memory: 'used_memory',
    free_memory: 'free_memory',
    available_memory: 'available_memory',
    percent_usage: 'percent_usage',
    host: 'host',
    time: 'time'
  };

  export type Memory_usageScalarFieldEnum = (typeof Memory_usageScalarFieldEnum)[keyof typeof Memory_usageScalarFieldEnum]


  export const System_metricsScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    sensor_name: 'sensor_name',
    value_type: 'value_type',
    value: 'value',
    host: 'host',
    min: 'min',
    max: 'max'
  };

  export type System_metricsScalarFieldEnum = (typeof System_metricsScalarFieldEnum)[keyof typeof System_metricsScalarFieldEnum]


  export const DiskmetricScalarFieldEnum: {
    id: 'id',
    host: 'host',
    name: 'name',
    label: 'label',
    totalgb: 'totalgb',
    usedgb: 'usedgb',
    freegb: 'freegb',
    timestamp: 'timestamp'
  };

  export type DiskmetricScalarFieldEnum = (typeof DiskmetricScalarFieldEnum)[keyof typeof DiskmetricScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    time: 'time',
    description: 'description'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const DevicesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ip_address: 'ip_address',
    mac_address: 'mac_address',
    password: 'password',
    time: 'time',
    notes: 'notes',
    status: 'status'
  };

  export type DevicesScalarFieldEnum = (typeof DevicesScalarFieldEnum)[keyof typeof DevicesScalarFieldEnum]


  export const DeviceUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    role: 'role'
  };

  export type DeviceUserScalarFieldEnum = (typeof DeviceUserScalarFieldEnum)[keyof typeof DeviceUserScalarFieldEnum]


  export const CommandScalarFieldEnum: {
    id: 'id',
    ruleId: 'ruleId',
    command: 'command',
    emailTemplateId: 'emailTemplateId'
  };

  export type CommandScalarFieldEnum = (typeof CommandScalarFieldEnum)[keyof typeof CommandScalarFieldEnum]


  export const RuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    groupId: 'groupId',
    emailTemplateId: 'emailTemplateId'
  };

  export type RuleScalarFieldEnum = (typeof RuleScalarFieldEnum)[keyof typeof RuleScalarFieldEnum]


  export const RuleGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailTemplateId: 'emailTemplateId'
  };

  export type RuleGroupScalarFieldEnum = (typeof RuleGroupScalarFieldEnum)[keyof typeof RuleGroupScalarFieldEnum]


  export const CommandMatchScalarFieldEnum: {
    id: 'id',
    logId: 'logId',
    logType: 'logType',
    commandId: 'commandId',
    ruleId: 'ruleId',
    commandText: 'commandText',
    logEntry: 'logEntry',
    timestamp: 'timestamp',
    addressed: 'addressed',
    addressedBy: 'addressedBy',
    addressedAt: 'addressedAt',
    notes: 'notes',
    emailSent: 'emailSent'
  };

  export type CommandMatchScalarFieldEnum = (typeof CommandMatchScalarFieldEnum)[keyof typeof CommandMatchScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    actionType: 'actionType',
    targetType: 'targetType',
    targetId: 'targetId',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    role: 'role',
    Mobile: 'Mobile',
    PrimaryContact: 'PrimaryContact',
    MobileContact: 'MobileContact',
    Relationship: 'Relationship',
    SecondContact: 'SecondContact',
    SecondMobile: 'SecondMobile',
    SecondRelationship: 'SecondRelationship',
    Remarks: 'Remarks',
    ndafile: 'ndafile',
    ndasubmissiondate: 'ndasubmissiondate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    location: 'location'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    groupId: 'groupId',
    joinedAt: 'joinedAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    senderId: 'senderId',
    groupId: 'groupId',
    edited: 'edited',
    createdAt: 'createdAt',
    fileAttachment: 'fileAttachment',
    fileOriginalName: 'fileOriginalName',
    fileType: 'fileType'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const UserEmailTemplateScalarFieldEnum: {
    userId: 'userId',
    emailTemplateId: 'emailTemplateId',
    assignedAt: 'assignedAt'
  };

  export type UserEmailTemplateScalarFieldEnum = (typeof UserEmailTemplateScalarFieldEnum)[keyof typeof UserEmailTemplateScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    postDate: 'postDate',
    expiryDate: 'expiryDate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    important: 'important'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationReadScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type NotificationReadScalarFieldEnum = (typeof NotificationReadScalarFieldEnum)[keyof typeof NotificationReadScalarFieldEnum]


  export const SavedQueryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tableName: 'tableName',
    columns: 'columns',
    conditions: 'conditions',
    emailTemplateId: 'emailTemplateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SavedQueryScalarFieldEnum = (typeof SavedQueryScalarFieldEnum)[keyof typeof SavedQueryScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedToId: 'assignedToId',
    createdById: 'createdById',
    relatedDeviceId: 'relatedDeviceId'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const TicketAttachmentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalFilename: 'originalFilename',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt',
    ticketId: 'ticketId',
    commentId: 'commentId',
    uploaderId: 'uploaderId'
  };

  export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


  export const AlertConditionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sourceTable: 'sourceTable',
    fieldName: 'fieldName',
    comparator: 'comparator',
    thresholdValue: 'thresholdValue',
    timeWindowMin: 'timeWindowMin',
    repeatIntervalMin: 'repeatIntervalMin',
    countThreshold: 'countThreshold',
    lastTriggeredAt: 'lastTriggeredAt',
    active: 'active',
    emailTemplateId: 'emailTemplateId'
  };

  export type AlertConditionScalarFieldEnum = (typeof AlertConditionScalarFieldEnum)[keyof typeof AlertConditionScalarFieldEnum]


  export const AlertEventScalarFieldEnum: {
    id: 'id',
    conditionId: 'conditionId',
    triggeredAt: 'triggeredAt',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    notes: 'notes'
  };

  export type AlertEventScalarFieldEnum = (typeof AlertEventScalarFieldEnum)[keyof typeof AlertEventScalarFieldEnum]


  export const LibraryEntryScalarFieldEnum: {
    id: 'id',
    refNo: 'refNo',
    category: 'category',
    title: 'title',
    author: 'author',
    pubYear: 'pubYear',
    creationDate: 'creationDate',
    borrower: 'borrower',
    loanDate: 'loanDate',
    remarks: 'remarks',
    attachmentUrl: 'attachmentUrl',
    attachmentFilename: 'attachmentFilename',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryEntryScalarFieldEnum = (typeof LibraryEntryScalarFieldEnum)[keyof typeof LibraryEntryScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isRead: 'isRead',
    senderId: 'senderId'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const FeedbackRecipientScalarFieldEnum: {
    id: 'id',
    feedbackId: 'feedbackId',
    userId: 'userId'
  };

  export type FeedbackRecipientScalarFieldEnum = (typeof FeedbackRecipientScalarFieldEnum)[keyof typeof FeedbackRecipientScalarFieldEnum]


  export const PagePermissionScalarFieldEnum: {
    id: 'id',
    route: 'route',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PagePermissionScalarFieldEnum = (typeof PagePermissionScalarFieldEnum)[keyof typeof PagePermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleName: 'roleName',
    pagePermissionId: 'pagePermissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserPermissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    pagePermissionId: 'pagePermissionId'
  };

  export type UserPermissionScalarFieldEnum = (typeof UserPermissionScalarFieldEnum)[keyof typeof UserPermissionScalarFieldEnum]


  export const PagesScalarFieldEnum: {
    id: 'id',
    notes: 'notes'
  };

  export type PagesScalarFieldEnum = (typeof PagesScalarFieldEnum)[keyof typeof PagesScalarFieldEnum]


  export const ProjectTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type ProjectTypeScalarFieldEnum = (typeof ProjectTypeScalarFieldEnum)[keyof typeof ProjectTypeScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    businessCode: 'businessCode',
    projectCode: 'projectCode',
    name: 'name',
    createDate: 'createDate',
    projectTypeId: 'projectTypeId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ModelEntryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    createDate: 'createDate',
    createBy: 'createBy',
    modifyDate: 'modifyDate',
    modifyBy: 'modifyBy',
    projectId: 'projectId'
  };

  export type ModelEntryScalarFieldEnum = (typeof ModelEntryScalarFieldEnum)[keyof typeof ModelEntryScalarFieldEnum]


  export const ProjectAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    role: 'role'
  };

  export type ProjectAssignmentScalarFieldEnum = (typeof ProjectAssignmentScalarFieldEnum)[keyof typeof ProjectAssignmentScalarFieldEnum]


  export const SambaLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    component: 'component',
    level: 'level',
    message: 'message',
    zone: 'zone',
    name: 'name',
    errorCode: 'errorCode',
    errorName: 'errorName',
    hostname: 'hostname',
    createdAt: 'createdAt'
  };

  export type SambaLogScalarFieldEnum = (typeof SambaLogScalarFieldEnum)[keyof typeof SambaLogScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    modifyBy: 'modifyBy',
    createBy: 'createBy',
    modifyDate: 'modifyDate',
    CCY: 'CCY',
    Region: 'Region',
    Remarks: 'Remarks',
    WCI_URL: 'WCI_URL',
    createDate: 'createDate',
    fullname: 'fullname'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const LdapuserScalarFieldEnum: {
    dn: 'dn',
    objectClass: 'objectClass',
    cn: 'cn',
    sn: 'sn',
    givenName: 'givenName',
    instanceType: 'instanceType',
    whenCreated: 'whenCreated',
    displayName: 'displayName',
    uSNCreated: 'uSNCreated',
    name: 'name',
    objectGUID: 'objectGUID',
    badPwdCount: 'badPwdCount',
    codePage: 'codePage',
    countryCode: 'countryCode',
    badPasswordTime: 'badPasswordTime',
    lastLogoff: 'lastLogoff',
    lastLogon: 'lastLogon',
    primaryGroupID: 'primaryGroupID',
    objectSid: 'objectSid',
    accountExpires: 'accountExpires',
    logonCount: 'logonCount',
    sAMAccountName: 'sAMAccountName',
    sAMAccountType: 'sAMAccountType',
    userPrincipalName: 'userPrincipalName',
    objectCategory: 'objectCategory',
    pwdLastSet: 'pwdLastSet',
    userAccountControl: 'userAccountControl',
    whenChanged: 'whenChanged',
    uSNChanged: 'uSNChanged',
    distinguishedName: 'distinguishedName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    adminCount: 'adminCount',
    description: 'description',
    isCriticalSystemObject: 'isCriticalSystemObject',
    memberOf: 'memberOf',
    servicePrincipalName: 'servicePrincipalName',
    showInAdvancedViewOnly: 'showInAdvancedViewOnly',
    id: 'id'
  };

  export type LdapuserScalarFieldEnum = (typeof LdapuserScalarFieldEnum)[keyof typeof LdapuserScalarFieldEnum]


  export const DriveFolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriveFolderScalarFieldEnum = (typeof DriveFolderScalarFieldEnum)[keyof typeof DriveFolderScalarFieldEnum]


  export const DriveFileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    size: 'size',
    order: 'order',
    folderId: 'folderId',
    ownerId: 'ownerId',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriveFileScalarFieldEnum = (typeof DriveFileScalarFieldEnum)[keyof typeof DriveFileScalarFieldEnum]


  export const DriveFilePermissionScalarFieldEnum: {
    id: 'id',
    fileId: 'fileId',
    userId: 'userId',
    access: 'access',
    grantedBy: 'grantedBy',
    grantedAt: 'grantedAt'
  };

  export type DriveFilePermissionScalarFieldEnum = (typeof DriveFilePermissionScalarFieldEnum)[keyof typeof DriveFilePermissionScalarFieldEnum]


  export const JobTitleScalarFieldEnum: {
    id: 'id',
    sn: 'sn',
    jobTitle: 'jobTitle',
    abbreviation: 'abbreviation',
    grade: 'grade',
    seniorityLevel: 'seniorityLevel',
    selectableInStaffCV: 'selectableInStaffCV',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobTitleScalarFieldEnum = (typeof JobTitleScalarFieldEnum)[keyof typeof JobTitleScalarFieldEnum]


  export const UserActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    username: 'username',
    page: 'page',
    loginTime: 'loginTime'
  };

  export type UserActivityScalarFieldEnum = (typeof UserActivityScalarFieldEnum)[keyof typeof UserActivityScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    sequence: 'sequence',
    remarks: 'remarks',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamLeaderScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId'
  };

  export type TeamLeaderScalarFieldEnum = (typeof TeamLeaderScalarFieldEnum)[keyof typeof TeamLeaderScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const TeamLocationScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    locationId: 'locationId'
  };

  export type TeamLocationScalarFieldEnum = (typeof TeamLocationScalarFieldEnum)[keyof typeof TeamLocationScalarFieldEnum]


  export const AuditWorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditWorkflowScalarFieldEnum = (typeof AuditWorkflowScalarFieldEnum)[keyof typeof AuditWorkflowScalarFieldEnum]


  export const AuditStepScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    position: 'position',
    status: 'status',
    assignedToId: 'assignedToId',
    dueDate: 'dueDate',
    workflowId: 'workflowId'
  };

  export type AuditStepScalarFieldEnum = (typeof AuditStepScalarFieldEnum)[keyof typeof AuditStepScalarFieldEnum]


  export const StepLogScalarFieldEnum: {
    id: 'id',
    stepId: 'stepId',
    message: 'message',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type StepLogScalarFieldEnum = (typeof StepLogScalarFieldEnum)[keyof typeof StepLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'StepStatus'
   */
  export type EnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus'>
    


  /**
   * Reference to a field of type 'StepStatus[]'
   */
  export type ListEnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type logsWhereInput = {
    AND?: logsWhereInput | logsWhereInput[]
    OR?: logsWhereInput[]
    NOT?: logsWhereInput | logsWhereInput[]
    id?: IntFilter<"logs"> | number
    name?: StringFilter<"logs"> | string
    host?: StringNullableFilter<"logs"> | string | null
    timestamp?: DateTimeFilter<"logs"> | Date | string
    piuser?: StringNullableFilter<"logs"> | string | null
    pid?: IntNullableFilter<"logs"> | number | null
    action?: StringNullableFilter<"logs"> | string | null
    cpu?: FloatNullableFilter<"logs"> | number | null
    mem?: FloatNullableFilter<"logs"> | number | null
    command?: StringNullableFilter<"logs"> | string | null
    port?: IntNullableFilter<"logs"> | number | null
    ipAddress?: StringNullableFilter<"logs"> | string | null
  }

  export type logsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    piuser?: SortOrderInput | SortOrder
    pid?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    command?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
  }

  export type logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: logsWhereInput | logsWhereInput[]
    OR?: logsWhereInput[]
    NOT?: logsWhereInput | logsWhereInput[]
    name?: StringFilter<"logs"> | string
    host?: StringNullableFilter<"logs"> | string | null
    timestamp?: DateTimeFilter<"logs"> | Date | string
    piuser?: StringNullableFilter<"logs"> | string | null
    pid?: IntNullableFilter<"logs"> | number | null
    action?: StringNullableFilter<"logs"> | string | null
    cpu?: FloatNullableFilter<"logs"> | number | null
    mem?: FloatNullableFilter<"logs"> | number | null
    command?: StringNullableFilter<"logs"> | string | null
    port?: IntNullableFilter<"logs"> | number | null
    ipAddress?: StringNullableFilter<"logs"> | string | null
  }, "id">

  export type logsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    piuser?: SortOrderInput | SortOrder
    pid?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    command?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    _count?: logsCountOrderByAggregateInput
    _avg?: logsAvgOrderByAggregateInput
    _max?: logsMaxOrderByAggregateInput
    _min?: logsMinOrderByAggregateInput
    _sum?: logsSumOrderByAggregateInput
  }

  export type logsScalarWhereWithAggregatesInput = {
    AND?: logsScalarWhereWithAggregatesInput | logsScalarWhereWithAggregatesInput[]
    OR?: logsScalarWhereWithAggregatesInput[]
    NOT?: logsScalarWhereWithAggregatesInput | logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logs"> | number
    name?: StringWithAggregatesFilter<"logs"> | string
    host?: StringNullableWithAggregatesFilter<"logs"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"logs"> | Date | string
    piuser?: StringNullableWithAggregatesFilter<"logs"> | string | null
    pid?: IntNullableWithAggregatesFilter<"logs"> | number | null
    action?: StringNullableWithAggregatesFilter<"logs"> | string | null
    cpu?: FloatNullableWithAggregatesFilter<"logs"> | number | null
    mem?: FloatNullableWithAggregatesFilter<"logs"> | number | null
    command?: StringNullableWithAggregatesFilter<"logs"> | string | null
    port?: IntNullableWithAggregatesFilter<"logs"> | number | null
    ipAddress?: StringNullableWithAggregatesFilter<"logs"> | string | null
  }

  export type authWhereInput = {
    AND?: authWhereInput | authWhereInput[]
    OR?: authWhereInput[]
    NOT?: authWhereInput | authWhereInput[]
    id?: IntFilter<"auth"> | number
    timestamp?: DateTimeFilter<"auth"> | Date | string
    username?: StringFilter<"auth"> | string
    log_entry?: StringFilter<"auth"> | string
  }

  export type authOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    username?: SortOrder
    log_entry?: SortOrder
  }

  export type authWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: authWhereInput | authWhereInput[]
    OR?: authWhereInput[]
    NOT?: authWhereInput | authWhereInput[]
    timestamp?: DateTimeFilter<"auth"> | Date | string
    username?: StringFilter<"auth"> | string
    log_entry?: StringFilter<"auth"> | string
  }, "id">

  export type authOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    username?: SortOrder
    log_entry?: SortOrder
    _count?: authCountOrderByAggregateInput
    _avg?: authAvgOrderByAggregateInput
    _max?: authMaxOrderByAggregateInput
    _min?: authMinOrderByAggregateInput
    _sum?: authSumOrderByAggregateInput
  }

  export type authScalarWhereWithAggregatesInput = {
    AND?: authScalarWhereWithAggregatesInput | authScalarWhereWithAggregatesInput[]
    OR?: authScalarWhereWithAggregatesInput[]
    NOT?: authScalarWhereWithAggregatesInput | authScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auth"> | number
    timestamp?: DateTimeWithAggregatesFilter<"auth"> | Date | string
    username?: StringWithAggregatesFilter<"auth"> | string
    log_entry?: StringWithAggregatesFilter<"auth"> | string
  }

  export type memory_usageWhereInput = {
    AND?: memory_usageWhereInput | memory_usageWhereInput[]
    OR?: memory_usageWhereInput[]
    NOT?: memory_usageWhereInput | memory_usageWhereInput[]
    id?: IntFilter<"memory_usage"> | number
    total_memory?: BigIntFilter<"memory_usage"> | bigint | number
    used_memory?: BigIntFilter<"memory_usage"> | bigint | number
    free_memory?: BigIntFilter<"memory_usage"> | bigint | number
    available_memory?: BigIntFilter<"memory_usage"> | bigint | number
    percent_usage?: FloatFilter<"memory_usage"> | number
    host?: StringNullableFilter<"memory_usage"> | string | null
    time?: DateTimeFilter<"memory_usage"> | Date | string
  }

  export type memory_usageOrderByWithRelationInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
    host?: SortOrderInput | SortOrder
    time?: SortOrder
  }

  export type memory_usageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: memory_usageWhereInput | memory_usageWhereInput[]
    OR?: memory_usageWhereInput[]
    NOT?: memory_usageWhereInput | memory_usageWhereInput[]
    total_memory?: BigIntFilter<"memory_usage"> | bigint | number
    used_memory?: BigIntFilter<"memory_usage"> | bigint | number
    free_memory?: BigIntFilter<"memory_usage"> | bigint | number
    available_memory?: BigIntFilter<"memory_usage"> | bigint | number
    percent_usage?: FloatFilter<"memory_usage"> | number
    host?: StringNullableFilter<"memory_usage"> | string | null
    time?: DateTimeFilter<"memory_usage"> | Date | string
  }, "id">

  export type memory_usageOrderByWithAggregationInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
    host?: SortOrderInput | SortOrder
    time?: SortOrder
    _count?: memory_usageCountOrderByAggregateInput
    _avg?: memory_usageAvgOrderByAggregateInput
    _max?: memory_usageMaxOrderByAggregateInput
    _min?: memory_usageMinOrderByAggregateInput
    _sum?: memory_usageSumOrderByAggregateInput
  }

  export type memory_usageScalarWhereWithAggregatesInput = {
    AND?: memory_usageScalarWhereWithAggregatesInput | memory_usageScalarWhereWithAggregatesInput[]
    OR?: memory_usageScalarWhereWithAggregatesInput[]
    NOT?: memory_usageScalarWhereWithAggregatesInput | memory_usageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"memory_usage"> | number
    total_memory?: BigIntWithAggregatesFilter<"memory_usage"> | bigint | number
    used_memory?: BigIntWithAggregatesFilter<"memory_usage"> | bigint | number
    free_memory?: BigIntWithAggregatesFilter<"memory_usage"> | bigint | number
    available_memory?: BigIntWithAggregatesFilter<"memory_usage"> | bigint | number
    percent_usage?: FloatWithAggregatesFilter<"memory_usage"> | number
    host?: StringNullableWithAggregatesFilter<"memory_usage"> | string | null
    time?: DateTimeWithAggregatesFilter<"memory_usage"> | Date | string
  }

  export type system_metricsWhereInput = {
    AND?: system_metricsWhereInput | system_metricsWhereInput[]
    OR?: system_metricsWhereInput[]
    NOT?: system_metricsWhereInput | system_metricsWhereInput[]
    id?: IntFilter<"system_metrics"> | number
    timestamp?: DateTimeFilter<"system_metrics"> | Date | string
    sensor_name?: StringFilter<"system_metrics"> | string
    value_type?: StringFilter<"system_metrics"> | string
    value?: FloatFilter<"system_metrics"> | number
    host?: StringFilter<"system_metrics"> | string
    min?: StringNullableFilter<"system_metrics"> | string | null
    max?: StringNullableFilter<"system_metrics"> | string | null
  }

  export type system_metricsOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    sensor_name?: SortOrder
    value_type?: SortOrder
    value?: SortOrder
    host?: SortOrder
    min?: SortOrderInput | SortOrder
    max?: SortOrderInput | SortOrder
  }

  export type system_metricsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: system_metricsWhereInput | system_metricsWhereInput[]
    OR?: system_metricsWhereInput[]
    NOT?: system_metricsWhereInput | system_metricsWhereInput[]
    timestamp?: DateTimeFilter<"system_metrics"> | Date | string
    sensor_name?: StringFilter<"system_metrics"> | string
    value_type?: StringFilter<"system_metrics"> | string
    value?: FloatFilter<"system_metrics"> | number
    host?: StringFilter<"system_metrics"> | string
    min?: StringNullableFilter<"system_metrics"> | string | null
    max?: StringNullableFilter<"system_metrics"> | string | null
  }, "id">

  export type system_metricsOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    sensor_name?: SortOrder
    value_type?: SortOrder
    value?: SortOrder
    host?: SortOrder
    min?: SortOrderInput | SortOrder
    max?: SortOrderInput | SortOrder
    _count?: system_metricsCountOrderByAggregateInput
    _avg?: system_metricsAvgOrderByAggregateInput
    _max?: system_metricsMaxOrderByAggregateInput
    _min?: system_metricsMinOrderByAggregateInput
    _sum?: system_metricsSumOrderByAggregateInput
  }

  export type system_metricsScalarWhereWithAggregatesInput = {
    AND?: system_metricsScalarWhereWithAggregatesInput | system_metricsScalarWhereWithAggregatesInput[]
    OR?: system_metricsScalarWhereWithAggregatesInput[]
    NOT?: system_metricsScalarWhereWithAggregatesInput | system_metricsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"system_metrics"> | number
    timestamp?: DateTimeWithAggregatesFilter<"system_metrics"> | Date | string
    sensor_name?: StringWithAggregatesFilter<"system_metrics"> | string
    value_type?: StringWithAggregatesFilter<"system_metrics"> | string
    value?: FloatWithAggregatesFilter<"system_metrics"> | number
    host?: StringWithAggregatesFilter<"system_metrics"> | string
    min?: StringNullableWithAggregatesFilter<"system_metrics"> | string | null
    max?: StringNullableWithAggregatesFilter<"system_metrics"> | string | null
  }

  export type diskmetricWhereInput = {
    AND?: diskmetricWhereInput | diskmetricWhereInput[]
    OR?: diskmetricWhereInput[]
    NOT?: diskmetricWhereInput | diskmetricWhereInput[]
    id?: IntFilter<"diskmetric"> | number
    host?: StringFilter<"diskmetric"> | string
    name?: StringFilter<"diskmetric"> | string
    label?: StringNullableFilter<"diskmetric"> | string | null
    totalgb?: FloatFilter<"diskmetric"> | number
    usedgb?: FloatFilter<"diskmetric"> | number
    freegb?: FloatFilter<"diskmetric"> | number
    timestamp?: DateTimeFilter<"diskmetric"> | Date | string
  }

  export type diskmetricOrderByWithRelationInput = {
    id?: SortOrder
    host?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
    timestamp?: SortOrder
  }

  export type diskmetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: diskmetricWhereInput | diskmetricWhereInput[]
    OR?: diskmetricWhereInput[]
    NOT?: diskmetricWhereInput | diskmetricWhereInput[]
    host?: StringFilter<"diskmetric"> | string
    name?: StringFilter<"diskmetric"> | string
    label?: StringNullableFilter<"diskmetric"> | string | null
    totalgb?: FloatFilter<"diskmetric"> | number
    usedgb?: FloatFilter<"diskmetric"> | number
    freegb?: FloatFilter<"diskmetric"> | number
    timestamp?: DateTimeFilter<"diskmetric"> | Date | string
  }, "id">

  export type diskmetricOrderByWithAggregationInput = {
    id?: SortOrder
    host?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
    timestamp?: SortOrder
    _count?: diskmetricCountOrderByAggregateInput
    _avg?: diskmetricAvgOrderByAggregateInput
    _max?: diskmetricMaxOrderByAggregateInput
    _min?: diskmetricMinOrderByAggregateInput
    _sum?: diskmetricSumOrderByAggregateInput
  }

  export type diskmetricScalarWhereWithAggregatesInput = {
    AND?: diskmetricScalarWhereWithAggregatesInput | diskmetricScalarWhereWithAggregatesInput[]
    OR?: diskmetricScalarWhereWithAggregatesInput[]
    NOT?: diskmetricScalarWhereWithAggregatesInput | diskmetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"diskmetric"> | number
    host?: StringWithAggregatesFilter<"diskmetric"> | string
    name?: StringWithAggregatesFilter<"diskmetric"> | string
    label?: StringNullableWithAggregatesFilter<"diskmetric"> | string | null
    totalgb?: FloatWithAggregatesFilter<"diskmetric"> | number
    usedgb?: FloatWithAggregatesFilter<"diskmetric"> | number
    freegb?: FloatWithAggregatesFilter<"diskmetric"> | number
    timestamp?: DateTimeWithAggregatesFilter<"diskmetric"> | Date | string
  }

  export type notesWhereInput = {
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    id?: IntFilter<"notes"> | number
    title?: StringFilter<"notes"> | string
    time?: DateTimeFilter<"notes"> | Date | string
    description?: StringFilter<"notes"> | string
  }

  export type notesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    time?: SortOrder
    description?: SortOrder
  }

  export type notesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    title?: StringFilter<"notes"> | string
    time?: DateTimeFilter<"notes"> | Date | string
    description?: StringFilter<"notes"> | string
  }, "id">

  export type notesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    time?: SortOrder
    description?: SortOrder
    _count?: notesCountOrderByAggregateInput
    _avg?: notesAvgOrderByAggregateInput
    _max?: notesMaxOrderByAggregateInput
    _min?: notesMinOrderByAggregateInput
    _sum?: notesSumOrderByAggregateInput
  }

  export type notesScalarWhereWithAggregatesInput = {
    AND?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    OR?: notesScalarWhereWithAggregatesInput[]
    NOT?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notes"> | number
    title?: StringWithAggregatesFilter<"notes"> | string
    time?: DateTimeWithAggregatesFilter<"notes"> | Date | string
    description?: StringWithAggregatesFilter<"notes"> | string
  }

  export type devicesWhereInput = {
    AND?: devicesWhereInput | devicesWhereInput[]
    OR?: devicesWhereInput[]
    NOT?: devicesWhereInput | devicesWhereInput[]
    id?: IntFilter<"devices"> | number
    name?: StringFilter<"devices"> | string
    ip_address?: StringNullableFilter<"devices"> | string | null
    mac_address?: StringNullableFilter<"devices"> | string | null
    password?: StringNullableFilter<"devices"> | string | null
    time?: DateTimeFilter<"devices"> | Date | string
    notes?: StringFilter<"devices"> | string
    status?: StringFilter<"devices"> | string
    users?: DeviceUserListRelationFilter
    SupportTicket?: SupportTicketListRelationFilter
  }

  export type devicesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ip_address?: SortOrderInput | SortOrder
    mac_address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    time?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    users?: DeviceUserOrderByRelationAggregateInput
    SupportTicket?: SupportTicketOrderByRelationAggregateInput
  }

  export type devicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ip_address?: string
    AND?: devicesWhereInput | devicesWhereInput[]
    OR?: devicesWhereInput[]
    NOT?: devicesWhereInput | devicesWhereInput[]
    name?: StringFilter<"devices"> | string
    mac_address?: StringNullableFilter<"devices"> | string | null
    password?: StringNullableFilter<"devices"> | string | null
    time?: DateTimeFilter<"devices"> | Date | string
    notes?: StringFilter<"devices"> | string
    status?: StringFilter<"devices"> | string
    users?: DeviceUserListRelationFilter
    SupportTicket?: SupportTicketListRelationFilter
  }, "id" | "ip_address">

  export type devicesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ip_address?: SortOrderInput | SortOrder
    mac_address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    time?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    _count?: devicesCountOrderByAggregateInput
    _avg?: devicesAvgOrderByAggregateInput
    _max?: devicesMaxOrderByAggregateInput
    _min?: devicesMinOrderByAggregateInput
    _sum?: devicesSumOrderByAggregateInput
  }

  export type devicesScalarWhereWithAggregatesInput = {
    AND?: devicesScalarWhereWithAggregatesInput | devicesScalarWhereWithAggregatesInput[]
    OR?: devicesScalarWhereWithAggregatesInput[]
    NOT?: devicesScalarWhereWithAggregatesInput | devicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"devices"> | number
    name?: StringWithAggregatesFilter<"devices"> | string
    ip_address?: StringNullableWithAggregatesFilter<"devices"> | string | null
    mac_address?: StringNullableWithAggregatesFilter<"devices"> | string | null
    password?: StringNullableWithAggregatesFilter<"devices"> | string | null
    time?: DateTimeWithAggregatesFilter<"devices"> | Date | string
    notes?: StringWithAggregatesFilter<"devices"> | string
    status?: StringWithAggregatesFilter<"devices"> | string
  }

  export type DeviceUserWhereInput = {
    AND?: DeviceUserWhereInput | DeviceUserWhereInput[]
    OR?: DeviceUserWhereInput[]
    NOT?: DeviceUserWhereInput | DeviceUserWhereInput[]
    id?: IntFilter<"DeviceUser"> | number
    userId?: IntFilter<"DeviceUser"> | number
    deviceId?: IntFilter<"DeviceUser"> | number
    role?: StringFilter<"DeviceUser"> | string
    device?: XOR<DevicesScalarRelationFilter, devicesWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    role?: SortOrder
    device?: devicesOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DeviceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_deviceId?: DeviceUserUserIdDeviceIdCompoundUniqueInput
    AND?: DeviceUserWhereInput | DeviceUserWhereInput[]
    OR?: DeviceUserWhereInput[]
    NOT?: DeviceUserWhereInput | DeviceUserWhereInput[]
    userId?: IntFilter<"DeviceUser"> | number
    deviceId?: IntFilter<"DeviceUser"> | number
    role?: StringFilter<"DeviceUser"> | string
    device?: XOR<DevicesScalarRelationFilter, devicesWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceId">

  export type DeviceUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    role?: SortOrder
    _count?: DeviceUserCountOrderByAggregateInput
    _avg?: DeviceUserAvgOrderByAggregateInput
    _max?: DeviceUserMaxOrderByAggregateInput
    _min?: DeviceUserMinOrderByAggregateInput
    _sum?: DeviceUserSumOrderByAggregateInput
  }

  export type DeviceUserScalarWhereWithAggregatesInput = {
    AND?: DeviceUserScalarWhereWithAggregatesInput | DeviceUserScalarWhereWithAggregatesInput[]
    OR?: DeviceUserScalarWhereWithAggregatesInput[]
    NOT?: DeviceUserScalarWhereWithAggregatesInput | DeviceUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceUser"> | number
    userId?: IntWithAggregatesFilter<"DeviceUser"> | number
    deviceId?: IntWithAggregatesFilter<"DeviceUser"> | number
    role?: StringWithAggregatesFilter<"DeviceUser"> | string
  }

  export type CommandWhereInput = {
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    id?: IntFilter<"Command"> | number
    ruleId?: IntFilter<"Command"> | number
    command?: StringFilter<"Command"> | string
    emailTemplateId?: IntNullableFilter<"Command"> | number | null
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    rule?: XOR<RuleScalarRelationFilter, RuleWhereInput>
    matches?: CommandMatchListRelationFilter
  }

  export type CommandOrderByWithRelationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    command?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    emailTemplate?: EmailTemplateOrderByWithRelationInput
    rule?: RuleOrderByWithRelationInput
    matches?: CommandMatchOrderByRelationAggregateInput
  }

  export type CommandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    ruleId?: IntFilter<"Command"> | number
    command?: StringFilter<"Command"> | string
    emailTemplateId?: IntNullableFilter<"Command"> | number | null
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    rule?: XOR<RuleScalarRelationFilter, RuleWhereInput>
    matches?: CommandMatchListRelationFilter
  }, "id">

  export type CommandOrderByWithAggregationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    command?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    _count?: CommandCountOrderByAggregateInput
    _avg?: CommandAvgOrderByAggregateInput
    _max?: CommandMaxOrderByAggregateInput
    _min?: CommandMinOrderByAggregateInput
    _sum?: CommandSumOrderByAggregateInput
  }

  export type CommandScalarWhereWithAggregatesInput = {
    AND?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    OR?: CommandScalarWhereWithAggregatesInput[]
    NOT?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Command"> | number
    ruleId?: IntWithAggregatesFilter<"Command"> | number
    command?: StringWithAggregatesFilter<"Command"> | string
    emailTemplateId?: IntNullableWithAggregatesFilter<"Command"> | number | null
  }

  export type RuleWhereInput = {
    AND?: RuleWhereInput | RuleWhereInput[]
    OR?: RuleWhereInput[]
    NOT?: RuleWhereInput | RuleWhereInput[]
    id?: IntFilter<"Rule"> | number
    name?: StringFilter<"Rule"> | string
    description?: StringNullableFilter<"Rule"> | string | null
    createdAt?: DateTimeFilter<"Rule"> | Date | string
    updatedAt?: DateTimeFilter<"Rule"> | Date | string
    groupId?: IntNullableFilter<"Rule"> | number | null
    emailTemplateId?: IntNullableFilter<"Rule"> | number | null
    commands?: CommandListRelationFilter
    matches?: CommandMatchListRelationFilter
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    group?: XOR<RuleGroupNullableScalarRelationFilter, RuleGroupWhereInput> | null
  }

  export type RuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupId?: SortOrderInput | SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    commands?: CommandOrderByRelationAggregateInput
    matches?: CommandMatchOrderByRelationAggregateInput
    emailTemplate?: EmailTemplateOrderByWithRelationInput
    group?: RuleGroupOrderByWithRelationInput
  }

  export type RuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RuleWhereInput | RuleWhereInput[]
    OR?: RuleWhereInput[]
    NOT?: RuleWhereInput | RuleWhereInput[]
    name?: StringFilter<"Rule"> | string
    description?: StringNullableFilter<"Rule"> | string | null
    createdAt?: DateTimeFilter<"Rule"> | Date | string
    updatedAt?: DateTimeFilter<"Rule"> | Date | string
    groupId?: IntNullableFilter<"Rule"> | number | null
    emailTemplateId?: IntNullableFilter<"Rule"> | number | null
    commands?: CommandListRelationFilter
    matches?: CommandMatchListRelationFilter
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    group?: XOR<RuleGroupNullableScalarRelationFilter, RuleGroupWhereInput> | null
  }, "id">

  export type RuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupId?: SortOrderInput | SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    _count?: RuleCountOrderByAggregateInput
    _avg?: RuleAvgOrderByAggregateInput
    _max?: RuleMaxOrderByAggregateInput
    _min?: RuleMinOrderByAggregateInput
    _sum?: RuleSumOrderByAggregateInput
  }

  export type RuleScalarWhereWithAggregatesInput = {
    AND?: RuleScalarWhereWithAggregatesInput | RuleScalarWhereWithAggregatesInput[]
    OR?: RuleScalarWhereWithAggregatesInput[]
    NOT?: RuleScalarWhereWithAggregatesInput | RuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rule"> | number
    name?: StringWithAggregatesFilter<"Rule"> | string
    description?: StringNullableWithAggregatesFilter<"Rule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Rule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rule"> | Date | string
    groupId?: IntNullableWithAggregatesFilter<"Rule"> | number | null
    emailTemplateId?: IntNullableWithAggregatesFilter<"Rule"> | number | null
  }

  export type RuleGroupWhereInput = {
    AND?: RuleGroupWhereInput | RuleGroupWhereInput[]
    OR?: RuleGroupWhereInput[]
    NOT?: RuleGroupWhereInput | RuleGroupWhereInput[]
    id?: IntFilter<"RuleGroup"> | number
    name?: StringFilter<"RuleGroup"> | string
    createdAt?: DateTimeFilter<"RuleGroup"> | Date | string
    updatedAt?: DateTimeFilter<"RuleGroup"> | Date | string
    emailTemplateId?: IntNullableFilter<"RuleGroup"> | number | null
    rules?: RuleListRelationFilter
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }

  export type RuleGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    rules?: RuleOrderByRelationAggregateInput
    emailTemplate?: EmailTemplateOrderByWithRelationInput
  }

  export type RuleGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RuleGroupWhereInput | RuleGroupWhereInput[]
    OR?: RuleGroupWhereInput[]
    NOT?: RuleGroupWhereInput | RuleGroupWhereInput[]
    name?: StringFilter<"RuleGroup"> | string
    createdAt?: DateTimeFilter<"RuleGroup"> | Date | string
    updatedAt?: DateTimeFilter<"RuleGroup"> | Date | string
    emailTemplateId?: IntNullableFilter<"RuleGroup"> | number | null
    rules?: RuleListRelationFilter
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }, "id">

  export type RuleGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    _count?: RuleGroupCountOrderByAggregateInput
    _avg?: RuleGroupAvgOrderByAggregateInput
    _max?: RuleGroupMaxOrderByAggregateInput
    _min?: RuleGroupMinOrderByAggregateInput
    _sum?: RuleGroupSumOrderByAggregateInput
  }

  export type RuleGroupScalarWhereWithAggregatesInput = {
    AND?: RuleGroupScalarWhereWithAggregatesInput | RuleGroupScalarWhereWithAggregatesInput[]
    OR?: RuleGroupScalarWhereWithAggregatesInput[]
    NOT?: RuleGroupScalarWhereWithAggregatesInput | RuleGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RuleGroup"> | number
    name?: StringWithAggregatesFilter<"RuleGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RuleGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RuleGroup"> | Date | string
    emailTemplateId?: IntNullableWithAggregatesFilter<"RuleGroup"> | number | null
  }

  export type CommandMatchWhereInput = {
    AND?: CommandMatchWhereInput | CommandMatchWhereInput[]
    OR?: CommandMatchWhereInput[]
    NOT?: CommandMatchWhereInput | CommandMatchWhereInput[]
    id?: IntFilter<"CommandMatch"> | number
    logId?: IntFilter<"CommandMatch"> | number
    logType?: StringFilter<"CommandMatch"> | string
    commandId?: IntFilter<"CommandMatch"> | number
    ruleId?: IntFilter<"CommandMatch"> | number
    commandText?: StringFilter<"CommandMatch"> | string
    logEntry?: StringFilter<"CommandMatch"> | string
    timestamp?: DateTimeFilter<"CommandMatch"> | Date | string
    addressed?: BoolFilter<"CommandMatch"> | boolean
    addressedBy?: IntNullableFilter<"CommandMatch"> | number | null
    addressedAt?: DateTimeFilter<"CommandMatch"> | Date | string
    notes?: StringNullableFilter<"CommandMatch"> | string | null
    emailSent?: BoolFilter<"CommandMatch"> | boolean
    addressedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    command?: XOR<CommandScalarRelationFilter, CommandWhereInput>
    rule?: XOR<RuleScalarRelationFilter, RuleWhereInput>
    User?: UserListRelationFilter
  }

  export type CommandMatchOrderByWithRelationInput = {
    id?: SortOrder
    logId?: SortOrder
    logType?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    commandText?: SortOrder
    logEntry?: SortOrder
    timestamp?: SortOrder
    addressed?: SortOrder
    addressedBy?: SortOrderInput | SortOrder
    addressedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    addressedByUser?: UserOrderByWithRelationInput
    command?: CommandOrderByWithRelationInput
    rule?: RuleOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
  }

  export type CommandMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandMatchWhereInput | CommandMatchWhereInput[]
    OR?: CommandMatchWhereInput[]
    NOT?: CommandMatchWhereInput | CommandMatchWhereInput[]
    logId?: IntFilter<"CommandMatch"> | number
    logType?: StringFilter<"CommandMatch"> | string
    commandId?: IntFilter<"CommandMatch"> | number
    ruleId?: IntFilter<"CommandMatch"> | number
    commandText?: StringFilter<"CommandMatch"> | string
    logEntry?: StringFilter<"CommandMatch"> | string
    timestamp?: DateTimeFilter<"CommandMatch"> | Date | string
    addressed?: BoolFilter<"CommandMatch"> | boolean
    addressedBy?: IntNullableFilter<"CommandMatch"> | number | null
    addressedAt?: DateTimeFilter<"CommandMatch"> | Date | string
    notes?: StringNullableFilter<"CommandMatch"> | string | null
    emailSent?: BoolFilter<"CommandMatch"> | boolean
    addressedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    command?: XOR<CommandScalarRelationFilter, CommandWhereInput>
    rule?: XOR<RuleScalarRelationFilter, RuleWhereInput>
    User?: UserListRelationFilter
  }, "id">

  export type CommandMatchOrderByWithAggregationInput = {
    id?: SortOrder
    logId?: SortOrder
    logType?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    commandText?: SortOrder
    logEntry?: SortOrder
    timestamp?: SortOrder
    addressed?: SortOrder
    addressedBy?: SortOrderInput | SortOrder
    addressedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    _count?: CommandMatchCountOrderByAggregateInput
    _avg?: CommandMatchAvgOrderByAggregateInput
    _max?: CommandMatchMaxOrderByAggregateInput
    _min?: CommandMatchMinOrderByAggregateInput
    _sum?: CommandMatchSumOrderByAggregateInput
  }

  export type CommandMatchScalarWhereWithAggregatesInput = {
    AND?: CommandMatchScalarWhereWithAggregatesInput | CommandMatchScalarWhereWithAggregatesInput[]
    OR?: CommandMatchScalarWhereWithAggregatesInput[]
    NOT?: CommandMatchScalarWhereWithAggregatesInput | CommandMatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommandMatch"> | number
    logId?: IntWithAggregatesFilter<"CommandMatch"> | number
    logType?: StringWithAggregatesFilter<"CommandMatch"> | string
    commandId?: IntWithAggregatesFilter<"CommandMatch"> | number
    ruleId?: IntWithAggregatesFilter<"CommandMatch"> | number
    commandText?: StringWithAggregatesFilter<"CommandMatch"> | string
    logEntry?: StringWithAggregatesFilter<"CommandMatch"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CommandMatch"> | Date | string
    addressed?: BoolWithAggregatesFilter<"CommandMatch"> | boolean
    addressedBy?: IntNullableWithAggregatesFilter<"CommandMatch"> | number | null
    addressedAt?: DateTimeWithAggregatesFilter<"CommandMatch"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"CommandMatch"> | string | null
    emailSent?: BoolWithAggregatesFilter<"CommandMatch"> | boolean
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    userId?: IntFilter<"ActivityLog"> | number
    actionType?: StringFilter<"ActivityLog"> | string
    targetType?: StringFilter<"ActivityLog"> | string
    targetId?: IntNullableFilter<"ActivityLog"> | number | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: IntFilter<"ActivityLog"> | number
    actionType?: StringFilter<"ActivityLog"> | string
    targetType?: StringFilter<"ActivityLog"> | string
    targetId?: IntNullableFilter<"ActivityLog"> | number | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    userId?: IntWithAggregatesFilter<"ActivityLog"> | number
    actionType?: StringWithAggregatesFilter<"ActivityLog"> | string
    targetType?: StringWithAggregatesFilter<"ActivityLog"> | string
    targetId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: IntFilter<"EmailTemplate"> | number
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    AlertCondition?: AlertConditionListRelationFilter
    Command?: CommandListRelationFilter
    Rule?: RuleListRelationFilter
    RuleGroup?: RuleGroupListRelationFilter
    SavedQuery?: SavedQueryListRelationFilter
    assignedUsers?: UserEmailTemplateListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AlertCondition?: AlertConditionOrderByRelationAggregateInput
    Command?: CommandOrderByRelationAggregateInput
    Rule?: RuleOrderByRelationAggregateInput
    RuleGroup?: RuleGroupOrderByRelationAggregateInput
    SavedQuery?: SavedQueryOrderByRelationAggregateInput
    assignedUsers?: UserEmailTemplateOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    AlertCondition?: AlertConditionListRelationFilter
    Command?: CommandListRelationFilter
    Rule?: RuleListRelationFilter
    RuleGroup?: RuleGroupListRelationFilter
    SavedQuery?: SavedQueryListRelationFilter
    assignedUsers?: UserEmailTemplateListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _avg?: EmailTemplateAvgOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
    _sum?: EmailTemplateSumOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailTemplate"> | number
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    body?: StringWithAggregatesFilter<"EmailTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    role?: StringNullableListFilter<"User">
    Mobile?: IntNullableFilter<"User"> | number | null
    PrimaryContact?: StringNullableFilter<"User"> | string | null
    MobileContact?: IntNullableFilter<"User"> | number | null
    Relationship?: StringNullableFilter<"User"> | string | null
    SecondContact?: StringNullableFilter<"User"> | string | null
    SecondMobile?: IntNullableFilter<"User"> | number | null
    SecondRelationship?: StringNullableFilter<"User"> | string | null
    Remarks?: StringNullableFilter<"User"> | string | null
    ndafile?: StringNullableFilter<"User"> | string | null
    ndasubmissiondate?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    location?: StringNullableListFilter<"User">
    ActivityLog?: ActivityLogListRelationFilter
    CommandMatch?: CommandMatchListRelationFilter
    devices?: DeviceUserListRelationFilter
    DriveFile?: DriveFileListRelationFilter
    grantedPermissions?: DriveFilePermissionListRelationFilter
    DriveFilePermission?: DriveFilePermissionListRelationFilter
    DriveFolder?: DriveFolderListRelationFilter
    Feedback?: FeedbackListRelationFilter
    FeedbackRecipient?: FeedbackRecipientListRelationFilter
    GroupMember?: GroupMemberListRelationFilter
    Message?: MessageListRelationFilter
    NotificationRead?: NotificationReadListRelationFilter
    ProjectAssignment?: ProjectAssignmentListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    createdTickets?: SupportTicketListRelationFilter
    TeamLeader?: TeamLeaderListRelationFilter
    TeamMember?: TeamMemberListRelationFilter
    TicketAttachment?: TicketAttachmentListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    emailTemplates?: UserEmailTemplateListRelationFilter
    UserPermission?: UserPermissionListRelationFilter
    audit_steps?: AuditStepListRelationFilter
    receivedPermissions?: DriveFilePermissionListRelationFilter
    addressedMatches?: CommandMatchListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    Mobile?: SortOrderInput | SortOrder
    PrimaryContact?: SortOrderInput | SortOrder
    MobileContact?: SortOrderInput | SortOrder
    Relationship?: SortOrderInput | SortOrder
    SecondContact?: SortOrderInput | SortOrder
    SecondMobile?: SortOrderInput | SortOrder
    SecondRelationship?: SortOrderInput | SortOrder
    Remarks?: SortOrderInput | SortOrder
    ndafile?: SortOrderInput | SortOrder
    ndasubmissiondate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    ActivityLog?: ActivityLogOrderByRelationAggregateInput
    CommandMatch?: CommandMatchOrderByRelationAggregateInput
    devices?: DeviceUserOrderByRelationAggregateInput
    DriveFile?: DriveFileOrderByRelationAggregateInput
    grantedPermissions?: DriveFilePermissionOrderByRelationAggregateInput
    DriveFilePermission?: DriveFilePermissionOrderByRelationAggregateInput
    DriveFolder?: DriveFolderOrderByRelationAggregateInput
    Feedback?: FeedbackOrderByRelationAggregateInput
    FeedbackRecipient?: FeedbackRecipientOrderByRelationAggregateInput
    GroupMember?: GroupMemberOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
    NotificationRead?: NotificationReadOrderByRelationAggregateInput
    ProjectAssignment?: ProjectAssignmentOrderByRelationAggregateInput
    assignedTickets?: SupportTicketOrderByRelationAggregateInput
    createdTickets?: SupportTicketOrderByRelationAggregateInput
    TeamLeader?: TeamLeaderOrderByRelationAggregateInput
    TeamMember?: TeamMemberOrderByRelationAggregateInput
    TicketAttachment?: TicketAttachmentOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
    emailTemplates?: UserEmailTemplateOrderByRelationAggregateInput
    UserPermission?: UserPermissionOrderByRelationAggregateInput
    audit_steps?: AuditStepOrderByRelationAggregateInput
    receivedPermissions?: DriveFilePermissionOrderByRelationAggregateInput
    addressedMatches?: CommandMatchOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringNullableListFilter<"User">
    Mobile?: IntNullableFilter<"User"> | number | null
    PrimaryContact?: StringNullableFilter<"User"> | string | null
    MobileContact?: IntNullableFilter<"User"> | number | null
    Relationship?: StringNullableFilter<"User"> | string | null
    SecondContact?: StringNullableFilter<"User"> | string | null
    SecondMobile?: IntNullableFilter<"User"> | number | null
    SecondRelationship?: StringNullableFilter<"User"> | string | null
    Remarks?: StringNullableFilter<"User"> | string | null
    ndafile?: StringNullableFilter<"User"> | string | null
    ndasubmissiondate?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    location?: StringNullableListFilter<"User">
    ActivityLog?: ActivityLogListRelationFilter
    CommandMatch?: CommandMatchListRelationFilter
    devices?: DeviceUserListRelationFilter
    DriveFile?: DriveFileListRelationFilter
    grantedPermissions?: DriveFilePermissionListRelationFilter
    DriveFilePermission?: DriveFilePermissionListRelationFilter
    DriveFolder?: DriveFolderListRelationFilter
    Feedback?: FeedbackListRelationFilter
    FeedbackRecipient?: FeedbackRecipientListRelationFilter
    GroupMember?: GroupMemberListRelationFilter
    Message?: MessageListRelationFilter
    NotificationRead?: NotificationReadListRelationFilter
    ProjectAssignment?: ProjectAssignmentListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    createdTickets?: SupportTicketListRelationFilter
    TeamLeader?: TeamLeaderListRelationFilter
    TeamMember?: TeamMemberListRelationFilter
    TicketAttachment?: TicketAttachmentListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    emailTemplates?: UserEmailTemplateListRelationFilter
    UserPermission?: UserPermissionListRelationFilter
    audit_steps?: AuditStepListRelationFilter
    receivedPermissions?: DriveFilePermissionListRelationFilter
    addressedMatches?: CommandMatchListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    Mobile?: SortOrderInput | SortOrder
    PrimaryContact?: SortOrderInput | SortOrder
    MobileContact?: SortOrderInput | SortOrder
    Relationship?: SortOrderInput | SortOrder
    SecondContact?: SortOrderInput | SortOrder
    SecondMobile?: SortOrderInput | SortOrder
    SecondRelationship?: SortOrderInput | SortOrder
    Remarks?: SortOrderInput | SortOrder
    ndafile?: SortOrderInput | SortOrder
    ndasubmissiondate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableListFilter<"User">
    Mobile?: IntNullableWithAggregatesFilter<"User"> | number | null
    PrimaryContact?: StringNullableWithAggregatesFilter<"User"> | string | null
    MobileContact?: IntNullableWithAggregatesFilter<"User"> | number | null
    Relationship?: StringNullableWithAggregatesFilter<"User"> | string | null
    SecondContact?: StringNullableWithAggregatesFilter<"User"> | string | null
    SecondMobile?: IntNullableWithAggregatesFilter<"User"> | number | null
    SecondRelationship?: StringNullableWithAggregatesFilter<"User"> | string | null
    Remarks?: StringNullableWithAggregatesFilter<"User"> | string | null
    ndafile?: StringNullableWithAggregatesFilter<"User"> | string | null
    ndasubmissiondate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    location?: StringNullableListFilter<"User">
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter<"Group"> | number
    name?: StringFilter<"Group"> | string
    createdBy?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    members?: GroupMemberListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: GroupMemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    createdBy?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    members?: GroupMemberListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Group"> | number
    name?: StringWithAggregatesFilter<"Group"> | string
    createdBy?: StringWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: IntFilter<"GroupMember"> | number
    userId?: IntFilter<"GroupMember"> | number
    groupId?: IntFilter<"GroupMember"> | number
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_groupId?: GroupMemberUserIdGroupIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    userId?: IntFilter<"GroupMember"> | number
    groupId?: IntFilter<"GroupMember"> | number
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_groupId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _avg?: GroupMemberAvgOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
    _sum?: GroupMemberSumOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupMember"> | number
    userId?: IntWithAggregatesFilter<"GroupMember"> | number
    groupId?: IntWithAggregatesFilter<"GroupMember"> | number
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    content?: StringFilter<"Message"> | string
    senderId?: IntFilter<"Message"> | number
    groupId?: IntFilter<"Message"> | number
    edited?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    fileAttachment?: StringNullableFilter<"Message"> | string | null
    fileOriginalName?: StringNullableFilter<"Message"> | string | null
    fileType?: StringNullableFilter<"Message"> | string | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    edited?: SortOrder
    createdAt?: SortOrder
    fileAttachment?: SortOrderInput | SortOrder
    fileOriginalName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    group?: GroupOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    senderId?: IntFilter<"Message"> | number
    groupId?: IntFilter<"Message"> | number
    edited?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    fileAttachment?: StringNullableFilter<"Message"> | string | null
    fileOriginalName?: StringNullableFilter<"Message"> | string | null
    fileType?: StringNullableFilter<"Message"> | string | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    edited?: SortOrder
    createdAt?: SortOrder
    fileAttachment?: SortOrderInput | SortOrder
    fileOriginalName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    content?: StringWithAggregatesFilter<"Message"> | string
    senderId?: IntWithAggregatesFilter<"Message"> | number
    groupId?: IntWithAggregatesFilter<"Message"> | number
    edited?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    fileAttachment?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileOriginalName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileType?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type UserEmailTemplateWhereInput = {
    AND?: UserEmailTemplateWhereInput | UserEmailTemplateWhereInput[]
    OR?: UserEmailTemplateWhereInput[]
    NOT?: UserEmailTemplateWhereInput | UserEmailTemplateWhereInput[]
    userId?: IntFilter<"UserEmailTemplate"> | number
    emailTemplateId?: IntFilter<"UserEmailTemplate"> | number
    assignedAt?: DateTimeFilter<"UserEmailTemplate"> | Date | string
    emailTemplate?: XOR<EmailTemplateScalarRelationFilter, EmailTemplateWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserEmailTemplateOrderByWithRelationInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
    assignedAt?: SortOrder
    emailTemplate?: EmailTemplateOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserEmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    userId_emailTemplateId?: UserEmailTemplateUserIdEmailTemplateIdCompoundUniqueInput
    AND?: UserEmailTemplateWhereInput | UserEmailTemplateWhereInput[]
    OR?: UserEmailTemplateWhereInput[]
    NOT?: UserEmailTemplateWhereInput | UserEmailTemplateWhereInput[]
    userId?: IntFilter<"UserEmailTemplate"> | number
    emailTemplateId?: IntFilter<"UserEmailTemplate"> | number
    assignedAt?: DateTimeFilter<"UserEmailTemplate"> | Date | string
    emailTemplate?: XOR<EmailTemplateScalarRelationFilter, EmailTemplateWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_emailTemplateId">

  export type UserEmailTemplateOrderByWithAggregationInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
    assignedAt?: SortOrder
    _count?: UserEmailTemplateCountOrderByAggregateInput
    _avg?: UserEmailTemplateAvgOrderByAggregateInput
    _max?: UserEmailTemplateMaxOrderByAggregateInput
    _min?: UserEmailTemplateMinOrderByAggregateInput
    _sum?: UserEmailTemplateSumOrderByAggregateInput
  }

  export type UserEmailTemplateScalarWhereWithAggregatesInput = {
    AND?: UserEmailTemplateScalarWhereWithAggregatesInput | UserEmailTemplateScalarWhereWithAggregatesInput[]
    OR?: UserEmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: UserEmailTemplateScalarWhereWithAggregatesInput | UserEmailTemplateScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserEmailTemplate"> | number
    emailTemplateId?: IntWithAggregatesFilter<"UserEmailTemplate"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"UserEmailTemplate"> | Date | string
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    name?: StringFilter<"Roles"> | string
    description?: StringFilter<"Roles"> | string
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    name?: StringFilter<"Roles"> | string
    description?: StringFilter<"Roles"> | string
  }, "id">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    name?: StringWithAggregatesFilter<"Roles"> | string
    description?: StringWithAggregatesFilter<"Roles"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    postDate?: DateTimeFilter<"Notification"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdBy?: IntFilter<"Notification"> | number
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    important?: BoolFilter<"Notification"> | boolean
    reads?: NotificationReadListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    important?: SortOrder
    reads?: NotificationReadOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    postDate?: DateTimeFilter<"Notification"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdBy?: IntFilter<"Notification"> | number
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    important?: BoolFilter<"Notification"> | boolean
    reads?: NotificationReadListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    important?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    postDate?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdBy?: IntWithAggregatesFilter<"Notification"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    important?: BoolWithAggregatesFilter<"Notification"> | boolean
  }

  export type NotificationReadWhereInput = {
    AND?: NotificationReadWhereInput | NotificationReadWhereInput[]
    OR?: NotificationReadWhereInput[]
    NOT?: NotificationReadWhereInput | NotificationReadWhereInput[]
    id?: IntFilter<"NotificationRead"> | number
    notificationId?: IntFilter<"NotificationRead"> | number
    userId?: IntFilter<"NotificationRead"> | number
    readAt?: DateTimeFilter<"NotificationRead"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationReadOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationReadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    notificationId_userId?: NotificationReadNotificationIdUserIdCompoundUniqueInput
    AND?: NotificationReadWhereInput | NotificationReadWhereInput[]
    OR?: NotificationReadWhereInput[]
    NOT?: NotificationReadWhereInput | NotificationReadWhereInput[]
    notificationId?: IntFilter<"NotificationRead"> | number
    userId?: IntFilter<"NotificationRead"> | number
    readAt?: DateTimeFilter<"NotificationRead"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "notificationId_userId">

  export type NotificationReadOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: NotificationReadCountOrderByAggregateInput
    _avg?: NotificationReadAvgOrderByAggregateInput
    _max?: NotificationReadMaxOrderByAggregateInput
    _min?: NotificationReadMinOrderByAggregateInput
    _sum?: NotificationReadSumOrderByAggregateInput
  }

  export type NotificationReadScalarWhereWithAggregatesInput = {
    AND?: NotificationReadScalarWhereWithAggregatesInput | NotificationReadScalarWhereWithAggregatesInput[]
    OR?: NotificationReadScalarWhereWithAggregatesInput[]
    NOT?: NotificationReadScalarWhereWithAggregatesInput | NotificationReadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationRead"> | number
    notificationId?: IntWithAggregatesFilter<"NotificationRead"> | number
    userId?: IntWithAggregatesFilter<"NotificationRead"> | number
    readAt?: DateTimeWithAggregatesFilter<"NotificationRead"> | Date | string
  }

  export type SavedQueryWhereInput = {
    AND?: SavedQueryWhereInput | SavedQueryWhereInput[]
    OR?: SavedQueryWhereInput[]
    NOT?: SavedQueryWhereInput | SavedQueryWhereInput[]
    id?: IntFilter<"SavedQuery"> | number
    name?: StringFilter<"SavedQuery"> | string
    description?: StringNullableFilter<"SavedQuery"> | string | null
    tableName?: StringFilter<"SavedQuery"> | string
    columns?: StringNullableListFilter<"SavedQuery">
    conditions?: JsonNullableFilter<"SavedQuery">
    emailTemplateId?: IntNullableFilter<"SavedQuery"> | number | null
    createdAt?: DateTimeFilter<"SavedQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SavedQuery"> | Date | string
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }

  export type SavedQueryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tableName?: SortOrder
    columns?: SortOrder
    conditions?: SortOrderInput | SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplate?: EmailTemplateOrderByWithRelationInput
  }

  export type SavedQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SavedQueryWhereInput | SavedQueryWhereInput[]
    OR?: SavedQueryWhereInput[]
    NOT?: SavedQueryWhereInput | SavedQueryWhereInput[]
    description?: StringNullableFilter<"SavedQuery"> | string | null
    tableName?: StringFilter<"SavedQuery"> | string
    columns?: StringNullableListFilter<"SavedQuery">
    conditions?: JsonNullableFilter<"SavedQuery">
    emailTemplateId?: IntNullableFilter<"SavedQuery"> | number | null
    createdAt?: DateTimeFilter<"SavedQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SavedQuery"> | Date | string
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }, "id" | "name">

  export type SavedQueryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tableName?: SortOrder
    columns?: SortOrder
    conditions?: SortOrderInput | SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SavedQueryCountOrderByAggregateInput
    _avg?: SavedQueryAvgOrderByAggregateInput
    _max?: SavedQueryMaxOrderByAggregateInput
    _min?: SavedQueryMinOrderByAggregateInput
    _sum?: SavedQuerySumOrderByAggregateInput
  }

  export type SavedQueryScalarWhereWithAggregatesInput = {
    AND?: SavedQueryScalarWhereWithAggregatesInput | SavedQueryScalarWhereWithAggregatesInput[]
    OR?: SavedQueryScalarWhereWithAggregatesInput[]
    NOT?: SavedQueryScalarWhereWithAggregatesInput | SavedQueryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SavedQuery"> | number
    name?: StringWithAggregatesFilter<"SavedQuery"> | string
    description?: StringNullableWithAggregatesFilter<"SavedQuery"> | string | null
    tableName?: StringWithAggregatesFilter<"SavedQuery"> | string
    columns?: StringNullableListFilter<"SavedQuery">
    conditions?: JsonNullableWithAggregatesFilter<"SavedQuery">
    emailTemplateId?: IntNullableWithAggregatesFilter<"SavedQuery"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SavedQuery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedQuery"> | Date | string
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: IntFilter<"TicketComment"> | number
    ticketId?: IntFilter<"TicketComment"> | number
    userId?: IntFilter<"TicketComment"> | number
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    TicketAttachment?: TicketAttachmentListRelationFilter
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    TicketAttachment?: TicketAttachmentOrderByRelationAggregateInput
    ticket?: SupportTicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    ticketId?: IntFilter<"TicketComment"> | number
    userId?: IntFilter<"TicketComment"> | number
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    TicketAttachment?: TicketAttachmentListRelationFilter
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _avg?: TicketCommentAvgOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
    _sum?: TicketCommentSumOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketComment"> | number
    ticketId?: IntWithAggregatesFilter<"TicketComment"> | number
    userId?: IntWithAggregatesFilter<"TicketComment"> | number
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    assignedToId?: IntNullableFilter<"SupportTicket"> | number | null
    createdById?: IntFilter<"SupportTicket"> | number
    relatedDeviceId?: IntNullableFilter<"SupportTicket"> | number | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    relatedDevice?: XOR<DevicesNullableScalarRelationFilter, devicesWhereInput> | null
    attachments?: TicketAttachmentListRelationFilter
    comments?: TicketCommentListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrderInput | SortOrder
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    relatedDevice?: devicesOrderByWithRelationInput
    attachments?: TicketAttachmentOrderByRelationAggregateInput
    comments?: TicketCommentOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    assignedToId?: IntNullableFilter<"SupportTicket"> | number | null
    createdById?: IntFilter<"SupportTicket"> | number
    relatedDeviceId?: IntNullableFilter<"SupportTicket"> | number | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    relatedDevice?: XOR<DevicesNullableScalarRelationFilter, devicesWhereInput> | null
    attachments?: TicketAttachmentListRelationFilter
    comments?: TicketCommentListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrderInput | SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _avg?: SupportTicketAvgOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
    _sum?: SupportTicketSumOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupportTicket"> | number
    title?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: StringWithAggregatesFilter<"SupportTicket"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    assignedToId?: IntNullableWithAggregatesFilter<"SupportTicket"> | number | null
    createdById?: IntWithAggregatesFilter<"SupportTicket"> | number
    relatedDeviceId?: IntNullableWithAggregatesFilter<"SupportTicket"> | number | null
  }

  export type TicketAttachmentWhereInput = {
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    id?: IntFilter<"TicketAttachment"> | number
    filename?: StringFilter<"TicketAttachment"> | string
    originalFilename?: StringFilter<"TicketAttachment"> | string
    fileSize?: IntFilter<"TicketAttachment"> | number
    mimeType?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: IntNullableFilter<"TicketAttachment"> | number | null
    commentId?: IntNullableFilter<"TicketAttachment"> | number | null
    uploaderId?: IntFilter<"TicketAttachment"> | number
    comment?: XOR<TicketCommentNullableScalarRelationFilter, TicketCommentWhereInput> | null
    ticket?: XOR<SupportTicketNullableScalarRelationFilter, SupportTicketWhereInput> | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    comment?: TicketCommentOrderByWithRelationInput
    ticket?: SupportTicketOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type TicketAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    filename?: StringFilter<"TicketAttachment"> | string
    originalFilename?: StringFilter<"TicketAttachment"> | string
    fileSize?: IntFilter<"TicketAttachment"> | number
    mimeType?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: IntNullableFilter<"TicketAttachment"> | number | null
    commentId?: IntNullableFilter<"TicketAttachment"> | number | null
    uploaderId?: IntFilter<"TicketAttachment"> | number
    comment?: XOR<TicketCommentNullableScalarRelationFilter, TicketCommentWhereInput> | null
    ticket?: XOR<SupportTicketNullableScalarRelationFilter, SupportTicketWhereInput> | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TicketAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    _count?: TicketAttachmentCountOrderByAggregateInput
    _avg?: TicketAttachmentAvgOrderByAggregateInput
    _max?: TicketAttachmentMaxOrderByAggregateInput
    _min?: TicketAttachmentMinOrderByAggregateInput
    _sum?: TicketAttachmentSumOrderByAggregateInput
  }

  export type TicketAttachmentScalarWhereWithAggregatesInput = {
    AND?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    OR?: TicketAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketAttachment"> | number
    filename?: StringWithAggregatesFilter<"TicketAttachment"> | string
    originalFilename?: StringWithAggregatesFilter<"TicketAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"TicketAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"TicketAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketAttachment"> | Date | string
    ticketId?: IntNullableWithAggregatesFilter<"TicketAttachment"> | number | null
    commentId?: IntNullableWithAggregatesFilter<"TicketAttachment"> | number | null
    uploaderId?: IntWithAggregatesFilter<"TicketAttachment"> | number
  }

  export type AlertConditionWhereInput = {
    AND?: AlertConditionWhereInput | AlertConditionWhereInput[]
    OR?: AlertConditionWhereInput[]
    NOT?: AlertConditionWhereInput | AlertConditionWhereInput[]
    id?: IntFilter<"AlertCondition"> | number
    name?: StringFilter<"AlertCondition"> | string
    sourceTable?: StringFilter<"AlertCondition"> | string
    fieldName?: StringFilter<"AlertCondition"> | string
    comparator?: StringFilter<"AlertCondition"> | string
    thresholdValue?: StringFilter<"AlertCondition"> | string
    timeWindowMin?: IntNullableFilter<"AlertCondition"> | number | null
    repeatIntervalMin?: IntNullableFilter<"AlertCondition"> | number | null
    countThreshold?: IntNullableFilter<"AlertCondition"> | number | null
    lastTriggeredAt?: DateTimeNullableFilter<"AlertCondition"> | Date | string | null
    active?: BoolFilter<"AlertCondition"> | boolean
    emailTemplateId?: IntNullableFilter<"AlertCondition"> | number | null
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    triggeredAlerts?: AlertEventListRelationFilter
  }

  export type AlertConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sourceTable?: SortOrder
    fieldName?: SortOrder
    comparator?: SortOrder
    thresholdValue?: SortOrder
    timeWindowMin?: SortOrderInput | SortOrder
    repeatIntervalMin?: SortOrderInput | SortOrder
    countThreshold?: SortOrderInput | SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    active?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    emailTemplate?: EmailTemplateOrderByWithRelationInput
    triggeredAlerts?: AlertEventOrderByRelationAggregateInput
  }

  export type AlertConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlertConditionWhereInput | AlertConditionWhereInput[]
    OR?: AlertConditionWhereInput[]
    NOT?: AlertConditionWhereInput | AlertConditionWhereInput[]
    name?: StringFilter<"AlertCondition"> | string
    sourceTable?: StringFilter<"AlertCondition"> | string
    fieldName?: StringFilter<"AlertCondition"> | string
    comparator?: StringFilter<"AlertCondition"> | string
    thresholdValue?: StringFilter<"AlertCondition"> | string
    timeWindowMin?: IntNullableFilter<"AlertCondition"> | number | null
    repeatIntervalMin?: IntNullableFilter<"AlertCondition"> | number | null
    countThreshold?: IntNullableFilter<"AlertCondition"> | number | null
    lastTriggeredAt?: DateTimeNullableFilter<"AlertCondition"> | Date | string | null
    active?: BoolFilter<"AlertCondition"> | boolean
    emailTemplateId?: IntNullableFilter<"AlertCondition"> | number | null
    emailTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    triggeredAlerts?: AlertEventListRelationFilter
  }, "id">

  export type AlertConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sourceTable?: SortOrder
    fieldName?: SortOrder
    comparator?: SortOrder
    thresholdValue?: SortOrder
    timeWindowMin?: SortOrderInput | SortOrder
    repeatIntervalMin?: SortOrderInput | SortOrder
    countThreshold?: SortOrderInput | SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    active?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    _count?: AlertConditionCountOrderByAggregateInput
    _avg?: AlertConditionAvgOrderByAggregateInput
    _max?: AlertConditionMaxOrderByAggregateInput
    _min?: AlertConditionMinOrderByAggregateInput
    _sum?: AlertConditionSumOrderByAggregateInput
  }

  export type AlertConditionScalarWhereWithAggregatesInput = {
    AND?: AlertConditionScalarWhereWithAggregatesInput | AlertConditionScalarWhereWithAggregatesInput[]
    OR?: AlertConditionScalarWhereWithAggregatesInput[]
    NOT?: AlertConditionScalarWhereWithAggregatesInput | AlertConditionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AlertCondition"> | number
    name?: StringWithAggregatesFilter<"AlertCondition"> | string
    sourceTable?: StringWithAggregatesFilter<"AlertCondition"> | string
    fieldName?: StringWithAggregatesFilter<"AlertCondition"> | string
    comparator?: StringWithAggregatesFilter<"AlertCondition"> | string
    thresholdValue?: StringWithAggregatesFilter<"AlertCondition"> | string
    timeWindowMin?: IntNullableWithAggregatesFilter<"AlertCondition"> | number | null
    repeatIntervalMin?: IntNullableWithAggregatesFilter<"AlertCondition"> | number | null
    countThreshold?: IntNullableWithAggregatesFilter<"AlertCondition"> | number | null
    lastTriggeredAt?: DateTimeNullableWithAggregatesFilter<"AlertCondition"> | Date | string | null
    active?: BoolWithAggregatesFilter<"AlertCondition"> | boolean
    emailTemplateId?: IntNullableWithAggregatesFilter<"AlertCondition"> | number | null
  }

  export type AlertEventWhereInput = {
    AND?: AlertEventWhereInput | AlertEventWhereInput[]
    OR?: AlertEventWhereInput[]
    NOT?: AlertEventWhereInput | AlertEventWhereInput[]
    id?: IntFilter<"AlertEvent"> | number
    conditionId?: IntFilter<"AlertEvent"> | number
    triggeredAt?: DateTimeFilter<"AlertEvent"> | Date | string
    resolved?: BoolFilter<"AlertEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    notes?: StringNullableFilter<"AlertEvent"> | string | null
    alertCondition?: XOR<AlertConditionScalarRelationFilter, AlertConditionWhereInput>
  }

  export type AlertEventOrderByWithRelationInput = {
    id?: SortOrder
    conditionId?: SortOrder
    triggeredAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    alertCondition?: AlertConditionOrderByWithRelationInput
  }

  export type AlertEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlertEventWhereInput | AlertEventWhereInput[]
    OR?: AlertEventWhereInput[]
    NOT?: AlertEventWhereInput | AlertEventWhereInput[]
    conditionId?: IntFilter<"AlertEvent"> | number
    triggeredAt?: DateTimeFilter<"AlertEvent"> | Date | string
    resolved?: BoolFilter<"AlertEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    notes?: StringNullableFilter<"AlertEvent"> | string | null
    alertCondition?: XOR<AlertConditionScalarRelationFilter, AlertConditionWhereInput>
  }, "id">

  export type AlertEventOrderByWithAggregationInput = {
    id?: SortOrder
    conditionId?: SortOrder
    triggeredAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AlertEventCountOrderByAggregateInput
    _avg?: AlertEventAvgOrderByAggregateInput
    _max?: AlertEventMaxOrderByAggregateInput
    _min?: AlertEventMinOrderByAggregateInput
    _sum?: AlertEventSumOrderByAggregateInput
  }

  export type AlertEventScalarWhereWithAggregatesInput = {
    AND?: AlertEventScalarWhereWithAggregatesInput | AlertEventScalarWhereWithAggregatesInput[]
    OR?: AlertEventScalarWhereWithAggregatesInput[]
    NOT?: AlertEventScalarWhereWithAggregatesInput | AlertEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AlertEvent"> | number
    conditionId?: IntWithAggregatesFilter<"AlertEvent"> | number
    triggeredAt?: DateTimeWithAggregatesFilter<"AlertEvent"> | Date | string
    resolved?: BoolWithAggregatesFilter<"AlertEvent"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"AlertEvent"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"AlertEvent"> | string | null
  }

  export type LibraryEntryWhereInput = {
    AND?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    OR?: LibraryEntryWhereInput[]
    NOT?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    id?: IntFilter<"LibraryEntry"> | number
    refNo?: StringFilter<"LibraryEntry"> | string
    category?: StringFilter<"LibraryEntry"> | string
    title?: StringFilter<"LibraryEntry"> | string
    author?: StringNullableFilter<"LibraryEntry"> | string | null
    pubYear?: IntNullableFilter<"LibraryEntry"> | number | null
    creationDate?: DateTimeFilter<"LibraryEntry"> | Date | string
    borrower?: StringNullableFilter<"LibraryEntry"> | string | null
    loanDate?: DateTimeNullableFilter<"LibraryEntry"> | Date | string | null
    remarks?: StringNullableFilter<"LibraryEntry"> | string | null
    attachmentUrl?: StringNullableFilter<"LibraryEntry"> | string | null
    attachmentFilename?: StringNullableFilter<"LibraryEntry"> | string | null
    createdAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
  }

  export type LibraryEntryOrderByWithRelationInput = {
    id?: SortOrder
    refNo?: SortOrder
    category?: SortOrder
    title?: SortOrder
    author?: SortOrderInput | SortOrder
    pubYear?: SortOrderInput | SortOrder
    creationDate?: SortOrder
    borrower?: SortOrderInput | SortOrder
    loanDate?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    attachmentFilename?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    OR?: LibraryEntryWhereInput[]
    NOT?: LibraryEntryWhereInput | LibraryEntryWhereInput[]
    refNo?: StringFilter<"LibraryEntry"> | string
    category?: StringFilter<"LibraryEntry"> | string
    title?: StringFilter<"LibraryEntry"> | string
    author?: StringNullableFilter<"LibraryEntry"> | string | null
    pubYear?: IntNullableFilter<"LibraryEntry"> | number | null
    creationDate?: DateTimeFilter<"LibraryEntry"> | Date | string
    borrower?: StringNullableFilter<"LibraryEntry"> | string | null
    loanDate?: DateTimeNullableFilter<"LibraryEntry"> | Date | string | null
    remarks?: StringNullableFilter<"LibraryEntry"> | string | null
    attachmentUrl?: StringNullableFilter<"LibraryEntry"> | string | null
    attachmentFilename?: StringNullableFilter<"LibraryEntry"> | string | null
    createdAt?: DateTimeFilter<"LibraryEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryEntry"> | Date | string
  }, "id">

  export type LibraryEntryOrderByWithAggregationInput = {
    id?: SortOrder
    refNo?: SortOrder
    category?: SortOrder
    title?: SortOrder
    author?: SortOrderInput | SortOrder
    pubYear?: SortOrderInput | SortOrder
    creationDate?: SortOrder
    borrower?: SortOrderInput | SortOrder
    loanDate?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    attachmentFilename?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryEntryCountOrderByAggregateInput
    _avg?: LibraryEntryAvgOrderByAggregateInput
    _max?: LibraryEntryMaxOrderByAggregateInput
    _min?: LibraryEntryMinOrderByAggregateInput
    _sum?: LibraryEntrySumOrderByAggregateInput
  }

  export type LibraryEntryScalarWhereWithAggregatesInput = {
    AND?: LibraryEntryScalarWhereWithAggregatesInput | LibraryEntryScalarWhereWithAggregatesInput[]
    OR?: LibraryEntryScalarWhereWithAggregatesInput[]
    NOT?: LibraryEntryScalarWhereWithAggregatesInput | LibraryEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LibraryEntry"> | number
    refNo?: StringWithAggregatesFilter<"LibraryEntry"> | string
    category?: StringWithAggregatesFilter<"LibraryEntry"> | string
    title?: StringWithAggregatesFilter<"LibraryEntry"> | string
    author?: StringNullableWithAggregatesFilter<"LibraryEntry"> | string | null
    pubYear?: IntNullableWithAggregatesFilter<"LibraryEntry"> | number | null
    creationDate?: DateTimeWithAggregatesFilter<"LibraryEntry"> | Date | string
    borrower?: StringNullableWithAggregatesFilter<"LibraryEntry"> | string | null
    loanDate?: DateTimeNullableWithAggregatesFilter<"LibraryEntry"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"LibraryEntry"> | string | null
    attachmentUrl?: StringNullableWithAggregatesFilter<"LibraryEntry"> | string | null
    attachmentFilename?: StringNullableWithAggregatesFilter<"LibraryEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LibraryEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryEntry"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    isRead?: BoolFilter<"Feedback"> | boolean
    senderId?: IntFilter<"Feedback"> | number
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipients?: FeedbackRecipientListRelationFilter
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    sender?: UserOrderByWithRelationInput
    recipients?: FeedbackRecipientOrderByRelationAggregateInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    isRead?: BoolFilter<"Feedback"> | boolean
    senderId?: IntFilter<"Feedback"> | number
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipients?: FeedbackRecipientListRelationFilter
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    subject?: StringWithAggregatesFilter<"Feedback"> | string
    message?: StringWithAggregatesFilter<"Feedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    isRead?: BoolWithAggregatesFilter<"Feedback"> | boolean
    senderId?: IntWithAggregatesFilter<"Feedback"> | number
  }

  export type FeedbackRecipientWhereInput = {
    AND?: FeedbackRecipientWhereInput | FeedbackRecipientWhereInput[]
    OR?: FeedbackRecipientWhereInput[]
    NOT?: FeedbackRecipientWhereInput | FeedbackRecipientWhereInput[]
    id?: IntFilter<"FeedbackRecipient"> | number
    feedbackId?: IntFilter<"FeedbackRecipient"> | number
    userId?: IntFilter<"FeedbackRecipient"> | number
    feedback?: XOR<FeedbackScalarRelationFilter, FeedbackWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackRecipientOrderByWithRelationInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
    feedback?: FeedbackOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FeedbackRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    feedbackId_userId?: FeedbackRecipientFeedbackIdUserIdCompoundUniqueInput
    AND?: FeedbackRecipientWhereInput | FeedbackRecipientWhereInput[]
    OR?: FeedbackRecipientWhereInput[]
    NOT?: FeedbackRecipientWhereInput | FeedbackRecipientWhereInput[]
    feedbackId?: IntFilter<"FeedbackRecipient"> | number
    userId?: IntFilter<"FeedbackRecipient"> | number
    feedback?: XOR<FeedbackScalarRelationFilter, FeedbackWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "feedbackId_userId">

  export type FeedbackRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
    _count?: FeedbackRecipientCountOrderByAggregateInput
    _avg?: FeedbackRecipientAvgOrderByAggregateInput
    _max?: FeedbackRecipientMaxOrderByAggregateInput
    _min?: FeedbackRecipientMinOrderByAggregateInput
    _sum?: FeedbackRecipientSumOrderByAggregateInput
  }

  export type FeedbackRecipientScalarWhereWithAggregatesInput = {
    AND?: FeedbackRecipientScalarWhereWithAggregatesInput | FeedbackRecipientScalarWhereWithAggregatesInput[]
    OR?: FeedbackRecipientScalarWhereWithAggregatesInput[]
    NOT?: FeedbackRecipientScalarWhereWithAggregatesInput | FeedbackRecipientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeedbackRecipient"> | number
    feedbackId?: IntWithAggregatesFilter<"FeedbackRecipient"> | number
    userId?: IntWithAggregatesFilter<"FeedbackRecipient"> | number
  }

  export type PagePermissionWhereInput = {
    AND?: PagePermissionWhereInput | PagePermissionWhereInput[]
    OR?: PagePermissionWhereInput[]
    NOT?: PagePermissionWhereInput | PagePermissionWhereInput[]
    id?: IntFilter<"PagePermission"> | number
    route?: StringFilter<"PagePermission"> | string
    description?: StringNullableFilter<"PagePermission"> | string | null
    createdAt?: DateTimeFilter<"PagePermission"> | Date | string
    allowedRoles?: RolePermissionListRelationFilter
    allowedUsers?: UserPermissionListRelationFilter
  }

  export type PagePermissionOrderByWithRelationInput = {
    id?: SortOrder
    route?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    allowedRoles?: RolePermissionOrderByRelationAggregateInput
    allowedUsers?: UserPermissionOrderByRelationAggregateInput
  }

  export type PagePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagePermissionWhereInput | PagePermissionWhereInput[]
    OR?: PagePermissionWhereInput[]
    NOT?: PagePermissionWhereInput | PagePermissionWhereInput[]
    route?: StringFilter<"PagePermission"> | string
    description?: StringNullableFilter<"PagePermission"> | string | null
    createdAt?: DateTimeFilter<"PagePermission"> | Date | string
    allowedRoles?: RolePermissionListRelationFilter
    allowedUsers?: UserPermissionListRelationFilter
  }, "id">

  export type PagePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    route?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PagePermissionCountOrderByAggregateInput
    _avg?: PagePermissionAvgOrderByAggregateInput
    _max?: PagePermissionMaxOrderByAggregateInput
    _min?: PagePermissionMinOrderByAggregateInput
    _sum?: PagePermissionSumOrderByAggregateInput
  }

  export type PagePermissionScalarWhereWithAggregatesInput = {
    AND?: PagePermissionScalarWhereWithAggregatesInput | PagePermissionScalarWhereWithAggregatesInput[]
    OR?: PagePermissionScalarWhereWithAggregatesInput[]
    NOT?: PagePermissionScalarWhereWithAggregatesInput | PagePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PagePermission"> | number
    route?: StringWithAggregatesFilter<"PagePermission"> | string
    description?: StringNullableWithAggregatesFilter<"PagePermission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PagePermission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleName?: StringFilter<"RolePermission"> | string
    pagePermissionId?: IntFilter<"RolePermission"> | number
    pagePermission?: XOR<PagePermissionScalarRelationFilter, PagePermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleName?: SortOrder
    pagePermissionId?: SortOrder
    pagePermission?: PagePermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleName_pagePermissionId?: RolePermissionRoleNamePagePermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleName?: StringFilter<"RolePermission"> | string
    pagePermissionId?: IntFilter<"RolePermission"> | number
    pagePermission?: XOR<PagePermissionScalarRelationFilter, PagePermissionWhereInput>
  }, "id" | "roleName_pagePermissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleName?: SortOrder
    pagePermissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleName?: StringWithAggregatesFilter<"RolePermission"> | string
    pagePermissionId?: IntWithAggregatesFilter<"RolePermission"> | number
  }

  export type UserPermissionWhereInput = {
    AND?: UserPermissionWhereInput | UserPermissionWhereInput[]
    OR?: UserPermissionWhereInput[]
    NOT?: UserPermissionWhereInput | UserPermissionWhereInput[]
    id?: IntFilter<"UserPermission"> | number
    userId?: IntFilter<"UserPermission"> | number
    pagePermissionId?: IntFilter<"UserPermission"> | number
    pagePermission?: XOR<PagePermissionScalarRelationFilter, PagePermissionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPermissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
    pagePermission?: PagePermissionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_pagePermissionId?: UserPermissionUserIdPagePermissionIdCompoundUniqueInput
    AND?: UserPermissionWhereInput | UserPermissionWhereInput[]
    OR?: UserPermissionWhereInput[]
    NOT?: UserPermissionWhereInput | UserPermissionWhereInput[]
    userId?: IntFilter<"UserPermission"> | number
    pagePermissionId?: IntFilter<"UserPermission"> | number
    pagePermission?: XOR<PagePermissionScalarRelationFilter, PagePermissionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_pagePermissionId">

  export type UserPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
    _count?: UserPermissionCountOrderByAggregateInput
    _avg?: UserPermissionAvgOrderByAggregateInput
    _max?: UserPermissionMaxOrderByAggregateInput
    _min?: UserPermissionMinOrderByAggregateInput
    _sum?: UserPermissionSumOrderByAggregateInput
  }

  export type UserPermissionScalarWhereWithAggregatesInput = {
    AND?: UserPermissionScalarWhereWithAggregatesInput | UserPermissionScalarWhereWithAggregatesInput[]
    OR?: UserPermissionScalarWhereWithAggregatesInput[]
    NOT?: UserPermissionScalarWhereWithAggregatesInput | UserPermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPermission"> | number
    userId?: IntWithAggregatesFilter<"UserPermission"> | number
    pagePermissionId?: IntWithAggregatesFilter<"UserPermission"> | number
  }

  export type pagesWhereInput = {
    AND?: pagesWhereInput | pagesWhereInput[]
    OR?: pagesWhereInput[]
    NOT?: pagesWhereInput | pagesWhereInput[]
    id?: IntFilter<"pages"> | number
    notes?: StringNullableFilter<"pages"> | string | null
  }

  export type pagesOrderByWithRelationInput = {
    id?: SortOrder
    notes?: SortOrderInput | SortOrder
  }

  export type pagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pagesWhereInput | pagesWhereInput[]
    OR?: pagesWhereInput[]
    NOT?: pagesWhereInput | pagesWhereInput[]
    notes?: StringNullableFilter<"pages"> | string | null
  }, "id">

  export type pagesOrderByWithAggregationInput = {
    id?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: pagesCountOrderByAggregateInput
    _avg?: pagesAvgOrderByAggregateInput
    _max?: pagesMaxOrderByAggregateInput
    _min?: pagesMinOrderByAggregateInput
    _sum?: pagesSumOrderByAggregateInput
  }

  export type pagesScalarWhereWithAggregatesInput = {
    AND?: pagesScalarWhereWithAggregatesInput | pagesScalarWhereWithAggregatesInput[]
    OR?: pagesScalarWhereWithAggregatesInput[]
    NOT?: pagesScalarWhereWithAggregatesInput | pagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pages"> | number
    notes?: StringNullableWithAggregatesFilter<"pages"> | string | null
  }

  export type ProjectTypeWhereInput = {
    AND?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    OR?: ProjectTypeWhereInput[]
    NOT?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    id?: IntFilter<"ProjectType"> | number
    name?: StringFilter<"ProjectType"> | string
    description?: StringNullableFilter<"ProjectType"> | string | null
    projects?: ProjectListRelationFilter
  }

  export type ProjectTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type ProjectTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    OR?: ProjectTypeWhereInput[]
    NOT?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    description?: StringNullableFilter<"ProjectType"> | string | null
    projects?: ProjectListRelationFilter
  }, "id" | "name">

  export type ProjectTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ProjectTypeCountOrderByAggregateInput
    _avg?: ProjectTypeAvgOrderByAggregateInput
    _max?: ProjectTypeMaxOrderByAggregateInput
    _min?: ProjectTypeMinOrderByAggregateInput
    _sum?: ProjectTypeSumOrderByAggregateInput
  }

  export type ProjectTypeScalarWhereWithAggregatesInput = {
    AND?: ProjectTypeScalarWhereWithAggregatesInput | ProjectTypeScalarWhereWithAggregatesInput[]
    OR?: ProjectTypeScalarWhereWithAggregatesInput[]
    NOT?: ProjectTypeScalarWhereWithAggregatesInput | ProjectTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectType"> | number
    name?: StringWithAggregatesFilter<"ProjectType"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectType"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    businessCode?: StringFilter<"Project"> | string
    projectCode?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    createDate?: DateTimeFilter<"Project"> | Date | string
    projectTypeId?: IntNullableFilter<"Project"> | number | null
    models?: ModelEntryListRelationFilter
    projectType?: XOR<ProjectTypeNullableScalarRelationFilter, ProjectTypeWhereInput> | null
    assignments?: ProjectAssignmentListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    businessCode?: SortOrder
    projectCode?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    projectTypeId?: SortOrderInput | SortOrder
    models?: ModelEntryOrderByRelationAggregateInput
    projectType?: ProjectTypeOrderByWithRelationInput
    assignments?: ProjectAssignmentOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    businessCode?: StringFilter<"Project"> | string
    projectCode?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    createDate?: DateTimeFilter<"Project"> | Date | string
    projectTypeId?: IntNullableFilter<"Project"> | number | null
    models?: ModelEntryListRelationFilter
    projectType?: XOR<ProjectTypeNullableScalarRelationFilter, ProjectTypeWhereInput> | null
    assignments?: ProjectAssignmentListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    businessCode?: SortOrder
    projectCode?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    projectTypeId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    businessCode?: StringWithAggregatesFilter<"Project"> | string
    projectCode?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    createDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    projectTypeId?: IntNullableWithAggregatesFilter<"Project"> | number | null
  }

  export type ModelEntryWhereInput = {
    AND?: ModelEntryWhereInput | ModelEntryWhereInput[]
    OR?: ModelEntryWhereInput[]
    NOT?: ModelEntryWhereInput | ModelEntryWhereInput[]
    id?: IntFilter<"ModelEntry"> | number
    code?: StringFilter<"ModelEntry"> | string
    description?: StringNullableFilter<"ModelEntry"> | string | null
    createDate?: DateTimeFilter<"ModelEntry"> | Date | string
    createBy?: StringFilter<"ModelEntry"> | string
    modifyDate?: DateTimeNullableFilter<"ModelEntry"> | Date | string | null
    modifyBy?: StringNullableFilter<"ModelEntry"> | string | null
    projectId?: IntFilter<"ModelEntry"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ModelEntryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createDate?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrderInput | SortOrder
    modifyBy?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ModelEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModelEntryWhereInput | ModelEntryWhereInput[]
    OR?: ModelEntryWhereInput[]
    NOT?: ModelEntryWhereInput | ModelEntryWhereInput[]
    code?: StringFilter<"ModelEntry"> | string
    description?: StringNullableFilter<"ModelEntry"> | string | null
    createDate?: DateTimeFilter<"ModelEntry"> | Date | string
    createBy?: StringFilter<"ModelEntry"> | string
    modifyDate?: DateTimeNullableFilter<"ModelEntry"> | Date | string | null
    modifyBy?: StringNullableFilter<"ModelEntry"> | string | null
    projectId?: IntFilter<"ModelEntry"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ModelEntryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createDate?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrderInput | SortOrder
    modifyBy?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: ModelEntryCountOrderByAggregateInput
    _avg?: ModelEntryAvgOrderByAggregateInput
    _max?: ModelEntryMaxOrderByAggregateInput
    _min?: ModelEntryMinOrderByAggregateInput
    _sum?: ModelEntrySumOrderByAggregateInput
  }

  export type ModelEntryScalarWhereWithAggregatesInput = {
    AND?: ModelEntryScalarWhereWithAggregatesInput | ModelEntryScalarWhereWithAggregatesInput[]
    OR?: ModelEntryScalarWhereWithAggregatesInput[]
    NOT?: ModelEntryScalarWhereWithAggregatesInput | ModelEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModelEntry"> | number
    code?: StringWithAggregatesFilter<"ModelEntry"> | string
    description?: StringNullableWithAggregatesFilter<"ModelEntry"> | string | null
    createDate?: DateTimeWithAggregatesFilter<"ModelEntry"> | Date | string
    createBy?: StringWithAggregatesFilter<"ModelEntry"> | string
    modifyDate?: DateTimeNullableWithAggregatesFilter<"ModelEntry"> | Date | string | null
    modifyBy?: StringNullableWithAggregatesFilter<"ModelEntry"> | string | null
    projectId?: IntWithAggregatesFilter<"ModelEntry"> | number
  }

  export type ProjectAssignmentWhereInput = {
    AND?: ProjectAssignmentWhereInput | ProjectAssignmentWhereInput[]
    OR?: ProjectAssignmentWhereInput[]
    NOT?: ProjectAssignmentWhereInput | ProjectAssignmentWhereInput[]
    id?: IntFilter<"ProjectAssignment"> | number
    userId?: IntFilter<"ProjectAssignment"> | number
    projectId?: IntFilter<"ProjectAssignment"> | number
    role?: StringFilter<"ProjectAssignment"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_projectId?: ProjectAssignmentUserIdProjectIdCompoundUniqueInput
    AND?: ProjectAssignmentWhereInput | ProjectAssignmentWhereInput[]
    OR?: ProjectAssignmentWhereInput[]
    NOT?: ProjectAssignmentWhereInput | ProjectAssignmentWhereInput[]
    userId?: IntFilter<"ProjectAssignment"> | number
    projectId?: IntFilter<"ProjectAssignment"> | number
    role?: StringFilter<"ProjectAssignment"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_projectId">

  export type ProjectAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    _count?: ProjectAssignmentCountOrderByAggregateInput
    _avg?: ProjectAssignmentAvgOrderByAggregateInput
    _max?: ProjectAssignmentMaxOrderByAggregateInput
    _min?: ProjectAssignmentMinOrderByAggregateInput
    _sum?: ProjectAssignmentSumOrderByAggregateInput
  }

  export type ProjectAssignmentScalarWhereWithAggregatesInput = {
    AND?: ProjectAssignmentScalarWhereWithAggregatesInput | ProjectAssignmentScalarWhereWithAggregatesInput[]
    OR?: ProjectAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ProjectAssignmentScalarWhereWithAggregatesInput | ProjectAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectAssignment"> | number
    userId?: IntWithAggregatesFilter<"ProjectAssignment"> | number
    projectId?: IntWithAggregatesFilter<"ProjectAssignment"> | number
    role?: StringWithAggregatesFilter<"ProjectAssignment"> | string
  }

  export type SambaLogWhereInput = {
    AND?: SambaLogWhereInput | SambaLogWhereInput[]
    OR?: SambaLogWhereInput[]
    NOT?: SambaLogWhereInput | SambaLogWhereInput[]
    id?: IntFilter<"SambaLog"> | number
    timestamp?: DateTimeFilter<"SambaLog"> | Date | string
    component?: StringFilter<"SambaLog"> | string
    level?: StringFilter<"SambaLog"> | string
    message?: StringFilter<"SambaLog"> | string
    zone?: StringNullableFilter<"SambaLog"> | string | null
    name?: StringNullableFilter<"SambaLog"> | string | null
    errorCode?: IntNullableFilter<"SambaLog"> | number | null
    errorName?: StringNullableFilter<"SambaLog"> | string | null
    hostname?: StringNullableFilter<"SambaLog"> | string | null
    createdAt?: DateTimeFilter<"SambaLog"> | Date | string
  }

  export type SambaLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    component?: SortOrder
    level?: SortOrder
    message?: SortOrder
    zone?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorName?: SortOrderInput | SortOrder
    hostname?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SambaLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SambaLogWhereInput | SambaLogWhereInput[]
    OR?: SambaLogWhereInput[]
    NOT?: SambaLogWhereInput | SambaLogWhereInput[]
    timestamp?: DateTimeFilter<"SambaLog"> | Date | string
    component?: StringFilter<"SambaLog"> | string
    level?: StringFilter<"SambaLog"> | string
    message?: StringFilter<"SambaLog"> | string
    zone?: StringNullableFilter<"SambaLog"> | string | null
    name?: StringNullableFilter<"SambaLog"> | string | null
    errorCode?: IntNullableFilter<"SambaLog"> | number | null
    errorName?: StringNullableFilter<"SambaLog"> | string | null
    hostname?: StringNullableFilter<"SambaLog"> | string | null
    createdAt?: DateTimeFilter<"SambaLog"> | Date | string
  }, "id">

  export type SambaLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    component?: SortOrder
    level?: SortOrder
    message?: SortOrder
    zone?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorName?: SortOrderInput | SortOrder
    hostname?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SambaLogCountOrderByAggregateInput
    _avg?: SambaLogAvgOrderByAggregateInput
    _max?: SambaLogMaxOrderByAggregateInput
    _min?: SambaLogMinOrderByAggregateInput
    _sum?: SambaLogSumOrderByAggregateInput
  }

  export type SambaLogScalarWhereWithAggregatesInput = {
    AND?: SambaLogScalarWhereWithAggregatesInput | SambaLogScalarWhereWithAggregatesInput[]
    OR?: SambaLogScalarWhereWithAggregatesInput[]
    NOT?: SambaLogScalarWhereWithAggregatesInput | SambaLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SambaLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"SambaLog"> | Date | string
    component?: StringWithAggregatesFilter<"SambaLog"> | string
    level?: StringWithAggregatesFilter<"SambaLog"> | string
    message?: StringWithAggregatesFilter<"SambaLog"> | string
    zone?: StringNullableWithAggregatesFilter<"SambaLog"> | string | null
    name?: StringNullableWithAggregatesFilter<"SambaLog"> | string | null
    errorCode?: IntNullableWithAggregatesFilter<"SambaLog"> | number | null
    errorName?: StringNullableWithAggregatesFilter<"SambaLog"> | string | null
    hostname?: StringNullableWithAggregatesFilter<"SambaLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SambaLog"> | Date | string
  }

  export type locationWhereInput = {
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    id?: IntFilter<"location"> | number
    code?: StringFilter<"location"> | string
    name?: StringFilter<"location"> | string
    modifyBy?: StringNullableFilter<"location"> | string | null
    createBy?: StringFilter<"location"> | string
    modifyDate?: DateTimeFilter<"location"> | Date | string
    CCY?: StringNullableFilter<"location"> | string | null
    Region?: StringNullableFilter<"location"> | string | null
    Remarks?: StringNullableFilter<"location"> | string | null
    WCI_URL?: StringNullableFilter<"location"> | string | null
    createDate?: DateTimeFilter<"location"> | Date | string
    fullname?: StringNullableFilter<"location"> | string | null
    TeamLocation?: TeamLocationListRelationFilter
  }

  export type locationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    modifyBy?: SortOrderInput | SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    CCY?: SortOrderInput | SortOrder
    Region?: SortOrderInput | SortOrder
    Remarks?: SortOrderInput | SortOrder
    WCI_URL?: SortOrderInput | SortOrder
    createDate?: SortOrder
    fullname?: SortOrderInput | SortOrder
    TeamLocation?: TeamLocationOrderByRelationAggregateInput
  }

  export type locationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    code?: StringFilter<"location"> | string
    name?: StringFilter<"location"> | string
    modifyBy?: StringNullableFilter<"location"> | string | null
    createBy?: StringFilter<"location"> | string
    modifyDate?: DateTimeFilter<"location"> | Date | string
    CCY?: StringNullableFilter<"location"> | string | null
    Region?: StringNullableFilter<"location"> | string | null
    Remarks?: StringNullableFilter<"location"> | string | null
    WCI_URL?: StringNullableFilter<"location"> | string | null
    createDate?: DateTimeFilter<"location"> | Date | string
    fullname?: StringNullableFilter<"location"> | string | null
    TeamLocation?: TeamLocationListRelationFilter
  }, "id">

  export type locationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    modifyBy?: SortOrderInput | SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    CCY?: SortOrderInput | SortOrder
    Region?: SortOrderInput | SortOrder
    Remarks?: SortOrderInput | SortOrder
    WCI_URL?: SortOrderInput | SortOrder
    createDate?: SortOrder
    fullname?: SortOrderInput | SortOrder
    _count?: locationCountOrderByAggregateInput
    _avg?: locationAvgOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
    _sum?: locationSumOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    OR?: locationScalarWhereWithAggregatesInput[]
    NOT?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"location"> | number
    code?: StringWithAggregatesFilter<"location"> | string
    name?: StringWithAggregatesFilter<"location"> | string
    modifyBy?: StringNullableWithAggregatesFilter<"location"> | string | null
    createBy?: StringWithAggregatesFilter<"location"> | string
    modifyDate?: DateTimeWithAggregatesFilter<"location"> | Date | string
    CCY?: StringNullableWithAggregatesFilter<"location"> | string | null
    Region?: StringNullableWithAggregatesFilter<"location"> | string | null
    Remarks?: StringNullableWithAggregatesFilter<"location"> | string | null
    WCI_URL?: StringNullableWithAggregatesFilter<"location"> | string | null
    createDate?: DateTimeWithAggregatesFilter<"location"> | Date | string
    fullname?: StringNullableWithAggregatesFilter<"location"> | string | null
  }

  export type ldapuserWhereInput = {
    AND?: ldapuserWhereInput | ldapuserWhereInput[]
    OR?: ldapuserWhereInput[]
    NOT?: ldapuserWhereInput | ldapuserWhereInput[]
    dn?: StringFilter<"ldapuser"> | string
    objectClass?: StringNullableListFilter<"ldapuser">
    cn?: StringFilter<"ldapuser"> | string
    sn?: StringNullableFilter<"ldapuser"> | string | null
    givenName?: StringNullableFilter<"ldapuser"> | string | null
    instanceType?: IntFilter<"ldapuser"> | number
    whenCreated?: BigIntFilter<"ldapuser"> | bigint | number
    displayName?: StringNullableFilter<"ldapuser"> | string | null
    uSNCreated?: IntFilter<"ldapuser"> | number
    name?: StringFilter<"ldapuser"> | string
    objectGUID?: StringFilter<"ldapuser"> | string
    badPwdCount?: IntNullableFilter<"ldapuser"> | number | null
    codePage?: IntFilter<"ldapuser"> | number
    countryCode?: IntFilter<"ldapuser"> | number
    badPasswordTime?: BigIntNullableFilter<"ldapuser"> | bigint | number | null
    lastLogoff?: BigIntNullableFilter<"ldapuser"> | bigint | number | null
    lastLogon?: BigIntNullableFilter<"ldapuser"> | bigint | number | null
    primaryGroupID?: IntFilter<"ldapuser"> | number
    objectSid?: StringFilter<"ldapuser"> | string
    accountExpires?: BigIntFilter<"ldapuser"> | bigint | number
    logonCount?: IntNullableFilter<"ldapuser"> | number | null
    sAMAccountName?: StringFilter<"ldapuser"> | string
    sAMAccountType?: IntFilter<"ldapuser"> | number
    userPrincipalName?: StringNullableFilter<"ldapuser"> | string | null
    objectCategory?: StringFilter<"ldapuser"> | string
    pwdLastSet?: BigIntFilter<"ldapuser"> | bigint | number
    userAccountControl?: IntFilter<"ldapuser"> | number
    whenChanged?: BigIntFilter<"ldapuser"> | bigint | number
    uSNChanged?: IntFilter<"ldapuser"> | number
    distinguishedName?: StringFilter<"ldapuser"> | string
    createdAt?: DateTimeFilter<"ldapuser"> | Date | string
    updatedAt?: DateTimeFilter<"ldapuser"> | Date | string
    adminCount?: IntNullableFilter<"ldapuser"> | number | null
    description?: StringNullableFilter<"ldapuser"> | string | null
    isCriticalSystemObject?: BoolNullableFilter<"ldapuser"> | boolean | null
    memberOf?: StringNullableFilter<"ldapuser"> | string | null
    servicePrincipalName?: StringNullableFilter<"ldapuser"> | string | null
    showInAdvancedViewOnly?: BoolNullableFilter<"ldapuser"> | boolean | null
    id?: IntFilter<"ldapuser"> | number
  }

  export type ldapuserOrderByWithRelationInput = {
    dn?: SortOrder
    objectClass?: SortOrder
    cn?: SortOrder
    sn?: SortOrderInput | SortOrder
    givenName?: SortOrderInput | SortOrder
    instanceType?: SortOrder
    whenCreated?: SortOrder
    displayName?: SortOrderInput | SortOrder
    uSNCreated?: SortOrder
    name?: SortOrder
    objectGUID?: SortOrder
    badPwdCount?: SortOrderInput | SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrderInput | SortOrder
    lastLogoff?: SortOrderInput | SortOrder
    lastLogon?: SortOrderInput | SortOrder
    primaryGroupID?: SortOrder
    objectSid?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrderInput | SortOrder
    sAMAccountName?: SortOrder
    sAMAccountType?: SortOrder
    userPrincipalName?: SortOrderInput | SortOrder
    objectCategory?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    distinguishedName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminCount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isCriticalSystemObject?: SortOrderInput | SortOrder
    memberOf?: SortOrderInput | SortOrder
    servicePrincipalName?: SortOrderInput | SortOrder
    showInAdvancedViewOnly?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type ldapuserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ldapuserWhereInput | ldapuserWhereInput[]
    OR?: ldapuserWhereInput[]
    NOT?: ldapuserWhereInput | ldapuserWhereInput[]
    dn?: StringFilter<"ldapuser"> | string
    objectClass?: StringNullableListFilter<"ldapuser">
    cn?: StringFilter<"ldapuser"> | string
    sn?: StringNullableFilter<"ldapuser"> | string | null
    givenName?: StringNullableFilter<"ldapuser"> | string | null
    instanceType?: IntFilter<"ldapuser"> | number
    whenCreated?: BigIntFilter<"ldapuser"> | bigint | number
    displayName?: StringNullableFilter<"ldapuser"> | string | null
    uSNCreated?: IntFilter<"ldapuser"> | number
    name?: StringFilter<"ldapuser"> | string
    objectGUID?: StringFilter<"ldapuser"> | string
    badPwdCount?: IntNullableFilter<"ldapuser"> | number | null
    codePage?: IntFilter<"ldapuser"> | number
    countryCode?: IntFilter<"ldapuser"> | number
    badPasswordTime?: BigIntNullableFilter<"ldapuser"> | bigint | number | null
    lastLogoff?: BigIntNullableFilter<"ldapuser"> | bigint | number | null
    lastLogon?: BigIntNullableFilter<"ldapuser"> | bigint | number | null
    primaryGroupID?: IntFilter<"ldapuser"> | number
    objectSid?: StringFilter<"ldapuser"> | string
    accountExpires?: BigIntFilter<"ldapuser"> | bigint | number
    logonCount?: IntNullableFilter<"ldapuser"> | number | null
    sAMAccountName?: StringFilter<"ldapuser"> | string
    sAMAccountType?: IntFilter<"ldapuser"> | number
    userPrincipalName?: StringNullableFilter<"ldapuser"> | string | null
    objectCategory?: StringFilter<"ldapuser"> | string
    pwdLastSet?: BigIntFilter<"ldapuser"> | bigint | number
    userAccountControl?: IntFilter<"ldapuser"> | number
    whenChanged?: BigIntFilter<"ldapuser"> | bigint | number
    uSNChanged?: IntFilter<"ldapuser"> | number
    distinguishedName?: StringFilter<"ldapuser"> | string
    createdAt?: DateTimeFilter<"ldapuser"> | Date | string
    updatedAt?: DateTimeFilter<"ldapuser"> | Date | string
    adminCount?: IntNullableFilter<"ldapuser"> | number | null
    description?: StringNullableFilter<"ldapuser"> | string | null
    isCriticalSystemObject?: BoolNullableFilter<"ldapuser"> | boolean | null
    memberOf?: StringNullableFilter<"ldapuser"> | string | null
    servicePrincipalName?: StringNullableFilter<"ldapuser"> | string | null
    showInAdvancedViewOnly?: BoolNullableFilter<"ldapuser"> | boolean | null
  }, "id">

  export type ldapuserOrderByWithAggregationInput = {
    dn?: SortOrder
    objectClass?: SortOrder
    cn?: SortOrder
    sn?: SortOrderInput | SortOrder
    givenName?: SortOrderInput | SortOrder
    instanceType?: SortOrder
    whenCreated?: SortOrder
    displayName?: SortOrderInput | SortOrder
    uSNCreated?: SortOrder
    name?: SortOrder
    objectGUID?: SortOrder
    badPwdCount?: SortOrderInput | SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrderInput | SortOrder
    lastLogoff?: SortOrderInput | SortOrder
    lastLogon?: SortOrderInput | SortOrder
    primaryGroupID?: SortOrder
    objectSid?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrderInput | SortOrder
    sAMAccountName?: SortOrder
    sAMAccountType?: SortOrder
    userPrincipalName?: SortOrderInput | SortOrder
    objectCategory?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    distinguishedName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminCount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isCriticalSystemObject?: SortOrderInput | SortOrder
    memberOf?: SortOrderInput | SortOrder
    servicePrincipalName?: SortOrderInput | SortOrder
    showInAdvancedViewOnly?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: ldapuserCountOrderByAggregateInput
    _avg?: ldapuserAvgOrderByAggregateInput
    _max?: ldapuserMaxOrderByAggregateInput
    _min?: ldapuserMinOrderByAggregateInput
    _sum?: ldapuserSumOrderByAggregateInput
  }

  export type ldapuserScalarWhereWithAggregatesInput = {
    AND?: ldapuserScalarWhereWithAggregatesInput | ldapuserScalarWhereWithAggregatesInput[]
    OR?: ldapuserScalarWhereWithAggregatesInput[]
    NOT?: ldapuserScalarWhereWithAggregatesInput | ldapuserScalarWhereWithAggregatesInput[]
    dn?: StringWithAggregatesFilter<"ldapuser"> | string
    objectClass?: StringNullableListFilter<"ldapuser">
    cn?: StringWithAggregatesFilter<"ldapuser"> | string
    sn?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    givenName?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    instanceType?: IntWithAggregatesFilter<"ldapuser"> | number
    whenCreated?: BigIntWithAggregatesFilter<"ldapuser"> | bigint | number
    displayName?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    uSNCreated?: IntWithAggregatesFilter<"ldapuser"> | number
    name?: StringWithAggregatesFilter<"ldapuser"> | string
    objectGUID?: StringWithAggregatesFilter<"ldapuser"> | string
    badPwdCount?: IntNullableWithAggregatesFilter<"ldapuser"> | number | null
    codePage?: IntWithAggregatesFilter<"ldapuser"> | number
    countryCode?: IntWithAggregatesFilter<"ldapuser"> | number
    badPasswordTime?: BigIntNullableWithAggregatesFilter<"ldapuser"> | bigint | number | null
    lastLogoff?: BigIntNullableWithAggregatesFilter<"ldapuser"> | bigint | number | null
    lastLogon?: BigIntNullableWithAggregatesFilter<"ldapuser"> | bigint | number | null
    primaryGroupID?: IntWithAggregatesFilter<"ldapuser"> | number
    objectSid?: StringWithAggregatesFilter<"ldapuser"> | string
    accountExpires?: BigIntWithAggregatesFilter<"ldapuser"> | bigint | number
    logonCount?: IntNullableWithAggregatesFilter<"ldapuser"> | number | null
    sAMAccountName?: StringWithAggregatesFilter<"ldapuser"> | string
    sAMAccountType?: IntWithAggregatesFilter<"ldapuser"> | number
    userPrincipalName?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    objectCategory?: StringWithAggregatesFilter<"ldapuser"> | string
    pwdLastSet?: BigIntWithAggregatesFilter<"ldapuser"> | bigint | number
    userAccountControl?: IntWithAggregatesFilter<"ldapuser"> | number
    whenChanged?: BigIntWithAggregatesFilter<"ldapuser"> | bigint | number
    uSNChanged?: IntWithAggregatesFilter<"ldapuser"> | number
    distinguishedName?: StringWithAggregatesFilter<"ldapuser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ldapuser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ldapuser"> | Date | string
    adminCount?: IntNullableWithAggregatesFilter<"ldapuser"> | number | null
    description?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    isCriticalSystemObject?: BoolNullableWithAggregatesFilter<"ldapuser"> | boolean | null
    memberOf?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    servicePrincipalName?: StringNullableWithAggregatesFilter<"ldapuser"> | string | null
    showInAdvancedViewOnly?: BoolNullableWithAggregatesFilter<"ldapuser"> | boolean | null
    id?: IntWithAggregatesFilter<"ldapuser"> | number
  }

  export type DriveFolderWhereInput = {
    AND?: DriveFolderWhereInput | DriveFolderWhereInput[]
    OR?: DriveFolderWhereInput[]
    NOT?: DriveFolderWhereInput | DriveFolderWhereInput[]
    id?: IntFilter<"DriveFolder"> | number
    name?: StringFilter<"DriveFolder"> | string
    parentId?: IntNullableFilter<"DriveFolder"> | number | null
    ownerId?: IntFilter<"DriveFolder"> | number
    createdAt?: DateTimeFilter<"DriveFolder"> | Date | string
    updatedAt?: DateTimeFilter<"DriveFolder"> | Date | string
    files?: DriveFileListRelationFilter
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<DriveFolderNullableScalarRelationFilter, DriveFolderWhereInput> | null
    children?: DriveFolderListRelationFilter
  }

  export type DriveFolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    files?: DriveFileOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    parent?: DriveFolderOrderByWithRelationInput
    children?: DriveFolderOrderByRelationAggregateInput
  }

  export type DriveFolderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DriveFolderWhereInput | DriveFolderWhereInput[]
    OR?: DriveFolderWhereInput[]
    NOT?: DriveFolderWhereInput | DriveFolderWhereInput[]
    name?: StringFilter<"DriveFolder"> | string
    parentId?: IntNullableFilter<"DriveFolder"> | number | null
    ownerId?: IntFilter<"DriveFolder"> | number
    createdAt?: DateTimeFilter<"DriveFolder"> | Date | string
    updatedAt?: DateTimeFilter<"DriveFolder"> | Date | string
    files?: DriveFileListRelationFilter
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<DriveFolderNullableScalarRelationFilter, DriveFolderWhereInput> | null
    children?: DriveFolderListRelationFilter
  }, "id">

  export type DriveFolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriveFolderCountOrderByAggregateInput
    _avg?: DriveFolderAvgOrderByAggregateInput
    _max?: DriveFolderMaxOrderByAggregateInput
    _min?: DriveFolderMinOrderByAggregateInput
    _sum?: DriveFolderSumOrderByAggregateInput
  }

  export type DriveFolderScalarWhereWithAggregatesInput = {
    AND?: DriveFolderScalarWhereWithAggregatesInput | DriveFolderScalarWhereWithAggregatesInput[]
    OR?: DriveFolderScalarWhereWithAggregatesInput[]
    NOT?: DriveFolderScalarWhereWithAggregatesInput | DriveFolderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DriveFolder"> | number
    name?: StringWithAggregatesFilter<"DriveFolder"> | string
    parentId?: IntNullableWithAggregatesFilter<"DriveFolder"> | number | null
    ownerId?: IntWithAggregatesFilter<"DriveFolder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DriveFolder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DriveFolder"> | Date | string
  }

  export type DriveFileWhereInput = {
    AND?: DriveFileWhereInput | DriveFileWhereInput[]
    OR?: DriveFileWhereInput[]
    NOT?: DriveFileWhereInput | DriveFileWhereInput[]
    id?: IntFilter<"DriveFile"> | number
    name?: StringFilter<"DriveFile"> | string
    type?: StringFilter<"DriveFile"> | string
    size?: IntFilter<"DriveFile"> | number
    order?: IntFilter<"DriveFile"> | number
    folderId?: IntNullableFilter<"DriveFile"> | number | null
    ownerId?: IntFilter<"DriveFile"> | number
    url?: StringFilter<"DriveFile"> | string
    createdAt?: DateTimeFilter<"DriveFile"> | Date | string
    updatedAt?: DateTimeFilter<"DriveFile"> | Date | string
    folder?: XOR<DriveFolderNullableScalarRelationFilter, DriveFolderWhereInput> | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    permissions?: DriveFilePermissionListRelationFilter
  }

  export type DriveFileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folder?: DriveFolderOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    permissions?: DriveFilePermissionOrderByRelationAggregateInput
  }

  export type DriveFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DriveFileWhereInput | DriveFileWhereInput[]
    OR?: DriveFileWhereInput[]
    NOT?: DriveFileWhereInput | DriveFileWhereInput[]
    name?: StringFilter<"DriveFile"> | string
    type?: StringFilter<"DriveFile"> | string
    size?: IntFilter<"DriveFile"> | number
    order?: IntFilter<"DriveFile"> | number
    folderId?: IntNullableFilter<"DriveFile"> | number | null
    ownerId?: IntFilter<"DriveFile"> | number
    url?: StringFilter<"DriveFile"> | string
    createdAt?: DateTimeFilter<"DriveFile"> | Date | string
    updatedAt?: DateTimeFilter<"DriveFile"> | Date | string
    folder?: XOR<DriveFolderNullableScalarRelationFilter, DriveFolderWhereInput> | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    permissions?: DriveFilePermissionListRelationFilter
  }, "id">

  export type DriveFileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriveFileCountOrderByAggregateInput
    _avg?: DriveFileAvgOrderByAggregateInput
    _max?: DriveFileMaxOrderByAggregateInput
    _min?: DriveFileMinOrderByAggregateInput
    _sum?: DriveFileSumOrderByAggregateInput
  }

  export type DriveFileScalarWhereWithAggregatesInput = {
    AND?: DriveFileScalarWhereWithAggregatesInput | DriveFileScalarWhereWithAggregatesInput[]
    OR?: DriveFileScalarWhereWithAggregatesInput[]
    NOT?: DriveFileScalarWhereWithAggregatesInput | DriveFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DriveFile"> | number
    name?: StringWithAggregatesFilter<"DriveFile"> | string
    type?: StringWithAggregatesFilter<"DriveFile"> | string
    size?: IntWithAggregatesFilter<"DriveFile"> | number
    order?: IntWithAggregatesFilter<"DriveFile"> | number
    folderId?: IntNullableWithAggregatesFilter<"DriveFile"> | number | null
    ownerId?: IntWithAggregatesFilter<"DriveFile"> | number
    url?: StringWithAggregatesFilter<"DriveFile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DriveFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DriveFile"> | Date | string
  }

  export type DriveFilePermissionWhereInput = {
    AND?: DriveFilePermissionWhereInput | DriveFilePermissionWhereInput[]
    OR?: DriveFilePermissionWhereInput[]
    NOT?: DriveFilePermissionWhereInput | DriveFilePermissionWhereInput[]
    id?: IntFilter<"DriveFilePermission"> | number
    fileId?: IntFilter<"DriveFilePermission"> | number
    userId?: IntFilter<"DriveFilePermission"> | number
    access?: StringFilter<"DriveFilePermission"> | string
    grantedBy?: IntFilter<"DriveFilePermission"> | number
    grantedAt?: DateTimeFilter<"DriveFilePermission"> | Date | string
    file?: XOR<DriveFileScalarRelationFilter, DriveFileWhereInput>
    granter?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    User?: UserListRelationFilter
  }

  export type DriveFilePermissionOrderByWithRelationInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    file?: DriveFileOrderByWithRelationInput
    granter?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
  }

  export type DriveFilePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fileId_userId?: DriveFilePermissionFileIdUserIdCompoundUniqueInput
    AND?: DriveFilePermissionWhereInput | DriveFilePermissionWhereInput[]
    OR?: DriveFilePermissionWhereInput[]
    NOT?: DriveFilePermissionWhereInput | DriveFilePermissionWhereInput[]
    fileId?: IntFilter<"DriveFilePermission"> | number
    userId?: IntFilter<"DriveFilePermission"> | number
    access?: StringFilter<"DriveFilePermission"> | string
    grantedBy?: IntFilter<"DriveFilePermission"> | number
    grantedAt?: DateTimeFilter<"DriveFilePermission"> | Date | string
    file?: XOR<DriveFileScalarRelationFilter, DriveFileWhereInput>
    granter?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    User?: UserListRelationFilter
  }, "id" | "fileId_userId">

  export type DriveFilePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    _count?: DriveFilePermissionCountOrderByAggregateInput
    _avg?: DriveFilePermissionAvgOrderByAggregateInput
    _max?: DriveFilePermissionMaxOrderByAggregateInput
    _min?: DriveFilePermissionMinOrderByAggregateInput
    _sum?: DriveFilePermissionSumOrderByAggregateInput
  }

  export type DriveFilePermissionScalarWhereWithAggregatesInput = {
    AND?: DriveFilePermissionScalarWhereWithAggregatesInput | DriveFilePermissionScalarWhereWithAggregatesInput[]
    OR?: DriveFilePermissionScalarWhereWithAggregatesInput[]
    NOT?: DriveFilePermissionScalarWhereWithAggregatesInput | DriveFilePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DriveFilePermission"> | number
    fileId?: IntWithAggregatesFilter<"DriveFilePermission"> | number
    userId?: IntWithAggregatesFilter<"DriveFilePermission"> | number
    access?: StringWithAggregatesFilter<"DriveFilePermission"> | string
    grantedBy?: IntWithAggregatesFilter<"DriveFilePermission"> | number
    grantedAt?: DateTimeWithAggregatesFilter<"DriveFilePermission"> | Date | string
  }

  export type JobTitleWhereInput = {
    AND?: JobTitleWhereInput | JobTitleWhereInput[]
    OR?: JobTitleWhereInput[]
    NOT?: JobTitleWhereInput | JobTitleWhereInput[]
    id?: IntFilter<"JobTitle"> | number
    sn?: StringFilter<"JobTitle"> | string
    jobTitle?: StringFilter<"JobTitle"> | string
    abbreviation?: StringFilter<"JobTitle"> | string
    grade?: StringFilter<"JobTitle"> | string
    seniorityLevel?: StringFilter<"JobTitle"> | string
    selectableInStaffCV?: StringFilter<"JobTitle"> | string
    createdAt?: DateTimeFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeFilter<"JobTitle"> | Date | string
  }

  export type JobTitleOrderByWithRelationInput = {
    id?: SortOrder
    sn?: SortOrder
    jobTitle?: SortOrder
    abbreviation?: SortOrder
    grade?: SortOrder
    seniorityLevel?: SortOrder
    selectableInStaffCV?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobTitleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobTitleWhereInput | JobTitleWhereInput[]
    OR?: JobTitleWhereInput[]
    NOT?: JobTitleWhereInput | JobTitleWhereInput[]
    sn?: StringFilter<"JobTitle"> | string
    jobTitle?: StringFilter<"JobTitle"> | string
    abbreviation?: StringFilter<"JobTitle"> | string
    grade?: StringFilter<"JobTitle"> | string
    seniorityLevel?: StringFilter<"JobTitle"> | string
    selectableInStaffCV?: StringFilter<"JobTitle"> | string
    createdAt?: DateTimeFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeFilter<"JobTitle"> | Date | string
  }, "id">

  export type JobTitleOrderByWithAggregationInput = {
    id?: SortOrder
    sn?: SortOrder
    jobTitle?: SortOrder
    abbreviation?: SortOrder
    grade?: SortOrder
    seniorityLevel?: SortOrder
    selectableInStaffCV?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobTitleCountOrderByAggregateInput
    _avg?: JobTitleAvgOrderByAggregateInput
    _max?: JobTitleMaxOrderByAggregateInput
    _min?: JobTitleMinOrderByAggregateInput
    _sum?: JobTitleSumOrderByAggregateInput
  }

  export type JobTitleScalarWhereWithAggregatesInput = {
    AND?: JobTitleScalarWhereWithAggregatesInput | JobTitleScalarWhereWithAggregatesInput[]
    OR?: JobTitleScalarWhereWithAggregatesInput[]
    NOT?: JobTitleScalarWhereWithAggregatesInput | JobTitleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobTitle"> | number
    sn?: StringWithAggregatesFilter<"JobTitle"> | string
    jobTitle?: StringWithAggregatesFilter<"JobTitle"> | string
    abbreviation?: StringWithAggregatesFilter<"JobTitle"> | string
    grade?: StringWithAggregatesFilter<"JobTitle"> | string
    seniorityLevel?: StringWithAggregatesFilter<"JobTitle"> | string
    selectableInStaffCV?: StringWithAggregatesFilter<"JobTitle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobTitle"> | Date | string
  }

  export type UserActivityWhereInput = {
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    id?: IntFilter<"UserActivity"> | number
    userId?: IntFilter<"UserActivity"> | number
    username?: StringFilter<"UserActivity"> | string
    page?: StringFilter<"UserActivity"> | string
    loginTime?: DateTimeFilter<"UserActivity"> | Date | string
  }

  export type UserActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    page?: SortOrder
    loginTime?: SortOrder
  }

  export type UserActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    userId?: IntFilter<"UserActivity"> | number
    username?: StringFilter<"UserActivity"> | string
    page?: StringFilter<"UserActivity"> | string
    loginTime?: DateTimeFilter<"UserActivity"> | Date | string
  }, "id">

  export type UserActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    page?: SortOrder
    loginTime?: SortOrder
    _count?: UserActivityCountOrderByAggregateInput
    _avg?: UserActivityAvgOrderByAggregateInput
    _max?: UserActivityMaxOrderByAggregateInput
    _min?: UserActivityMinOrderByAggregateInput
    _sum?: UserActivitySumOrderByAggregateInput
  }

  export type UserActivityScalarWhereWithAggregatesInput = {
    AND?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    OR?: UserActivityScalarWhereWithAggregatesInput[]
    NOT?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserActivity"> | number
    userId?: IntWithAggregatesFilter<"UserActivity"> | number
    username?: StringWithAggregatesFilter<"UserActivity"> | string
    page?: StringWithAggregatesFilter<"UserActivity"> | string
    loginTime?: DateTimeWithAggregatesFilter<"UserActivity"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    sequence?: IntFilter<"Team"> | number
    remarks?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    leaders?: TeamLeaderListRelationFilter
    locations?: TeamLocationListRelationFilter
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    sequence?: SortOrder
    remarks?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leaders?: TeamLeaderOrderByRelationAggregateInput
    locations?: TeamLocationOrderByRelationAggregateInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    sequence?: IntFilter<"Team"> | number
    remarks?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    leaders?: TeamLeaderListRelationFilter
    locations?: TeamLocationListRelationFilter
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    sequence?: SortOrder
    remarks?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    sequence?: IntWithAggregatesFilter<"Team"> | number
    remarks?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamLeaderWhereInput = {
    AND?: TeamLeaderWhereInput | TeamLeaderWhereInput[]
    OR?: TeamLeaderWhereInput[]
    NOT?: TeamLeaderWhereInput | TeamLeaderWhereInput[]
    id?: IntFilter<"TeamLeader"> | number
    teamId?: IntFilter<"TeamLeader"> | number
    userId?: IntFilter<"TeamLeader"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamLeaderOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamLeaderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_userId?: TeamLeaderTeamIdUserIdCompoundUniqueInput
    AND?: TeamLeaderWhereInput | TeamLeaderWhereInput[]
    OR?: TeamLeaderWhereInput[]
    NOT?: TeamLeaderWhereInput | TeamLeaderWhereInput[]
    teamId?: IntFilter<"TeamLeader"> | number
    userId?: IntFilter<"TeamLeader"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamLeaderOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    _count?: TeamLeaderCountOrderByAggregateInput
    _avg?: TeamLeaderAvgOrderByAggregateInput
    _max?: TeamLeaderMaxOrderByAggregateInput
    _min?: TeamLeaderMinOrderByAggregateInput
    _sum?: TeamLeaderSumOrderByAggregateInput
  }

  export type TeamLeaderScalarWhereWithAggregatesInput = {
    AND?: TeamLeaderScalarWhereWithAggregatesInput | TeamLeaderScalarWhereWithAggregatesInput[]
    OR?: TeamLeaderScalarWhereWithAggregatesInput[]
    NOT?: TeamLeaderScalarWhereWithAggregatesInput | TeamLeaderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamLeader"> | number
    teamId?: IntWithAggregatesFilter<"TeamLeader"> | number
    userId?: IntWithAggregatesFilter<"TeamLeader"> | number
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamMember"> | number
    teamId?: IntWithAggregatesFilter<"TeamMember"> | number
    userId?: IntWithAggregatesFilter<"TeamMember"> | number
  }

  export type TeamLocationWhereInput = {
    AND?: TeamLocationWhereInput | TeamLocationWhereInput[]
    OR?: TeamLocationWhereInput[]
    NOT?: TeamLocationWhereInput | TeamLocationWhereInput[]
    id?: IntFilter<"TeamLocation"> | number
    teamId?: IntFilter<"TeamLocation"> | number
    locationId?: IntFilter<"TeamLocation"> | number
    location?: XOR<LocationScalarRelationFilter, locationWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type TeamLocationOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
    location?: locationOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type TeamLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_locationId?: TeamLocationTeamIdLocationIdCompoundUniqueInput
    AND?: TeamLocationWhereInput | TeamLocationWhereInput[]
    OR?: TeamLocationWhereInput[]
    NOT?: TeamLocationWhereInput | TeamLocationWhereInput[]
    teamId?: IntFilter<"TeamLocation"> | number
    locationId?: IntFilter<"TeamLocation"> | number
    location?: XOR<LocationScalarRelationFilter, locationWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "teamId_locationId">

  export type TeamLocationOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
    _count?: TeamLocationCountOrderByAggregateInput
    _avg?: TeamLocationAvgOrderByAggregateInput
    _max?: TeamLocationMaxOrderByAggregateInput
    _min?: TeamLocationMinOrderByAggregateInput
    _sum?: TeamLocationSumOrderByAggregateInput
  }

  export type TeamLocationScalarWhereWithAggregatesInput = {
    AND?: TeamLocationScalarWhereWithAggregatesInput | TeamLocationScalarWhereWithAggregatesInput[]
    OR?: TeamLocationScalarWhereWithAggregatesInput[]
    NOT?: TeamLocationScalarWhereWithAggregatesInput | TeamLocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamLocation"> | number
    teamId?: IntWithAggregatesFilter<"TeamLocation"> | number
    locationId?: IntWithAggregatesFilter<"TeamLocation"> | number
  }

  export type AuditWorkflowWhereInput = {
    AND?: AuditWorkflowWhereInput | AuditWorkflowWhereInput[]
    OR?: AuditWorkflowWhereInput[]
    NOT?: AuditWorkflowWhereInput | AuditWorkflowWhereInput[]
    id?: IntFilter<"AuditWorkflow"> | number
    name?: StringFilter<"AuditWorkflow"> | string
    description?: StringNullableFilter<"AuditWorkflow"> | string | null
    createdAt?: DateTimeFilter<"AuditWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"AuditWorkflow"> | Date | string
    steps?: AuditStepListRelationFilter
  }

  export type AuditWorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    steps?: AuditStepOrderByRelationAggregateInput
  }

  export type AuditWorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditWorkflowWhereInput | AuditWorkflowWhereInput[]
    OR?: AuditWorkflowWhereInput[]
    NOT?: AuditWorkflowWhereInput | AuditWorkflowWhereInput[]
    name?: StringFilter<"AuditWorkflow"> | string
    description?: StringNullableFilter<"AuditWorkflow"> | string | null
    createdAt?: DateTimeFilter<"AuditWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"AuditWorkflow"> | Date | string
    steps?: AuditStepListRelationFilter
  }, "id">

  export type AuditWorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditWorkflowCountOrderByAggregateInput
    _avg?: AuditWorkflowAvgOrderByAggregateInput
    _max?: AuditWorkflowMaxOrderByAggregateInput
    _min?: AuditWorkflowMinOrderByAggregateInput
    _sum?: AuditWorkflowSumOrderByAggregateInput
  }

  export type AuditWorkflowScalarWhereWithAggregatesInput = {
    AND?: AuditWorkflowScalarWhereWithAggregatesInput | AuditWorkflowScalarWhereWithAggregatesInput[]
    OR?: AuditWorkflowScalarWhereWithAggregatesInput[]
    NOT?: AuditWorkflowScalarWhereWithAggregatesInput | AuditWorkflowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditWorkflow"> | number
    name?: StringWithAggregatesFilter<"AuditWorkflow"> | string
    description?: StringNullableWithAggregatesFilter<"AuditWorkflow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditWorkflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditWorkflow"> | Date | string
  }

  export type AuditStepWhereInput = {
    AND?: AuditStepWhereInput | AuditStepWhereInput[]
    OR?: AuditStepWhereInput[]
    NOT?: AuditStepWhereInput | AuditStepWhereInput[]
    id?: IntFilter<"AuditStep"> | number
    title?: StringFilter<"AuditStep"> | string
    description?: StringNullableFilter<"AuditStep"> | string | null
    position?: IntFilter<"AuditStep"> | number
    status?: EnumStepStatusFilter<"AuditStep"> | $Enums.StepStatus
    assignedToId?: IntNullableFilter<"AuditStep"> | number | null
    dueDate?: DateTimeNullableFilter<"AuditStep"> | Date | string | null
    workflowId?: IntFilter<"AuditStep"> | number
    workflow?: XOR<AuditWorkflowScalarRelationFilter, AuditWorkflowWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    logs?: StepLogListRelationFilter
  }

  export type AuditStepOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    workflowId?: SortOrder
    workflow?: AuditWorkflowOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    logs?: StepLogOrderByRelationAggregateInput
  }

  export type AuditStepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditStepWhereInput | AuditStepWhereInput[]
    OR?: AuditStepWhereInput[]
    NOT?: AuditStepWhereInput | AuditStepWhereInput[]
    title?: StringFilter<"AuditStep"> | string
    description?: StringNullableFilter<"AuditStep"> | string | null
    position?: IntFilter<"AuditStep"> | number
    status?: EnumStepStatusFilter<"AuditStep"> | $Enums.StepStatus
    assignedToId?: IntNullableFilter<"AuditStep"> | number | null
    dueDate?: DateTimeNullableFilter<"AuditStep"> | Date | string | null
    workflowId?: IntFilter<"AuditStep"> | number
    workflow?: XOR<AuditWorkflowScalarRelationFilter, AuditWorkflowWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    logs?: StepLogListRelationFilter
  }, "id">

  export type AuditStepOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    workflowId?: SortOrder
    _count?: AuditStepCountOrderByAggregateInput
    _avg?: AuditStepAvgOrderByAggregateInput
    _max?: AuditStepMaxOrderByAggregateInput
    _min?: AuditStepMinOrderByAggregateInput
    _sum?: AuditStepSumOrderByAggregateInput
  }

  export type AuditStepScalarWhereWithAggregatesInput = {
    AND?: AuditStepScalarWhereWithAggregatesInput | AuditStepScalarWhereWithAggregatesInput[]
    OR?: AuditStepScalarWhereWithAggregatesInput[]
    NOT?: AuditStepScalarWhereWithAggregatesInput | AuditStepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditStep"> | number
    title?: StringWithAggregatesFilter<"AuditStep"> | string
    description?: StringNullableWithAggregatesFilter<"AuditStep"> | string | null
    position?: IntWithAggregatesFilter<"AuditStep"> | number
    status?: EnumStepStatusWithAggregatesFilter<"AuditStep"> | $Enums.StepStatus
    assignedToId?: IntNullableWithAggregatesFilter<"AuditStep"> | number | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"AuditStep"> | Date | string | null
    workflowId?: IntWithAggregatesFilter<"AuditStep"> | number
  }

  export type StepLogWhereInput = {
    AND?: StepLogWhereInput | StepLogWhereInput[]
    OR?: StepLogWhereInput[]
    NOT?: StepLogWhereInput | StepLogWhereInput[]
    id?: IntFilter<"StepLog"> | number
    stepId?: IntFilter<"StepLog"> | number
    message?: StringFilter<"StepLog"> | string
    createdBy?: StringFilter<"StepLog"> | string
    createdAt?: DateTimeFilter<"StepLog"> | Date | string
    step?: XOR<AuditStepScalarRelationFilter, AuditStepWhereInput>
  }

  export type StepLogOrderByWithRelationInput = {
    id?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    step?: AuditStepOrderByWithRelationInput
  }

  export type StepLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StepLogWhereInput | StepLogWhereInput[]
    OR?: StepLogWhereInput[]
    NOT?: StepLogWhereInput | StepLogWhereInput[]
    stepId?: IntFilter<"StepLog"> | number
    message?: StringFilter<"StepLog"> | string
    createdBy?: StringFilter<"StepLog"> | string
    createdAt?: DateTimeFilter<"StepLog"> | Date | string
    step?: XOR<AuditStepScalarRelationFilter, AuditStepWhereInput>
  }, "id">

  export type StepLogOrderByWithAggregationInput = {
    id?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: StepLogCountOrderByAggregateInput
    _avg?: StepLogAvgOrderByAggregateInput
    _max?: StepLogMaxOrderByAggregateInput
    _min?: StepLogMinOrderByAggregateInput
    _sum?: StepLogSumOrderByAggregateInput
  }

  export type StepLogScalarWhereWithAggregatesInput = {
    AND?: StepLogScalarWhereWithAggregatesInput | StepLogScalarWhereWithAggregatesInput[]
    OR?: StepLogScalarWhereWithAggregatesInput[]
    NOT?: StepLogScalarWhereWithAggregatesInput | StepLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StepLog"> | number
    stepId?: IntWithAggregatesFilter<"StepLog"> | number
    message?: StringWithAggregatesFilter<"StepLog"> | string
    createdBy?: StringWithAggregatesFilter<"StepLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StepLog"> | Date | string
  }

  export type logsCreateInput = {
    name: string
    host?: string | null
    timestamp?: Date | string
    piuser?: string | null
    pid?: number | null
    action?: string | null
    cpu?: number | null
    mem?: number | null
    command?: string | null
    port?: number | null
    ipAddress?: string | null
  }

  export type logsUncheckedCreateInput = {
    id?: number
    name: string
    host?: string | null
    timestamp?: Date | string
    piuser?: string | null
    pid?: number | null
    action?: string | null
    cpu?: number | null
    mem?: number | null
    command?: string | null
    port?: number | null
    ipAddress?: string | null
  }

  export type logsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    piuser?: NullableStringFieldUpdateOperationsInput | string | null
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableFloatFieldUpdateOperationsInput | number | null
    command?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    piuser?: NullableStringFieldUpdateOperationsInput | string | null
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableFloatFieldUpdateOperationsInput | number | null
    command?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logsCreateManyInput = {
    id?: number
    name: string
    host?: string | null
    timestamp?: Date | string
    piuser?: string | null
    pid?: number | null
    action?: string | null
    cpu?: number | null
    mem?: number | null
    command?: string | null
    port?: number | null
    ipAddress?: string | null
  }

  export type logsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    piuser?: NullableStringFieldUpdateOperationsInput | string | null
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableFloatFieldUpdateOperationsInput | number | null
    command?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    piuser?: NullableStringFieldUpdateOperationsInput | string | null
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableFloatFieldUpdateOperationsInput | number | null
    command?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type authCreateInput = {
    timestamp?: Date | string
    username: string
    log_entry: string
  }

  export type authUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    username: string
    log_entry: string
  }

  export type authUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    log_entry?: StringFieldUpdateOperationsInput | string
  }

  export type authUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    log_entry?: StringFieldUpdateOperationsInput | string
  }

  export type authCreateManyInput = {
    id?: number
    timestamp?: Date | string
    username: string
    log_entry: string
  }

  export type authUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    log_entry?: StringFieldUpdateOperationsInput | string
  }

  export type authUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    log_entry?: StringFieldUpdateOperationsInput | string
  }

  export type memory_usageCreateInput = {
    total_memory: bigint | number
    used_memory: bigint | number
    free_memory: bigint | number
    available_memory: bigint | number
    percent_usage: number
    host?: string | null
    time?: Date | string
  }

  export type memory_usageUncheckedCreateInput = {
    id?: number
    total_memory: bigint | number
    used_memory: bigint | number
    free_memory: bigint | number
    available_memory: bigint | number
    percent_usage: number
    host?: string | null
    time?: Date | string
  }

  export type memory_usageUpdateInput = {
    total_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    used_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    free_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    available_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    percent_usage?: FloatFieldUpdateOperationsInput | number
    host?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memory_usageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    used_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    free_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    available_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    percent_usage?: FloatFieldUpdateOperationsInput | number
    host?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memory_usageCreateManyInput = {
    id?: number
    total_memory: bigint | number
    used_memory: bigint | number
    free_memory: bigint | number
    available_memory: bigint | number
    percent_usage: number
    host?: string | null
    time?: Date | string
  }

  export type memory_usageUpdateManyMutationInput = {
    total_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    used_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    free_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    available_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    percent_usage?: FloatFieldUpdateOperationsInput | number
    host?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memory_usageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    used_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    free_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    available_memory?: BigIntFieldUpdateOperationsInput | bigint | number
    percent_usage?: FloatFieldUpdateOperationsInput | number
    host?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_metricsCreateInput = {
    timestamp?: Date | string
    sensor_name: string
    value_type?: string
    value?: number
    host: string
    min?: string | null
    max?: string | null
  }

  export type system_metricsUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    sensor_name: string
    value_type?: string
    value?: number
    host: string
    min?: string | null
    max?: string | null
  }

  export type system_metricsUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sensor_name?: StringFieldUpdateOperationsInput | string
    value_type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    host?: StringFieldUpdateOperationsInput | string
    min?: NullableStringFieldUpdateOperationsInput | string | null
    max?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type system_metricsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sensor_name?: StringFieldUpdateOperationsInput | string
    value_type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    host?: StringFieldUpdateOperationsInput | string
    min?: NullableStringFieldUpdateOperationsInput | string | null
    max?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type system_metricsCreateManyInput = {
    id?: number
    timestamp?: Date | string
    sensor_name: string
    value_type?: string
    value?: number
    host: string
    min?: string | null
    max?: string | null
  }

  export type system_metricsUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sensor_name?: StringFieldUpdateOperationsInput | string
    value_type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    host?: StringFieldUpdateOperationsInput | string
    min?: NullableStringFieldUpdateOperationsInput | string | null
    max?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type system_metricsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sensor_name?: StringFieldUpdateOperationsInput | string
    value_type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    host?: StringFieldUpdateOperationsInput | string
    min?: NullableStringFieldUpdateOperationsInput | string | null
    max?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diskmetricCreateInput = {
    host: string
    name: string
    label?: string | null
    totalgb: number
    usedgb: number
    freegb: number
    timestamp?: Date | string
  }

  export type diskmetricUncheckedCreateInput = {
    id?: number
    host: string
    name: string
    label?: string | null
    totalgb: number
    usedgb: number
    freegb: number
    timestamp?: Date | string
  }

  export type diskmetricUpdateInput = {
    host?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    totalgb?: FloatFieldUpdateOperationsInput | number
    usedgb?: FloatFieldUpdateOperationsInput | number
    freegb?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diskmetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    host?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    totalgb?: FloatFieldUpdateOperationsInput | number
    usedgb?: FloatFieldUpdateOperationsInput | number
    freegb?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diskmetricCreateManyInput = {
    id?: number
    host: string
    name: string
    label?: string | null
    totalgb: number
    usedgb: number
    freegb: number
    timestamp?: Date | string
  }

  export type diskmetricUpdateManyMutationInput = {
    host?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    totalgb?: FloatFieldUpdateOperationsInput | number
    usedgb?: FloatFieldUpdateOperationsInput | number
    freegb?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diskmetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    host?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    totalgb?: FloatFieldUpdateOperationsInput | number
    usedgb?: FloatFieldUpdateOperationsInput | number
    freegb?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesCreateInput = {
    title: string
    time?: Date | string
    description: string
  }

  export type notesUncheckedCreateInput = {
    id?: number
    title: string
    time?: Date | string
    description: string
  }

  export type notesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type notesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type notesCreateManyInput = {
    id?: number
    title: string
    time?: Date | string
    description: string
  }

  export type notesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type notesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type devicesCreateInput = {
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
    users?: DeviceUserCreateNestedManyWithoutDeviceInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutRelatedDeviceInput
  }

  export type devicesUncheckedCreateInput = {
    id?: number
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
    users?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutRelatedDeviceInput
  }

  export type devicesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    users?: DeviceUserUpdateManyWithoutDeviceNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutRelatedDeviceNestedInput
  }

  export type devicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    users?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutRelatedDeviceNestedInput
  }

  export type devicesCreateManyInput = {
    id?: number
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
  }

  export type devicesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type devicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUserCreateInput = {
    role: string
    device: devicesCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUserUncheckedCreateInput = {
    id?: number
    userId: number
    deviceId: number
    role: string
  }

  export type DeviceUserUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    device?: devicesUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUserCreateManyInput = {
    id?: number
    userId: number
    deviceId: number
    role: string
  }

  export type DeviceUserUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CommandCreateInput = {
    command: string
    emailTemplate?: EmailTemplateCreateNestedOneWithoutCommandInput
    rule: RuleCreateNestedOneWithoutCommandsInput
    matches?: CommandMatchCreateNestedManyWithoutCommandInput
  }

  export type CommandUncheckedCreateInput = {
    id?: number
    ruleId: number
    command: string
    emailTemplateId?: number | null
    matches?: CommandMatchUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandUpdateInput = {
    command?: StringFieldUpdateOperationsInput | string
    emailTemplate?: EmailTemplateUpdateOneWithoutCommandNestedInput
    rule?: RuleUpdateOneRequiredWithoutCommandsNestedInput
    matches?: CommandMatchUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    matches?: CommandMatchUncheckedUpdateManyWithoutCommandNestedInput
  }

  export type CommandCreateManyInput = {
    id?: number
    ruleId: number
    command: string
    emailTemplateId?: number | null
  }

  export type CommandUpdateManyMutationInput = {
    command?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuleCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutRuleInput
    matches?: CommandMatchCreateNestedManyWithoutRuleInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutRuleInput
    group?: RuleGroupCreateNestedOneWithoutRulesInput
  }

  export type RuleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupId?: number | null
    emailTemplateId?: number | null
    commands?: CommandUncheckedCreateNestedManyWithoutRuleInput
    matches?: CommandMatchUncheckedCreateNestedManyWithoutRuleInput
  }

  export type RuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutRuleNestedInput
    matches?: CommandMatchUpdateManyWithoutRuleNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutRuleNestedInput
    group?: RuleGroupUpdateOneWithoutRulesNestedInput
  }

  export type RuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    commands?: CommandUncheckedUpdateManyWithoutRuleNestedInput
    matches?: CommandMatchUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type RuleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupId?: number | null
    emailTemplateId?: number | null
  }

  export type RuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuleGroupCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: RuleCreateNestedManyWithoutGroupInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutRuleGroupInput
  }

  export type RuleGroupUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: number | null
    rules?: RuleUncheckedCreateNestedManyWithoutGroupInput
  }

  export type RuleGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: RuleUpdateManyWithoutGroupNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutRuleGroupNestedInput
  }

  export type RuleGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    rules?: RuleUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type RuleGroupCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: number | null
  }

  export type RuleGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RuleGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommandMatchCreateInput = {
    logId: number
    logType: string
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    addressedByUser?: UserCreateNestedOneWithoutCommandMatchInput
    command: CommandCreateNestedOneWithoutMatchesInput
    rule: RuleCreateNestedOneWithoutMatchesInput
    User?: UserCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchUncheckedCreateInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    User?: UserUncheckedCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchUpdateInput = {
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    addressedByUser?: UserUpdateOneWithoutCommandMatchNestedInput
    command?: CommandUpdateOneRequiredWithoutMatchesNestedInput
    rule?: RuleUpdateOneRequiredWithoutMatchesNestedInput
    User?: UserUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchCreateManyInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
  }

  export type CommandMatchUpdateManyMutationInput = {
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandMatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogCreateInput = {
    actionType: string
    targetType: string
    targetId?: number | null
    details?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    userId: number
    actionType: string
    targetType: string
    targetId?: number | null
    details?: string | null
    timestamp?: Date | string
  }

  export type ActivityLogUpdateInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    userId: number
    actionType: string
    targetType: string
    targetId?: number | null
    details?: string | null
    timestamp?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandUncheckedCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleUncheckedCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
  }

  export type UserUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
  }

  export type GroupCreateInput = {
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMemberInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: number
    userId: number
    groupId: number
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMemberNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: number
    userId: number
    groupId: number
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    content: string
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
    group: GroupCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    content: string
    senderId: number
    groupId: number
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
  }

  export type MessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    group?: GroupUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyInput = {
    id?: number
    content: string
    senderId: number
    groupId: number
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserEmailTemplateCreateInput = {
    assignedAt?: Date | string
    emailTemplate: EmailTemplateCreateNestedOneWithoutAssignedUsersInput
    user: UserCreateNestedOneWithoutEmailTemplatesInput
  }

  export type UserEmailTemplateUncheckedCreateInput = {
    userId: number
    emailTemplateId: number
    assignedAt?: Date | string
  }

  export type UserEmailTemplateUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplate?: EmailTemplateUpdateOneRequiredWithoutAssignedUsersNestedInput
    user?: UserUpdateOneRequiredWithoutEmailTemplatesNestedInput
  }

  export type UserEmailTemplateUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    emailTemplateId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailTemplateCreateManyInput = {
    userId: number
    emailTemplateId: number
    assignedAt?: Date | string
  }

  export type UserEmailTemplateUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailTemplateUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    emailTemplateId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesCreateInput = {
    name: string
    description: string
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
  }

  export type RolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesCreateManyInput = {
    id?: number
    name: string
    description: string
  }

  export type RolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    title: string
    content: string
    postDate?: Date | string
    expiryDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    important?: boolean
    reads?: NotificationReadCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    postDate?: Date | string
    expiryDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    important?: boolean
    reads?: NotificationReadUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    important?: BoolFieldUpdateOperationsInput | boolean
    reads?: NotificationReadUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    important?: BoolFieldUpdateOperationsInput | boolean
    reads?: NotificationReadUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: number
    title: string
    content: string
    postDate?: Date | string
    expiryDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    important?: boolean
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationReadCreateInput = {
    readAt?: Date | string
    notification: NotificationCreateNestedOneWithoutReadsInput
    user: UserCreateNestedOneWithoutNotificationReadInput
  }

  export type NotificationReadUncheckedCreateInput = {
    id?: number
    notificationId: number
    userId: number
    readAt?: Date | string
  }

  export type NotificationReadUpdateInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutReadsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationReadNestedInput
  }

  export type NotificationReadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadCreateManyInput = {
    id?: number
    notificationId: number
    userId: number
    readAt?: Date | string
  }

  export type NotificationReadUpdateManyMutationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedQueryCreateInput = {
    name: string
    description?: string | null
    tableName: string
    columns?: SavedQueryCreatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplate?: EmailTemplateCreateNestedOneWithoutSavedQueryInput
  }

  export type SavedQueryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    tableName: string
    columns?: SavedQueryCreatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    emailTemplateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedQueryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplate?: EmailTemplateUpdateOneWithoutSavedQueryNestedInput
  }

  export type SavedQueryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedQueryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    tableName: string
    columns?: SavedQueryCreatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    emailTemplateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedQueryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedQueryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateInput = {
    content: string
    createdAt?: Date | string
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutCommentInput
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: number
    ticketId: number
    userId: number
    content: string
    createdAt?: Date | string
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type TicketCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TicketAttachment?: TicketAttachmentUpdateManyWithoutCommentNestedInput
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type TicketCommentCreateManyInput = {
    id?: number
    ticketId: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy: UserCreateNestedOneWithoutCreatedTicketsInput
    relatedDevice?: devicesCreateNestedOneWithoutSupportTicketInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    createdById: number
    relatedDeviceId?: number | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTicketsNestedInput
    relatedDevice?: devicesUpdateOneWithoutSupportTicketNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    createdById: number
    relatedDeviceId?: number | null
  }

  export type SupportTicketUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketAttachmentCreateInput = {
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    comment?: TicketCommentCreateNestedOneWithoutTicketAttachmentInput
    ticket?: SupportTicketCreateNestedOneWithoutAttachmentsInput
    uploader: UserCreateNestedOneWithoutTicketAttachmentInput
  }

  export type TicketAttachmentUncheckedCreateInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticketId?: number | null
    commentId?: number | null
    uploaderId: number
  }

  export type TicketAttachmentUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: TicketCommentUpdateOneWithoutTicketAttachmentNestedInput
    ticket?: SupportTicketUpdateOneWithoutAttachmentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutTicketAttachmentNestedInput
  }

  export type TicketAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    uploaderId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentCreateManyInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticketId?: number | null
    commentId?: number | null
    uploaderId: number
  }

  export type TicketAttachmentUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    uploaderId?: IntFieldUpdateOperationsInput | number
  }

  export type AlertConditionCreateInput = {
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    emailTemplate?: EmailTemplateCreateNestedOneWithoutAlertConditionInput
    triggeredAlerts?: AlertEventCreateNestedManyWithoutAlertConditionInput
  }

  export type AlertConditionUncheckedCreateInput = {
    id?: number
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    emailTemplateId?: number | null
    triggeredAlerts?: AlertEventUncheckedCreateNestedManyWithoutAlertConditionInput
  }

  export type AlertConditionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    emailTemplate?: EmailTemplateUpdateOneWithoutAlertConditionNestedInput
    triggeredAlerts?: AlertEventUpdateManyWithoutAlertConditionNestedInput
  }

  export type AlertConditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredAlerts?: AlertEventUncheckedUpdateManyWithoutAlertConditionNestedInput
  }

  export type AlertConditionCreateManyInput = {
    id?: number
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    emailTemplateId?: number | null
  }

  export type AlertConditionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertConditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertEventCreateInput = {
    triggeredAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    notes?: string | null
    alertCondition: AlertConditionCreateNestedOneWithoutTriggeredAlertsInput
  }

  export type AlertEventUncheckedCreateInput = {
    id?: number
    conditionId: number
    triggeredAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    notes?: string | null
  }

  export type AlertEventUpdateInput = {
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    alertCondition?: AlertConditionUpdateOneRequiredWithoutTriggeredAlertsNestedInput
  }

  export type AlertEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventCreateManyInput = {
    id?: number
    conditionId: number
    triggeredAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    notes?: string | null
  }

  export type AlertEventUpdateManyMutationInput = {
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conditionId?: IntFieldUpdateOperationsInput | number
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryEntryCreateInput = {
    refNo: string
    category: string
    title: string
    author?: string | null
    pubYear?: number | null
    creationDate: Date | string
    borrower?: string | null
    loanDate?: Date | string | null
    remarks?: string | null
    attachmentUrl?: string | null
    attachmentFilename?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryEntryUncheckedCreateInput = {
    id?: number
    refNo: string
    category: string
    title: string
    author?: string | null
    pubYear?: number | null
    creationDate: Date | string
    borrower?: string | null
    loanDate?: Date | string | null
    remarks?: string | null
    attachmentUrl?: string | null
    attachmentFilename?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryEntryUpdateInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    pubYear?: NullableIntFieldUpdateOperationsInput | number | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: NullableStringFieldUpdateOperationsInput | string | null
    loanDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentFilename?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    pubYear?: NullableIntFieldUpdateOperationsInput | number | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: NullableStringFieldUpdateOperationsInput | string | null
    loanDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentFilename?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryEntryCreateManyInput = {
    id?: number
    refNo: string
    category: string
    title: string
    author?: string | null
    pubYear?: number | null
    creationDate: Date | string
    borrower?: string | null
    loanDate?: Date | string | null
    remarks?: string | null
    attachmentUrl?: string | null
    attachmentFilename?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryEntryUpdateManyMutationInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    pubYear?: NullableIntFieldUpdateOperationsInput | number | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: NullableStringFieldUpdateOperationsInput | string | null
    loanDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentFilename?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    pubYear?: NullableIntFieldUpdateOperationsInput | number | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: NullableStringFieldUpdateOperationsInput | string | null
    loanDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentFilename?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutFeedbackInput
    recipients?: FeedbackRecipientCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    senderId: number
    recipients?: FeedbackRecipientUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutFeedbackNestedInput
    recipients?: FeedbackRecipientUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    recipients?: FeedbackRecipientUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackCreateManyInput = {
    id?: number
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    senderId: number
  }

  export type FeedbackUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackRecipientCreateInput = {
    feedback: FeedbackCreateNestedOneWithoutRecipientsInput
    user: UserCreateNestedOneWithoutFeedbackRecipientInput
  }

  export type FeedbackRecipientUncheckedCreateInput = {
    id?: number
    feedbackId: number
    userId: number
  }

  export type FeedbackRecipientUpdateInput = {
    feedback?: FeedbackUpdateOneRequiredWithoutRecipientsNestedInput
    user?: UserUpdateOneRequiredWithoutFeedbackRecipientNestedInput
  }

  export type FeedbackRecipientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feedbackId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackRecipientCreateManyInput = {
    id?: number
    feedbackId: number
    userId: number
  }

  export type FeedbackRecipientUpdateManyMutationInput = {

  }

  export type FeedbackRecipientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feedbackId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PagePermissionCreateInput = {
    route: string
    description?: string | null
    createdAt?: Date | string
    allowedRoles?: RolePermissionCreateNestedManyWithoutPagePermissionInput
    allowedUsers?: UserPermissionCreateNestedManyWithoutPagePermissionInput
  }

  export type PagePermissionUncheckedCreateInput = {
    id?: number
    route: string
    description?: string | null
    createdAt?: Date | string
    allowedRoles?: RolePermissionUncheckedCreateNestedManyWithoutPagePermissionInput
    allowedUsers?: UserPermissionUncheckedCreateNestedManyWithoutPagePermissionInput
  }

  export type PagePermissionUpdateInput = {
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowedRoles?: RolePermissionUpdateManyWithoutPagePermissionNestedInput
    allowedUsers?: UserPermissionUpdateManyWithoutPagePermissionNestedInput
  }

  export type PagePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowedRoles?: RolePermissionUncheckedUpdateManyWithoutPagePermissionNestedInput
    allowedUsers?: UserPermissionUncheckedUpdateManyWithoutPagePermissionNestedInput
  }

  export type PagePermissionCreateManyInput = {
    id?: number
    route: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PagePermissionUpdateManyMutationInput = {
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    roleName: string
    pagePermission: PagePermissionCreateNestedOneWithoutAllowedRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleName: string
    pagePermissionId: number
  }

  export type RolePermissionUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    pagePermission?: PagePermissionUpdateOneRequiredWithoutAllowedRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    pagePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleName: string
    pagePermissionId: number
  }

  export type RolePermissionUpdateManyMutationInput = {
    roleName?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    pagePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionCreateInput = {
    pagePermission: PagePermissionCreateNestedOneWithoutAllowedUsersInput
    user: UserCreateNestedOneWithoutUserPermissionInput
  }

  export type UserPermissionUncheckedCreateInput = {
    id?: number
    userId: number
    pagePermissionId: number
  }

  export type UserPermissionUpdateInput = {
    pagePermission?: PagePermissionUpdateOneRequiredWithoutAllowedUsersNestedInput
    user?: UserUpdateOneRequiredWithoutUserPermissionNestedInput
  }

  export type UserPermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pagePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionCreateManyInput = {
    id?: number
    userId: number
    pagePermissionId: number
  }

  export type UserPermissionUpdateManyMutationInput = {

  }

  export type UserPermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pagePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type pagesCreateInput = {
    notes?: string | null
  }

  export type pagesUncheckedCreateInput = {
    id?: number
    notes?: string | null
  }

  export type pagesUpdateInput = {
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagesCreateManyInput = {
    id?: number
    notes?: string | null
  }

  export type pagesUpdateManyMutationInput = {
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectTypeCreateInput = {
    name: string
    description?: string | null
    projects?: ProjectCreateNestedManyWithoutProjectTypeInput
  }

  export type ProjectTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutProjectTypeInput
  }

  export type ProjectTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutProjectTypeNestedInput
  }

  export type ProjectTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutProjectTypeNestedInput
  }

  export type ProjectTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type ProjectTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    models?: ModelEntryCreateNestedManyWithoutProjectInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    assignments?: ProjectAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    projectTypeId?: number | null
    models?: ModelEntryUncheckedCreateNestedManyWithoutProjectInput
    assignments?: ProjectAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelEntryUpdateManyWithoutProjectNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    assignments?: ProjectAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    models?: ModelEntryUncheckedUpdateManyWithoutProjectNestedInput
    assignments?: ProjectAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    projectTypeId?: number | null
  }

  export type ProjectUpdateManyMutationInput = {
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ModelEntryCreateInput = {
    code: string
    description?: string | null
    createDate: Date | string
    createBy: string
    modifyDate?: Date | string | null
    modifyBy?: string | null
    project: ProjectCreateNestedOneWithoutModelsInput
  }

  export type ModelEntryUncheckedCreateInput = {
    id?: number
    code: string
    description?: string | null
    createDate: Date | string
    createBy: string
    modifyDate?: Date | string | null
    modifyBy?: string | null
    projectId: number
  }

  export type ModelEntryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutModelsNestedInput
  }

  export type ModelEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ModelEntryCreateManyInput = {
    id?: number
    code: string
    description?: string | null
    createDate: Date | string
    createBy: string
    modifyDate?: Date | string | null
    modifyBy?: string | null
    projectId: number
  }

  export type ModelEntryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectAssignmentCreateInput = {
    role: string
    project: ProjectCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutProjectAssignmentInput
  }

  export type ProjectAssignmentUncheckedCreateInput = {
    id?: number
    userId: number
    projectId: number
    role: string
  }

  export type ProjectAssignmentUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectAssignmentNestedInput
  }

  export type ProjectAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectAssignmentCreateManyInput = {
    id?: number
    userId: number
    projectId: number
    role: string
  }

  export type ProjectAssignmentUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SambaLogCreateInput = {
    timestamp?: Date | string
    component: string
    level: string
    message: string
    zone?: string | null
    name?: string | null
    errorCode?: number | null
    errorName?: string | null
    hostname?: string | null
    createdAt?: Date | string
  }

  export type SambaLogUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    component: string
    level: string
    message: string
    zone?: string | null
    name?: string | null
    errorCode?: number | null
    errorName?: string | null
    hostname?: string | null
    createdAt?: Date | string
  }

  export type SambaLogUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableIntFieldUpdateOperationsInput | number | null
    errorName?: NullableStringFieldUpdateOperationsInput | string | null
    hostname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SambaLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableIntFieldUpdateOperationsInput | number | null
    errorName?: NullableStringFieldUpdateOperationsInput | string | null
    hostname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SambaLogCreateManyInput = {
    id?: number
    timestamp?: Date | string
    component: string
    level: string
    message: string
    zone?: string | null
    name?: string | null
    errorCode?: number | null
    errorName?: string | null
    hostname?: string | null
    createdAt?: Date | string
  }

  export type SambaLogUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableIntFieldUpdateOperationsInput | number | null
    errorName?: NullableStringFieldUpdateOperationsInput | string | null
    hostname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SambaLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableIntFieldUpdateOperationsInput | number | null
    errorName?: NullableStringFieldUpdateOperationsInput | string | null
    hostname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationCreateInput = {
    code: string
    name: string
    modifyBy?: string | null
    createBy: string
    modifyDate?: Date | string
    CCY?: string | null
    Region?: string | null
    Remarks?: string | null
    WCI_URL?: string | null
    createDate?: Date | string
    fullname?: string | null
    TeamLocation?: TeamLocationCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    modifyBy?: string | null
    createBy: string
    modifyDate?: Date | string
    CCY?: string | null
    Region?: string | null
    Remarks?: string | null
    WCI_URL?: string | null
    createDate?: Date | string
    fullname?: string | null
    TeamLocation?: TeamLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CCY?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    WCI_URL?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    TeamLocation?: TeamLocationUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CCY?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    WCI_URL?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    TeamLocation?: TeamLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationCreateManyInput = {
    id?: number
    code: string
    name: string
    modifyBy?: string | null
    createBy: string
    modifyDate?: Date | string
    CCY?: string | null
    Region?: string | null
    Remarks?: string | null
    WCI_URL?: string | null
    createDate?: Date | string
    fullname?: string | null
  }

  export type locationUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CCY?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    WCI_URL?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CCY?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    WCI_URL?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ldapuserCreateInput = {
    dn: string
    objectClass?: ldapuserCreateobjectClassInput | string[]
    cn: string
    sn?: string | null
    givenName?: string | null
    instanceType: number
    whenCreated: bigint | number
    displayName?: string | null
    uSNCreated: number
    name: string
    objectGUID: string
    badPwdCount?: number | null
    codePage: number
    countryCode: number
    badPasswordTime?: bigint | number | null
    lastLogoff?: bigint | number | null
    lastLogon?: bigint | number | null
    primaryGroupID: number
    objectSid: string
    accountExpires: bigint | number
    logonCount?: number | null
    sAMAccountName: string
    sAMAccountType: number
    userPrincipalName?: string | null
    objectCategory: string
    pwdLastSet: bigint | number
    userAccountControl: number
    whenChanged: bigint | number
    uSNChanged: number
    distinguishedName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminCount?: number | null
    description?: string | null
    isCriticalSystemObject?: boolean | null
    memberOf?: string | null
    servicePrincipalName?: string | null
    showInAdvancedViewOnly?: boolean | null
  }

  export type ldapuserUncheckedCreateInput = {
    dn: string
    objectClass?: ldapuserCreateobjectClassInput | string[]
    cn: string
    sn?: string | null
    givenName?: string | null
    instanceType: number
    whenCreated: bigint | number
    displayName?: string | null
    uSNCreated: number
    name: string
    objectGUID: string
    badPwdCount?: number | null
    codePage: number
    countryCode: number
    badPasswordTime?: bigint | number | null
    lastLogoff?: bigint | number | null
    lastLogon?: bigint | number | null
    primaryGroupID: number
    objectSid: string
    accountExpires: bigint | number
    logonCount?: number | null
    sAMAccountName: string
    sAMAccountType: number
    userPrincipalName?: string | null
    objectCategory: string
    pwdLastSet: bigint | number
    userAccountControl: number
    whenChanged: bigint | number
    uSNChanged: number
    distinguishedName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminCount?: number | null
    description?: string | null
    isCriticalSystemObject?: boolean | null
    memberOf?: string | null
    servicePrincipalName?: string | null
    showInAdvancedViewOnly?: boolean | null
    id?: number
  }

  export type ldapuserUpdateInput = {
    dn?: StringFieldUpdateOperationsInput | string
    objectClass?: ldapuserUpdateobjectClassInput | string[]
    cn?: StringFieldUpdateOperationsInput | string
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceType?: IntFieldUpdateOperationsInput | number
    whenCreated?: BigIntFieldUpdateOperationsInput | bigint | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    uSNCreated?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectGUID?: StringFieldUpdateOperationsInput | string
    badPwdCount?: NullableIntFieldUpdateOperationsInput | number | null
    codePage?: IntFieldUpdateOperationsInput | number
    countryCode?: IntFieldUpdateOperationsInput | number
    badPasswordTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogoff?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogon?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    primaryGroupID?: IntFieldUpdateOperationsInput | number
    objectSid?: StringFieldUpdateOperationsInput | string
    accountExpires?: BigIntFieldUpdateOperationsInput | bigint | number
    logonCount?: NullableIntFieldUpdateOperationsInput | number | null
    sAMAccountName?: StringFieldUpdateOperationsInput | string
    sAMAccountType?: IntFieldUpdateOperationsInput | number
    userPrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    objectCategory?: StringFieldUpdateOperationsInput | string
    pwdLastSet?: BigIntFieldUpdateOperationsInput | bigint | number
    userAccountControl?: IntFieldUpdateOperationsInput | number
    whenChanged?: BigIntFieldUpdateOperationsInput | bigint | number
    uSNChanged?: IntFieldUpdateOperationsInput | number
    distinguishedName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCriticalSystemObject?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberOf?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    showInAdvancedViewOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ldapuserUncheckedUpdateInput = {
    dn?: StringFieldUpdateOperationsInput | string
    objectClass?: ldapuserUpdateobjectClassInput | string[]
    cn?: StringFieldUpdateOperationsInput | string
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceType?: IntFieldUpdateOperationsInput | number
    whenCreated?: BigIntFieldUpdateOperationsInput | bigint | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    uSNCreated?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectGUID?: StringFieldUpdateOperationsInput | string
    badPwdCount?: NullableIntFieldUpdateOperationsInput | number | null
    codePage?: IntFieldUpdateOperationsInput | number
    countryCode?: IntFieldUpdateOperationsInput | number
    badPasswordTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogoff?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogon?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    primaryGroupID?: IntFieldUpdateOperationsInput | number
    objectSid?: StringFieldUpdateOperationsInput | string
    accountExpires?: BigIntFieldUpdateOperationsInput | bigint | number
    logonCount?: NullableIntFieldUpdateOperationsInput | number | null
    sAMAccountName?: StringFieldUpdateOperationsInput | string
    sAMAccountType?: IntFieldUpdateOperationsInput | number
    userPrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    objectCategory?: StringFieldUpdateOperationsInput | string
    pwdLastSet?: BigIntFieldUpdateOperationsInput | bigint | number
    userAccountControl?: IntFieldUpdateOperationsInput | number
    whenChanged?: BigIntFieldUpdateOperationsInput | bigint | number
    uSNChanged?: IntFieldUpdateOperationsInput | number
    distinguishedName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCriticalSystemObject?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberOf?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    showInAdvancedViewOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ldapuserCreateManyInput = {
    dn: string
    objectClass?: ldapuserCreateobjectClassInput | string[]
    cn: string
    sn?: string | null
    givenName?: string | null
    instanceType: number
    whenCreated: bigint | number
    displayName?: string | null
    uSNCreated: number
    name: string
    objectGUID: string
    badPwdCount?: number | null
    codePage: number
    countryCode: number
    badPasswordTime?: bigint | number | null
    lastLogoff?: bigint | number | null
    lastLogon?: bigint | number | null
    primaryGroupID: number
    objectSid: string
    accountExpires: bigint | number
    logonCount?: number | null
    sAMAccountName: string
    sAMAccountType: number
    userPrincipalName?: string | null
    objectCategory: string
    pwdLastSet: bigint | number
    userAccountControl: number
    whenChanged: bigint | number
    uSNChanged: number
    distinguishedName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminCount?: number | null
    description?: string | null
    isCriticalSystemObject?: boolean | null
    memberOf?: string | null
    servicePrincipalName?: string | null
    showInAdvancedViewOnly?: boolean | null
    id?: number
  }

  export type ldapuserUpdateManyMutationInput = {
    dn?: StringFieldUpdateOperationsInput | string
    objectClass?: ldapuserUpdateobjectClassInput | string[]
    cn?: StringFieldUpdateOperationsInput | string
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceType?: IntFieldUpdateOperationsInput | number
    whenCreated?: BigIntFieldUpdateOperationsInput | bigint | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    uSNCreated?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectGUID?: StringFieldUpdateOperationsInput | string
    badPwdCount?: NullableIntFieldUpdateOperationsInput | number | null
    codePage?: IntFieldUpdateOperationsInput | number
    countryCode?: IntFieldUpdateOperationsInput | number
    badPasswordTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogoff?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogon?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    primaryGroupID?: IntFieldUpdateOperationsInput | number
    objectSid?: StringFieldUpdateOperationsInput | string
    accountExpires?: BigIntFieldUpdateOperationsInput | bigint | number
    logonCount?: NullableIntFieldUpdateOperationsInput | number | null
    sAMAccountName?: StringFieldUpdateOperationsInput | string
    sAMAccountType?: IntFieldUpdateOperationsInput | number
    userPrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    objectCategory?: StringFieldUpdateOperationsInput | string
    pwdLastSet?: BigIntFieldUpdateOperationsInput | bigint | number
    userAccountControl?: IntFieldUpdateOperationsInput | number
    whenChanged?: BigIntFieldUpdateOperationsInput | bigint | number
    uSNChanged?: IntFieldUpdateOperationsInput | number
    distinguishedName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCriticalSystemObject?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberOf?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    showInAdvancedViewOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ldapuserUncheckedUpdateManyInput = {
    dn?: StringFieldUpdateOperationsInput | string
    objectClass?: ldapuserUpdateobjectClassInput | string[]
    cn?: StringFieldUpdateOperationsInput | string
    sn?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceType?: IntFieldUpdateOperationsInput | number
    whenCreated?: BigIntFieldUpdateOperationsInput | bigint | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    uSNCreated?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectGUID?: StringFieldUpdateOperationsInput | string
    badPwdCount?: NullableIntFieldUpdateOperationsInput | number | null
    codePage?: IntFieldUpdateOperationsInput | number
    countryCode?: IntFieldUpdateOperationsInput | number
    badPasswordTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogoff?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastLogon?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    primaryGroupID?: IntFieldUpdateOperationsInput | number
    objectSid?: StringFieldUpdateOperationsInput | string
    accountExpires?: BigIntFieldUpdateOperationsInput | bigint | number
    logonCount?: NullableIntFieldUpdateOperationsInput | number | null
    sAMAccountName?: StringFieldUpdateOperationsInput | string
    sAMAccountType?: IntFieldUpdateOperationsInput | number
    userPrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    objectCategory?: StringFieldUpdateOperationsInput | string
    pwdLastSet?: BigIntFieldUpdateOperationsInput | bigint | number
    userAccountControl?: IntFieldUpdateOperationsInput | number
    whenChanged?: BigIntFieldUpdateOperationsInput | bigint | number
    uSNChanged?: IntFieldUpdateOperationsInput | number
    distinguishedName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCriticalSystemObject?: NullableBoolFieldUpdateOperationsInput | boolean | null
    memberOf?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrincipalName?: NullableStringFieldUpdateOperationsInput | string | null
    showInAdvancedViewOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type DriveFolderCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileCreateNestedManyWithoutFolderInput
    owner: UserCreateNestedOneWithoutDriveFolderInput
    parent?: DriveFolderCreateNestedOneWithoutChildrenInput
    children?: DriveFolderCreateNestedManyWithoutParentInput
  }

  export type DriveFolderUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileUncheckedCreateNestedManyWithoutFolderInput
    children?: DriveFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type DriveFolderUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUpdateManyWithoutFolderNestedInput
    owner?: UserUpdateOneRequiredWithoutDriveFolderNestedInput
    parent?: DriveFolderUpdateOneWithoutChildrenNestedInput
    children?: DriveFolderUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUncheckedUpdateManyWithoutFolderNestedInput
    children?: DriveFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriveFolderUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFolderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFileCreateInput = {
    name: string
    type: string
    size: number
    order?: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: DriveFolderCreateNestedOneWithoutFilesInput
    owner: UserCreateNestedOneWithoutDriveFileInput
    permissions?: DriveFilePermissionCreateNestedManyWithoutFileInput
  }

  export type DriveFileUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    folderId?: number | null
    ownerId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type DriveFileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: DriveFolderUpdateOneWithoutFilesNestedInput
    owner?: UserUpdateOneRequiredWithoutDriveFileNestedInput
    permissions?: DriveFilePermissionUpdateManyWithoutFileNestedInput
  }

  export type DriveFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DriveFilePermissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type DriveFileCreateManyInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    folderId?: number | null
    ownerId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriveFileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFilePermissionCreateInput = {
    access: string
    grantedAt?: Date | string
    file: DriveFileCreateNestedOneWithoutPermissionsInput
    granter: UserCreateNestedOneWithoutGrantedPermissionsInput
    user: UserCreateNestedOneWithoutDriveFilePermissionInput
    User?: UserCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionUncheckedCreateInput = {
    id?: number
    fileId: number
    userId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
    User?: UserUncheckedCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionUpdateInput = {
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: DriveFileUpdateOneRequiredWithoutPermissionsNestedInput
    granter?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutDriveFilePermissionNestedInput
    User?: UserUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionCreateManyInput = {
    id?: number
    fileId: number
    userId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
  }

  export type DriveFilePermissionUpdateManyMutationInput = {
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFilePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleCreateInput = {
    sn: string
    jobTitle: string
    abbreviation: string
    grade: string
    seniorityLevel: string
    selectableInStaffCV: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobTitleUncheckedCreateInput = {
    id?: number
    sn: string
    jobTitle: string
    abbreviation: string
    grade: string
    seniorityLevel: string
    selectableInStaffCV: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobTitleUpdateInput = {
    sn?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    seniorityLevel?: StringFieldUpdateOperationsInput | string
    selectableInStaffCV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sn?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    seniorityLevel?: StringFieldUpdateOperationsInput | string
    selectableInStaffCV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleCreateManyInput = {
    id?: number
    sn: string
    jobTitle: string
    abbreviation: string
    grade: string
    seniorityLevel: string
    selectableInStaffCV: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobTitleUpdateManyMutationInput = {
    sn?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    seniorityLevel?: StringFieldUpdateOperationsInput | string
    selectableInStaffCV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sn?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    seniorityLevel?: StringFieldUpdateOperationsInput | string
    selectableInStaffCV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateInput = {
    userId: number
    username: string
    page: string
    loginTime?: Date | string
  }

  export type UserActivityUncheckedCreateInput = {
    id?: number
    userId: number
    username: string
    page: string
    loginTime?: Date | string
  }

  export type UserActivityUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateManyInput = {
    id?: number
    userId: number
    username: string
    page: string
    loginTime?: Date | string
  }

  export type UserActivityUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaders?: TeamLeaderCreateNestedManyWithoutTeamInput
    locations?: TeamLocationCreateNestedManyWithoutTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaders?: TeamLeaderUncheckedCreateNestedManyWithoutTeamInput
    locations?: TeamLocationUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaders?: TeamLeaderUpdateManyWithoutTeamNestedInput
    locations?: TeamLocationUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaders?: TeamLeaderUncheckedUpdateManyWithoutTeamNestedInput
    locations?: TeamLocationUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamLeaderCreateInput = {
    team: TeamCreateNestedOneWithoutLeadersInput
    user: UserCreateNestedOneWithoutTeamLeaderInput
  }

  export type TeamLeaderUncheckedCreateInput = {
    id?: number
    teamId: number
    userId: number
  }

  export type TeamLeaderUpdateInput = {
    team?: TeamUpdateOneRequiredWithoutLeadersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamLeaderNestedInput
  }

  export type TeamLeaderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLeaderCreateManyInput = {
    id?: number
    teamId: number
    userId: number
  }

  export type TeamLeaderUpdateManyMutationInput = {

  }

  export type TeamLeaderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberCreateInput = {
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: number
    teamId: number
    userId: number
  }

  export type TeamMemberUpdateInput = {
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberCreateManyInput = {
    id?: number
    teamId: number
    userId: number
  }

  export type TeamMemberUpdateManyMutationInput = {

  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLocationCreateInput = {
    location: locationCreateNestedOneWithoutTeamLocationInput
    team: TeamCreateNestedOneWithoutLocationsInput
  }

  export type TeamLocationUncheckedCreateInput = {
    id?: number
    teamId: number
    locationId: number
  }

  export type TeamLocationUpdateInput = {
    location?: locationUpdateOneRequiredWithoutTeamLocationNestedInput
    team?: TeamUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type TeamLocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLocationCreateManyInput = {
    id?: number
    teamId: number
    locationId: number
  }

  export type TeamLocationUpdateManyMutationInput = {

  }

  export type TeamLocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditWorkflowCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: AuditStepCreateNestedManyWithoutWorkflowInput
  }

  export type AuditWorkflowUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: AuditStepUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type AuditWorkflowUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: AuditStepUpdateManyWithoutWorkflowNestedInput
  }

  export type AuditWorkflowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: AuditStepUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type AuditWorkflowCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditWorkflowUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditWorkflowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditStepCreateInput = {
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    dueDate?: Date | string | null
    workflow: AuditWorkflowCreateNestedOneWithoutStepsInput
    assignedTo?: UserCreateNestedOneWithoutAudit_stepsInput
    logs?: StepLogCreateNestedManyWithoutStepInput
  }

  export type AuditStepUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    assignedToId?: number | null
    dueDate?: Date | string | null
    workflowId: number
    logs?: StepLogUncheckedCreateNestedManyWithoutStepInput
  }

  export type AuditStepUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: AuditWorkflowUpdateOneRequiredWithoutStepsNestedInput
    assignedTo?: UserUpdateOneWithoutAudit_stepsNestedInput
    logs?: StepLogUpdateManyWithoutStepNestedInput
  }

  export type AuditStepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflowId?: IntFieldUpdateOperationsInput | number
    logs?: StepLogUncheckedUpdateManyWithoutStepNestedInput
  }

  export type AuditStepCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    assignedToId?: number | null
    dueDate?: Date | string | null
    workflowId: number
  }

  export type AuditStepUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditStepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflowId?: IntFieldUpdateOperationsInput | number
  }

  export type StepLogCreateInput = {
    message: string
    createdBy: string
    createdAt?: Date | string
    step: AuditStepCreateNestedOneWithoutLogsInput
  }

  export type StepLogUncheckedCreateInput = {
    id?: number
    stepId: number
    message: string
    createdBy: string
    createdAt?: Date | string
  }

  export type StepLogUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: AuditStepUpdateOneRequiredWithoutLogsNestedInput
  }

  export type StepLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stepId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepLogCreateManyInput = {
    id?: number
    stepId: number
    message: string
    createdBy: string
    createdAt?: Date | string
  }

  export type StepLogUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stepId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type logsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    timestamp?: SortOrder
    piuser?: SortOrder
    pid?: SortOrder
    action?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    command?: SortOrder
    port?: SortOrder
    ipAddress?: SortOrder
  }

  export type logsAvgOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    port?: SortOrder
  }

  export type logsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    timestamp?: SortOrder
    piuser?: SortOrder
    pid?: SortOrder
    action?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    command?: SortOrder
    port?: SortOrder
    ipAddress?: SortOrder
  }

  export type logsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    timestamp?: SortOrder
    piuser?: SortOrder
    pid?: SortOrder
    action?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    command?: SortOrder
    port?: SortOrder
    ipAddress?: SortOrder
  }

  export type logsSumOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    port?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type authCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    username?: SortOrder
    log_entry?: SortOrder
  }

  export type authAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type authMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    username?: SortOrder
    log_entry?: SortOrder
  }

  export type authMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    username?: SortOrder
    log_entry?: SortOrder
  }

  export type authSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type memory_usageCountOrderByAggregateInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
    host?: SortOrder
    time?: SortOrder
  }

  export type memory_usageAvgOrderByAggregateInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
  }

  export type memory_usageMaxOrderByAggregateInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
    host?: SortOrder
    time?: SortOrder
  }

  export type memory_usageMinOrderByAggregateInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
    host?: SortOrder
    time?: SortOrder
  }

  export type memory_usageSumOrderByAggregateInput = {
    id?: SortOrder
    total_memory?: SortOrder
    used_memory?: SortOrder
    free_memory?: SortOrder
    available_memory?: SortOrder
    percent_usage?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type system_metricsCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    sensor_name?: SortOrder
    value_type?: SortOrder
    value?: SortOrder
    host?: SortOrder
    min?: SortOrder
    max?: SortOrder
  }

  export type system_metricsAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type system_metricsMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    sensor_name?: SortOrder
    value_type?: SortOrder
    value?: SortOrder
    host?: SortOrder
    min?: SortOrder
    max?: SortOrder
  }

  export type system_metricsMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    sensor_name?: SortOrder
    value_type?: SortOrder
    value?: SortOrder
    host?: SortOrder
    min?: SortOrder
    max?: SortOrder
  }

  export type system_metricsSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type diskmetricCountOrderByAggregateInput = {
    id?: SortOrder
    host?: SortOrder
    name?: SortOrder
    label?: SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
    timestamp?: SortOrder
  }

  export type diskmetricAvgOrderByAggregateInput = {
    id?: SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
  }

  export type diskmetricMaxOrderByAggregateInput = {
    id?: SortOrder
    host?: SortOrder
    name?: SortOrder
    label?: SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
    timestamp?: SortOrder
  }

  export type diskmetricMinOrderByAggregateInput = {
    id?: SortOrder
    host?: SortOrder
    name?: SortOrder
    label?: SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
    timestamp?: SortOrder
  }

  export type diskmetricSumOrderByAggregateInput = {
    id?: SortOrder
    totalgb?: SortOrder
    usedgb?: SortOrder
    freegb?: SortOrder
  }

  export type notesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    time?: SortOrder
    description?: SortOrder
  }

  export type notesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type notesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    time?: SortOrder
    description?: SortOrder
  }

  export type notesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    time?: SortOrder
    description?: SortOrder
  }

  export type notesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceUserListRelationFilter = {
    every?: DeviceUserWhereInput
    some?: DeviceUserWhereInput
    none?: DeviceUserWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type DeviceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type devicesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ip_address?: SortOrder
    mac_address?: SortOrder
    password?: SortOrder
    time?: SortOrder
    notes?: SortOrder
    status?: SortOrder
  }

  export type devicesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type devicesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ip_address?: SortOrder
    mac_address?: SortOrder
    password?: SortOrder
    time?: SortOrder
    notes?: SortOrder
    status?: SortOrder
  }

  export type devicesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ip_address?: SortOrder
    mac_address?: SortOrder
    password?: SortOrder
    time?: SortOrder
    notes?: SortOrder
    status?: SortOrder
  }

  export type devicesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DevicesScalarRelationFilter = {
    is?: devicesWhereInput
    isNot?: devicesWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DeviceUserUserIdDeviceIdCompoundUniqueInput = {
    userId: number
    deviceId: number
  }

  export type DeviceUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    role?: SortOrder
  }

  export type DeviceUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
  }

  export type DeviceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    role?: SortOrder
  }

  export type DeviceUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    role?: SortOrder
  }

  export type DeviceUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
  }

  export type EmailTemplateNullableScalarRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type RuleScalarRelationFilter = {
    is?: RuleWhereInput
    isNot?: RuleWhereInput
  }

  export type CommandMatchListRelationFilter = {
    every?: CommandMatchWhereInput
    some?: CommandMatchWhereInput
    none?: CommandMatchWhereInput
  }

  export type CommandMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandCountOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    command?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type CommandAvgOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type CommandMaxOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    command?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type CommandMinOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    command?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type CommandSumOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type CommandListRelationFilter = {
    every?: CommandWhereInput
    some?: CommandWhereInput
    none?: CommandWhereInput
  }

  export type RuleGroupNullableScalarRelationFilter = {
    is?: RuleGroupWhereInput | null
    isNot?: RuleGroupWhereInput | null
  }

  export type CommandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleListRelationFilter = {
    every?: RuleWhereInput
    some?: RuleWhereInput
    none?: RuleWhereInput
  }

  export type RuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RuleGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RuleGroupSumOrderByAggregateInput = {
    id?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommandScalarRelationFilter = {
    is?: CommandWhereInput
    isNot?: CommandWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandMatchCountOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    logType?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    commandText?: SortOrder
    logEntry?: SortOrder
    timestamp?: SortOrder
    addressed?: SortOrder
    addressedBy?: SortOrder
    addressedAt?: SortOrder
    notes?: SortOrder
    emailSent?: SortOrder
  }

  export type CommandMatchAvgOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    addressedBy?: SortOrder
  }

  export type CommandMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    logType?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    commandText?: SortOrder
    logEntry?: SortOrder
    timestamp?: SortOrder
    addressed?: SortOrder
    addressedBy?: SortOrder
    addressedAt?: SortOrder
    notes?: SortOrder
    emailSent?: SortOrder
  }

  export type CommandMatchMinOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    logType?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    commandText?: SortOrder
    logEntry?: SortOrder
    timestamp?: SortOrder
    addressed?: SortOrder
    addressedBy?: SortOrder
    addressedAt?: SortOrder
    notes?: SortOrder
    emailSent?: SortOrder
  }

  export type CommandMatchSumOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    commandId?: SortOrder
    ruleId?: SortOrder
    addressedBy?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
  }

  export type AlertConditionListRelationFilter = {
    every?: AlertConditionWhereInput
    some?: AlertConditionWhereInput
    none?: AlertConditionWhereInput
  }

  export type RuleGroupListRelationFilter = {
    every?: RuleGroupWhereInput
    some?: RuleGroupWhereInput
    none?: RuleGroupWhereInput
  }

  export type SavedQueryListRelationFilter = {
    every?: SavedQueryWhereInput
    some?: SavedQueryWhereInput
    none?: SavedQueryWhereInput
  }

  export type UserEmailTemplateListRelationFilter = {
    every?: UserEmailTemplateWhereInput
    some?: UserEmailTemplateWhereInput
    none?: UserEmailTemplateWhereInput
  }

  export type AlertConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RuleGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedQueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEmailTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type DriveFileListRelationFilter = {
    every?: DriveFileWhereInput
    some?: DriveFileWhereInput
    none?: DriveFileWhereInput
  }

  export type DriveFilePermissionListRelationFilter = {
    every?: DriveFilePermissionWhereInput
    some?: DriveFilePermissionWhereInput
    none?: DriveFilePermissionWhereInput
  }

  export type DriveFolderListRelationFilter = {
    every?: DriveFolderWhereInput
    some?: DriveFolderWhereInput
    none?: DriveFolderWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type FeedbackRecipientListRelationFilter = {
    every?: FeedbackRecipientWhereInput
    some?: FeedbackRecipientWhereInput
    none?: FeedbackRecipientWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationReadListRelationFilter = {
    every?: NotificationReadWhereInput
    some?: NotificationReadWhereInput
    none?: NotificationReadWhereInput
  }

  export type ProjectAssignmentListRelationFilter = {
    every?: ProjectAssignmentWhereInput
    some?: ProjectAssignmentWhereInput
    none?: ProjectAssignmentWhereInput
  }

  export type TeamLeaderListRelationFilter = {
    every?: TeamLeaderWhereInput
    some?: TeamLeaderWhereInput
    none?: TeamLeaderWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TicketAttachmentListRelationFilter = {
    every?: TicketAttachmentWhereInput
    some?: TicketAttachmentWhereInput
    none?: TicketAttachmentWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type UserPermissionListRelationFilter = {
    every?: UserPermissionWhereInput
    some?: UserPermissionWhereInput
    none?: UserPermissionWhereInput
  }

  export type AuditStepListRelationFilter = {
    every?: AuditStepWhereInput
    some?: AuditStepWhereInput
    none?: AuditStepWhereInput
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriveFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriveFilePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriveFolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamLeaderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    Mobile?: SortOrder
    PrimaryContact?: SortOrder
    MobileContact?: SortOrder
    Relationship?: SortOrder
    SecondContact?: SortOrder
    SecondMobile?: SortOrder
    SecondRelationship?: SortOrder
    Remarks?: SortOrder
    ndafile?: SortOrder
    ndasubmissiondate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    Mobile?: SortOrder
    MobileContact?: SortOrder
    SecondMobile?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    Mobile?: SortOrder
    PrimaryContact?: SortOrder
    MobileContact?: SortOrder
    Relationship?: SortOrder
    SecondContact?: SortOrder
    SecondMobile?: SortOrder
    SecondRelationship?: SortOrder
    Remarks?: SortOrder
    ndafile?: SortOrder
    ndasubmissiondate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    Mobile?: SortOrder
    PrimaryContact?: SortOrder
    MobileContact?: SortOrder
    Relationship?: SortOrder
    SecondContact?: SortOrder
    SecondMobile?: SortOrder
    SecondRelationship?: SortOrder
    Remarks?: SortOrder
    ndafile?: SortOrder
    ndasubmissiondate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    Mobile?: SortOrder
    MobileContact?: SortOrder
    SecondMobile?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberUserIdGroupIdCompoundUniqueInput = {
    userId: number
    groupId: number
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    edited?: SortOrder
    createdAt?: SortOrder
    fileAttachment?: SortOrder
    fileOriginalName?: SortOrder
    fileType?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    edited?: SortOrder
    createdAt?: SortOrder
    fileAttachment?: SortOrder
    fileOriginalName?: SortOrder
    fileType?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    edited?: SortOrder
    createdAt?: SortOrder
    fileAttachment?: SortOrder
    fileOriginalName?: SortOrder
    fileType?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
  }

  export type EmailTemplateScalarRelationFilter = {
    is?: EmailTemplateWhereInput
    isNot?: EmailTemplateWhereInput
  }

  export type UserEmailTemplateUserIdEmailTemplateIdCompoundUniqueInput = {
    userId: number
    emailTemplateId: number
  }

  export type UserEmailTemplateCountOrderByAggregateInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserEmailTemplateAvgOrderByAggregateInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type UserEmailTemplateMaxOrderByAggregateInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserEmailTemplateMinOrderByAggregateInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserEmailTemplateSumOrderByAggregateInput = {
    userId?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postDate?: SortOrder
    expiryDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    important?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postDate?: SortOrder
    expiryDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    important?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postDate?: SortOrder
    expiryDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    important?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationReadNotificationIdUserIdCompoundUniqueInput = {
    notificationId: number
    userId: number
  }

  export type NotificationReadCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReadAvgOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
  }

  export type NotificationReadMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReadMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReadSumOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SavedQueryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tableName?: SortOrder
    columns?: SortOrder
    conditions?: SortOrder
    emailTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedQueryAvgOrderByAggregateInput = {
    id?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type SavedQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tableName?: SortOrder
    emailTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedQueryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tableName?: SortOrder
    emailTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedQuerySumOrderByAggregateInput = {
    id?: SortOrder
    emailTemplateId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SupportTicketScalarRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
  }

  export type DevicesNullableScalarRelationFilter = {
    is?: devicesWhereInput | null
    isNot?: devicesWhereInput | null
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrder
  }

  export type SupportTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrder
  }

  export type SupportTicketSumOrderByAggregateInput = {
    id?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    relatedDeviceId?: SortOrder
  }

  export type TicketCommentNullableScalarRelationFilter = {
    is?: TicketCommentWhereInput | null
    isNot?: TicketCommentWhereInput | null
  }

  export type SupportTicketNullableScalarRelationFilter = {
    is?: SupportTicketWhereInput | null
    isNot?: SupportTicketWhereInput | null
  }

  export type TicketAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    commentId?: SortOrder
    uploaderId?: SortOrder
  }

  export type TicketAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    ticketId?: SortOrder
    commentId?: SortOrder
    uploaderId?: SortOrder
  }

  export type TicketAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    commentId?: SortOrder
    uploaderId?: SortOrder
  }

  export type TicketAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    commentId?: SortOrder
    uploaderId?: SortOrder
  }

  export type TicketAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    ticketId?: SortOrder
    commentId?: SortOrder
    uploaderId?: SortOrder
  }

  export type AlertEventListRelationFilter = {
    every?: AlertEventWhereInput
    some?: AlertEventWhereInput
    none?: AlertEventWhereInput
  }

  export type AlertEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sourceTable?: SortOrder
    fieldName?: SortOrder
    comparator?: SortOrder
    thresholdValue?: SortOrder
    timeWindowMin?: SortOrder
    repeatIntervalMin?: SortOrder
    countThreshold?: SortOrder
    lastTriggeredAt?: SortOrder
    active?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type AlertConditionAvgOrderByAggregateInput = {
    id?: SortOrder
    timeWindowMin?: SortOrder
    repeatIntervalMin?: SortOrder
    countThreshold?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type AlertConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sourceTable?: SortOrder
    fieldName?: SortOrder
    comparator?: SortOrder
    thresholdValue?: SortOrder
    timeWindowMin?: SortOrder
    repeatIntervalMin?: SortOrder
    countThreshold?: SortOrder
    lastTriggeredAt?: SortOrder
    active?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type AlertConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sourceTable?: SortOrder
    fieldName?: SortOrder
    comparator?: SortOrder
    thresholdValue?: SortOrder
    timeWindowMin?: SortOrder
    repeatIntervalMin?: SortOrder
    countThreshold?: SortOrder
    lastTriggeredAt?: SortOrder
    active?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type AlertConditionSumOrderByAggregateInput = {
    id?: SortOrder
    timeWindowMin?: SortOrder
    repeatIntervalMin?: SortOrder
    countThreshold?: SortOrder
    emailTemplateId?: SortOrder
  }

  export type AlertConditionScalarRelationFilter = {
    is?: AlertConditionWhereInput
    isNot?: AlertConditionWhereInput
  }

  export type AlertEventCountOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
    triggeredAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
  }

  export type AlertEventAvgOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
  }

  export type AlertEventMaxOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
    triggeredAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
  }

  export type AlertEventMinOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
    triggeredAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
  }

  export type AlertEventSumOrderByAggregateInput = {
    id?: SortOrder
    conditionId?: SortOrder
  }

  export type LibraryEntryCountOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    category?: SortOrder
    title?: SortOrder
    author?: SortOrder
    pubYear?: SortOrder
    creationDate?: SortOrder
    borrower?: SortOrder
    loanDate?: SortOrder
    remarks?: SortOrder
    attachmentUrl?: SortOrder
    attachmentFilename?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    pubYear?: SortOrder
  }

  export type LibraryEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    category?: SortOrder
    title?: SortOrder
    author?: SortOrder
    pubYear?: SortOrder
    creationDate?: SortOrder
    borrower?: SortOrder
    loanDate?: SortOrder
    remarks?: SortOrder
    attachmentUrl?: SortOrder
    attachmentFilename?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryEntryMinOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    category?: SortOrder
    title?: SortOrder
    author?: SortOrder
    pubYear?: SortOrder
    creationDate?: SortOrder
    borrower?: SortOrder
    loanDate?: SortOrder
    remarks?: SortOrder
    attachmentUrl?: SortOrder
    attachmentFilename?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryEntrySumOrderByAggregateInput = {
    id?: SortOrder
    pubYear?: SortOrder
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
  }

  export type FeedbackScalarRelationFilter = {
    is?: FeedbackWhereInput
    isNot?: FeedbackWhereInput
  }

  export type FeedbackRecipientFeedbackIdUserIdCompoundUniqueInput = {
    feedbackId: number
    userId: number
  }

  export type FeedbackRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackRecipientAvgOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackRecipientSumOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PagePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    route?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PagePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PagePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    route?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PagePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    route?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PagePermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PagePermissionScalarRelationFilter = {
    is?: PagePermissionWhereInput
    isNot?: PagePermissionWhereInput
  }

  export type RolePermissionRoleNamePagePermissionIdCompoundUniqueInput = {
    roleName: string
    pagePermissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type UserPermissionUserIdPagePermissionIdCompoundUniqueInput = {
    userId: number
    pagePermissionId: number
  }

  export type UserPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type UserPermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type UserPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type UserPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type UserPermissionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pagePermissionId?: SortOrder
  }

  export type pagesCountOrderByAggregateInput = {
    id?: SortOrder
    notes?: SortOrder
  }

  export type pagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pagesMaxOrderByAggregateInput = {
    id?: SortOrder
    notes?: SortOrder
  }

  export type pagesMinOrderByAggregateInput = {
    id?: SortOrder
    notes?: SortOrder
  }

  export type pagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProjectTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProjectTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProjectTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModelEntryListRelationFilter = {
    every?: ModelEntryWhereInput
    some?: ModelEntryWhereInput
    none?: ModelEntryWhereInput
  }

  export type ProjectTypeNullableScalarRelationFilter = {
    is?: ProjectTypeWhereInput | null
    isNot?: ProjectTypeWhereInput | null
  }

  export type ModelEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    businessCode?: SortOrder
    projectCode?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    projectTypeId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    projectTypeId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    businessCode?: SortOrder
    projectCode?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    projectTypeId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    businessCode?: SortOrder
    projectCode?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    projectTypeId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    projectTypeId?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ModelEntryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createDate?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    modifyBy?: SortOrder
    projectId?: SortOrder
  }

  export type ModelEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ModelEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createDate?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    modifyBy?: SortOrder
    projectId?: SortOrder
  }

  export type ModelEntryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createDate?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    modifyBy?: SortOrder
    projectId?: SortOrder
  }

  export type ModelEntrySumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectAssignmentUserIdProjectIdCompoundUniqueInput = {
    userId: number
    projectId: number
  }

  export type ProjectAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
  }

  export type ProjectAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
  }

  export type ProjectAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
  }

  export type ProjectAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type SambaLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    component?: SortOrder
    level?: SortOrder
    message?: SortOrder
    zone?: SortOrder
    name?: SortOrder
    errorCode?: SortOrder
    errorName?: SortOrder
    hostname?: SortOrder
    createdAt?: SortOrder
  }

  export type SambaLogAvgOrderByAggregateInput = {
    id?: SortOrder
    errorCode?: SortOrder
  }

  export type SambaLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    component?: SortOrder
    level?: SortOrder
    message?: SortOrder
    zone?: SortOrder
    name?: SortOrder
    errorCode?: SortOrder
    errorName?: SortOrder
    hostname?: SortOrder
    createdAt?: SortOrder
  }

  export type SambaLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    component?: SortOrder
    level?: SortOrder
    message?: SortOrder
    zone?: SortOrder
    name?: SortOrder
    errorCode?: SortOrder
    errorName?: SortOrder
    hostname?: SortOrder
    createdAt?: SortOrder
  }

  export type SambaLogSumOrderByAggregateInput = {
    id?: SortOrder
    errorCode?: SortOrder
  }

  export type TeamLocationListRelationFilter = {
    every?: TeamLocationWhereInput
    some?: TeamLocationWhereInput
    none?: TeamLocationWhereInput
  }

  export type TeamLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    modifyBy?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    CCY?: SortOrder
    Region?: SortOrder
    Remarks?: SortOrder
    WCI_URL?: SortOrder
    createDate?: SortOrder
    fullname?: SortOrder
  }

  export type locationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    modifyBy?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    CCY?: SortOrder
    Region?: SortOrder
    Remarks?: SortOrder
    WCI_URL?: SortOrder
    createDate?: SortOrder
    fullname?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    modifyBy?: SortOrder
    createBy?: SortOrder
    modifyDate?: SortOrder
    CCY?: SortOrder
    Region?: SortOrder
    Remarks?: SortOrder
    WCI_URL?: SortOrder
    createDate?: SortOrder
    fullname?: SortOrder
  }

  export type locationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ldapuserCountOrderByAggregateInput = {
    dn?: SortOrder
    objectClass?: SortOrder
    cn?: SortOrder
    sn?: SortOrder
    givenName?: SortOrder
    instanceType?: SortOrder
    whenCreated?: SortOrder
    displayName?: SortOrder
    uSNCreated?: SortOrder
    name?: SortOrder
    objectGUID?: SortOrder
    badPwdCount?: SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrder
    lastLogoff?: SortOrder
    lastLogon?: SortOrder
    primaryGroupID?: SortOrder
    objectSid?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrder
    sAMAccountName?: SortOrder
    sAMAccountType?: SortOrder
    userPrincipalName?: SortOrder
    objectCategory?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    distinguishedName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminCount?: SortOrder
    description?: SortOrder
    isCriticalSystemObject?: SortOrder
    memberOf?: SortOrder
    servicePrincipalName?: SortOrder
    showInAdvancedViewOnly?: SortOrder
    id?: SortOrder
  }

  export type ldapuserAvgOrderByAggregateInput = {
    instanceType?: SortOrder
    whenCreated?: SortOrder
    uSNCreated?: SortOrder
    badPwdCount?: SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrder
    lastLogoff?: SortOrder
    lastLogon?: SortOrder
    primaryGroupID?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrder
    sAMAccountType?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    adminCount?: SortOrder
    id?: SortOrder
  }

  export type ldapuserMaxOrderByAggregateInput = {
    dn?: SortOrder
    cn?: SortOrder
    sn?: SortOrder
    givenName?: SortOrder
    instanceType?: SortOrder
    whenCreated?: SortOrder
    displayName?: SortOrder
    uSNCreated?: SortOrder
    name?: SortOrder
    objectGUID?: SortOrder
    badPwdCount?: SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrder
    lastLogoff?: SortOrder
    lastLogon?: SortOrder
    primaryGroupID?: SortOrder
    objectSid?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrder
    sAMAccountName?: SortOrder
    sAMAccountType?: SortOrder
    userPrincipalName?: SortOrder
    objectCategory?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    distinguishedName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminCount?: SortOrder
    description?: SortOrder
    isCriticalSystemObject?: SortOrder
    memberOf?: SortOrder
    servicePrincipalName?: SortOrder
    showInAdvancedViewOnly?: SortOrder
    id?: SortOrder
  }

  export type ldapuserMinOrderByAggregateInput = {
    dn?: SortOrder
    cn?: SortOrder
    sn?: SortOrder
    givenName?: SortOrder
    instanceType?: SortOrder
    whenCreated?: SortOrder
    displayName?: SortOrder
    uSNCreated?: SortOrder
    name?: SortOrder
    objectGUID?: SortOrder
    badPwdCount?: SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrder
    lastLogoff?: SortOrder
    lastLogon?: SortOrder
    primaryGroupID?: SortOrder
    objectSid?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrder
    sAMAccountName?: SortOrder
    sAMAccountType?: SortOrder
    userPrincipalName?: SortOrder
    objectCategory?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    distinguishedName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminCount?: SortOrder
    description?: SortOrder
    isCriticalSystemObject?: SortOrder
    memberOf?: SortOrder
    servicePrincipalName?: SortOrder
    showInAdvancedViewOnly?: SortOrder
    id?: SortOrder
  }

  export type ldapuserSumOrderByAggregateInput = {
    instanceType?: SortOrder
    whenCreated?: SortOrder
    uSNCreated?: SortOrder
    badPwdCount?: SortOrder
    codePage?: SortOrder
    countryCode?: SortOrder
    badPasswordTime?: SortOrder
    lastLogoff?: SortOrder
    lastLogon?: SortOrder
    primaryGroupID?: SortOrder
    accountExpires?: SortOrder
    logonCount?: SortOrder
    sAMAccountType?: SortOrder
    pwdLastSet?: SortOrder
    userAccountControl?: SortOrder
    whenChanged?: SortOrder
    uSNChanged?: SortOrder
    adminCount?: SortOrder
    id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DriveFolderNullableScalarRelationFilter = {
    is?: DriveFolderWhereInput | null
    isNot?: DriveFolderWhereInput | null
  }

  export type DriveFolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriveFolderAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
  }

  export type DriveFolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriveFolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriveFolderSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
  }

  export type DriveFileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrder
    ownerId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriveFileAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrder
    ownerId?: SortOrder
  }

  export type DriveFileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrder
    ownerId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriveFileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrder
    ownerId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriveFileSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    order?: SortOrder
    folderId?: SortOrder
    ownerId?: SortOrder
  }

  export type DriveFileScalarRelationFilter = {
    is?: DriveFileWhereInput
    isNot?: DriveFileWhereInput
  }

  export type DriveFilePermissionFileIdUserIdCompoundUniqueInput = {
    fileId: number
    userId: number
  }

  export type DriveFilePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
  }

  export type DriveFilePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrder
  }

  export type DriveFilePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
  }

  export type DriveFilePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
  }

  export type DriveFilePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrder
  }

  export type JobTitleCountOrderByAggregateInput = {
    id?: SortOrder
    sn?: SortOrder
    jobTitle?: SortOrder
    abbreviation?: SortOrder
    grade?: SortOrder
    seniorityLevel?: SortOrder
    selectableInStaffCV?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobTitleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    sn?: SortOrder
    jobTitle?: SortOrder
    abbreviation?: SortOrder
    grade?: SortOrder
    seniorityLevel?: SortOrder
    selectableInStaffCV?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobTitleMinOrderByAggregateInput = {
    id?: SortOrder
    sn?: SortOrder
    jobTitle?: SortOrder
    abbreviation?: SortOrder
    grade?: SortOrder
    seniorityLevel?: SortOrder
    selectableInStaffCV?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobTitleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    page?: SortOrder
    loginTime?: SortOrder
  }

  export type UserActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    page?: SortOrder
    loginTime?: SortOrder
  }

  export type UserActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    page?: SortOrder
    loginTime?: SortOrder
  }

  export type UserActivitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    remarks?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    remarks?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    remarks?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamLeaderTeamIdUserIdCompoundUniqueInput = {
    teamId: number
    userId: number
  }

  export type TeamLeaderCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamLeaderAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamLeaderMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamLeaderMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamLeaderSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: number
    userId: number
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type TeamLocationTeamIdLocationIdCompoundUniqueInput = {
    teamId: number
    locationId: number
  }

  export type TeamLocationCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
  }

  export type TeamLocationAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
  }

  export type TeamLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
  }

  export type TeamLocationMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
  }

  export type TeamLocationSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
  }

  export type AuditWorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditWorkflowAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditWorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditWorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditWorkflowSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type AuditWorkflowScalarRelationFilter = {
    is?: AuditWorkflowWhereInput
    isNot?: AuditWorkflowWhereInput
  }

  export type StepLogListRelationFilter = {
    every?: StepLogWhereInput
    some?: StepLogWhereInput
    none?: StepLogWhereInput
  }

  export type StepLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditStepCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    workflowId?: SortOrder
  }

  export type AuditStepAvgOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    assignedToId?: SortOrder
    workflowId?: SortOrder
  }

  export type AuditStepMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    workflowId?: SortOrder
  }

  export type AuditStepMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    workflowId?: SortOrder
  }

  export type AuditStepSumOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    assignedToId?: SortOrder
    workflowId?: SortOrder
  }

  export type EnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type AuditStepScalarRelationFilter = {
    is?: AuditStepWhereInput
    isNot?: AuditStepWhereInput
  }

  export type StepLogCountOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StepLogAvgOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
  }

  export type StepLogMaxOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StepLogMinOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    message?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StepLogSumOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceUserCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutRelatedDeviceInput = {
    create?: XOR<SupportTicketCreateWithoutRelatedDeviceInput, SupportTicketUncheckedCreateWithoutRelatedDeviceInput> | SupportTicketCreateWithoutRelatedDeviceInput[] | SupportTicketUncheckedCreateWithoutRelatedDeviceInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRelatedDeviceInput | SupportTicketCreateOrConnectWithoutRelatedDeviceInput[]
    createMany?: SupportTicketCreateManyRelatedDeviceInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutRelatedDeviceInput = {
    create?: XOR<SupportTicketCreateWithoutRelatedDeviceInput, SupportTicketUncheckedCreateWithoutRelatedDeviceInput> | SupportTicketCreateWithoutRelatedDeviceInput[] | SupportTicketUncheckedCreateWithoutRelatedDeviceInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRelatedDeviceInput | SupportTicketCreateOrConnectWithoutRelatedDeviceInput[]
    createMany?: SupportTicketCreateManyRelatedDeviceInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type DeviceUserUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceUserUpsertWithWhereUniqueWithoutDeviceInput | DeviceUserUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    disconnect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    delete?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    update?: DeviceUserUpdateWithWhereUniqueWithoutDeviceInput | DeviceUserUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceUserUpdateManyWithWhereWithoutDeviceInput | DeviceUserUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutRelatedDeviceNestedInput = {
    create?: XOR<SupportTicketCreateWithoutRelatedDeviceInput, SupportTicketUncheckedCreateWithoutRelatedDeviceInput> | SupportTicketCreateWithoutRelatedDeviceInput[] | SupportTicketUncheckedCreateWithoutRelatedDeviceInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRelatedDeviceInput | SupportTicketCreateOrConnectWithoutRelatedDeviceInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutRelatedDeviceInput | SupportTicketUpsertWithWhereUniqueWithoutRelatedDeviceInput[]
    createMany?: SupportTicketCreateManyRelatedDeviceInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutRelatedDeviceInput | SupportTicketUpdateWithWhereUniqueWithoutRelatedDeviceInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutRelatedDeviceInput | SupportTicketUpdateManyWithWhereWithoutRelatedDeviceInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceUserUpsertWithWhereUniqueWithoutDeviceInput | DeviceUserUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    disconnect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    delete?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    update?: DeviceUserUpdateWithWhereUniqueWithoutDeviceInput | DeviceUserUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceUserUpdateManyWithWhereWithoutDeviceInput | DeviceUserUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutRelatedDeviceNestedInput = {
    create?: XOR<SupportTicketCreateWithoutRelatedDeviceInput, SupportTicketUncheckedCreateWithoutRelatedDeviceInput> | SupportTicketCreateWithoutRelatedDeviceInput[] | SupportTicketUncheckedCreateWithoutRelatedDeviceInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRelatedDeviceInput | SupportTicketCreateOrConnectWithoutRelatedDeviceInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutRelatedDeviceInput | SupportTicketUpsertWithWhereUniqueWithoutRelatedDeviceInput[]
    createMany?: SupportTicketCreateManyRelatedDeviceInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutRelatedDeviceInput | SupportTicketUpdateWithWhereUniqueWithoutRelatedDeviceInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutRelatedDeviceInput | SupportTicketUpdateManyWithWhereWithoutRelatedDeviceInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type devicesCreateNestedOneWithoutUsersInput = {
    create?: XOR<devicesCreateWithoutUsersInput, devicesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: devicesCreateOrConnectWithoutUsersInput
    connect?: devicesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type devicesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<devicesCreateWithoutUsersInput, devicesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: devicesCreateOrConnectWithoutUsersInput
    upsert?: devicesUpsertWithoutUsersInput
    connect?: devicesWhereUniqueInput
    update?: XOR<XOR<devicesUpdateToOneWithWhereWithoutUsersInput, devicesUpdateWithoutUsersInput>, devicesUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevicesInput, UserUpdateWithoutDevicesInput>, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type EmailTemplateCreateNestedOneWithoutCommandInput = {
    create?: XOR<EmailTemplateCreateWithoutCommandInput, EmailTemplateUncheckedCreateWithoutCommandInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCommandInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type RuleCreateNestedOneWithoutCommandsInput = {
    create?: XOR<RuleCreateWithoutCommandsInput, RuleUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: RuleCreateOrConnectWithoutCommandsInput
    connect?: RuleWhereUniqueInput
  }

  export type CommandMatchCreateNestedManyWithoutCommandInput = {
    create?: XOR<CommandMatchCreateWithoutCommandInput, CommandMatchUncheckedCreateWithoutCommandInput> | CommandMatchCreateWithoutCommandInput[] | CommandMatchUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutCommandInput | CommandMatchCreateOrConnectWithoutCommandInput[]
    createMany?: CommandMatchCreateManyCommandInputEnvelope
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type CommandMatchUncheckedCreateNestedManyWithoutCommandInput = {
    create?: XOR<CommandMatchCreateWithoutCommandInput, CommandMatchUncheckedCreateWithoutCommandInput> | CommandMatchCreateWithoutCommandInput[] | CommandMatchUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutCommandInput | CommandMatchCreateOrConnectWithoutCommandInput[]
    createMany?: CommandMatchCreateManyCommandInputEnvelope
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type EmailTemplateUpdateOneWithoutCommandNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCommandInput, EmailTemplateUncheckedCreateWithoutCommandInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCommandInput
    upsert?: EmailTemplateUpsertWithoutCommandInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutCommandInput, EmailTemplateUpdateWithoutCommandInput>, EmailTemplateUncheckedUpdateWithoutCommandInput>
  }

  export type RuleUpdateOneRequiredWithoutCommandsNestedInput = {
    create?: XOR<RuleCreateWithoutCommandsInput, RuleUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: RuleCreateOrConnectWithoutCommandsInput
    upsert?: RuleUpsertWithoutCommandsInput
    connect?: RuleWhereUniqueInput
    update?: XOR<XOR<RuleUpdateToOneWithWhereWithoutCommandsInput, RuleUpdateWithoutCommandsInput>, RuleUncheckedUpdateWithoutCommandsInput>
  }

  export type CommandMatchUpdateManyWithoutCommandNestedInput = {
    create?: XOR<CommandMatchCreateWithoutCommandInput, CommandMatchUncheckedCreateWithoutCommandInput> | CommandMatchCreateWithoutCommandInput[] | CommandMatchUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutCommandInput | CommandMatchCreateOrConnectWithoutCommandInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutCommandInput | CommandMatchUpsertWithWhereUniqueWithoutCommandInput[]
    createMany?: CommandMatchCreateManyCommandInputEnvelope
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutCommandInput | CommandMatchUpdateWithWhereUniqueWithoutCommandInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutCommandInput | CommandMatchUpdateManyWithWhereWithoutCommandInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type CommandMatchUncheckedUpdateManyWithoutCommandNestedInput = {
    create?: XOR<CommandMatchCreateWithoutCommandInput, CommandMatchUncheckedCreateWithoutCommandInput> | CommandMatchCreateWithoutCommandInput[] | CommandMatchUncheckedCreateWithoutCommandInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutCommandInput | CommandMatchCreateOrConnectWithoutCommandInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutCommandInput | CommandMatchUpsertWithWhereUniqueWithoutCommandInput[]
    createMany?: CommandMatchCreateManyCommandInputEnvelope
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutCommandInput | CommandMatchUpdateWithWhereUniqueWithoutCommandInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutCommandInput | CommandMatchUpdateManyWithWhereWithoutCommandInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type CommandCreateNestedManyWithoutRuleInput = {
    create?: XOR<CommandCreateWithoutRuleInput, CommandUncheckedCreateWithoutRuleInput> | CommandCreateWithoutRuleInput[] | CommandUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRuleInput | CommandCreateOrConnectWithoutRuleInput[]
    createMany?: CommandCreateManyRuleInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type CommandMatchCreateNestedManyWithoutRuleInput = {
    create?: XOR<CommandMatchCreateWithoutRuleInput, CommandMatchUncheckedCreateWithoutRuleInput> | CommandMatchCreateWithoutRuleInput[] | CommandMatchUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutRuleInput | CommandMatchCreateOrConnectWithoutRuleInput[]
    createMany?: CommandMatchCreateManyRuleInputEnvelope
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutRuleInput = {
    create?: XOR<EmailTemplateCreateWithoutRuleInput, EmailTemplateUncheckedCreateWithoutRuleInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutRuleInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type RuleGroupCreateNestedOneWithoutRulesInput = {
    create?: XOR<RuleGroupCreateWithoutRulesInput, RuleGroupUncheckedCreateWithoutRulesInput>
    connectOrCreate?: RuleGroupCreateOrConnectWithoutRulesInput
    connect?: RuleGroupWhereUniqueInput
  }

  export type CommandUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<CommandCreateWithoutRuleInput, CommandUncheckedCreateWithoutRuleInput> | CommandCreateWithoutRuleInput[] | CommandUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRuleInput | CommandCreateOrConnectWithoutRuleInput[]
    createMany?: CommandCreateManyRuleInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type CommandMatchUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<CommandMatchCreateWithoutRuleInput, CommandMatchUncheckedCreateWithoutRuleInput> | CommandMatchCreateWithoutRuleInput[] | CommandMatchUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutRuleInput | CommandMatchCreateOrConnectWithoutRuleInput[]
    createMany?: CommandMatchCreateManyRuleInputEnvelope
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type CommandUpdateManyWithoutRuleNestedInput = {
    create?: XOR<CommandCreateWithoutRuleInput, CommandUncheckedCreateWithoutRuleInput> | CommandCreateWithoutRuleInput[] | CommandUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRuleInput | CommandCreateOrConnectWithoutRuleInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutRuleInput | CommandUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: CommandCreateManyRuleInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutRuleInput | CommandUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutRuleInput | CommandUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type CommandMatchUpdateManyWithoutRuleNestedInput = {
    create?: XOR<CommandMatchCreateWithoutRuleInput, CommandMatchUncheckedCreateWithoutRuleInput> | CommandMatchCreateWithoutRuleInput[] | CommandMatchUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutRuleInput | CommandMatchCreateOrConnectWithoutRuleInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutRuleInput | CommandMatchUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: CommandMatchCreateManyRuleInputEnvelope
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutRuleInput | CommandMatchUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutRuleInput | CommandMatchUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type EmailTemplateUpdateOneWithoutRuleNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutRuleInput, EmailTemplateUncheckedCreateWithoutRuleInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutRuleInput
    upsert?: EmailTemplateUpsertWithoutRuleInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutRuleInput, EmailTemplateUpdateWithoutRuleInput>, EmailTemplateUncheckedUpdateWithoutRuleInput>
  }

  export type RuleGroupUpdateOneWithoutRulesNestedInput = {
    create?: XOR<RuleGroupCreateWithoutRulesInput, RuleGroupUncheckedCreateWithoutRulesInput>
    connectOrCreate?: RuleGroupCreateOrConnectWithoutRulesInput
    upsert?: RuleGroupUpsertWithoutRulesInput
    disconnect?: RuleGroupWhereInput | boolean
    delete?: RuleGroupWhereInput | boolean
    connect?: RuleGroupWhereUniqueInput
    update?: XOR<XOR<RuleGroupUpdateToOneWithWhereWithoutRulesInput, RuleGroupUpdateWithoutRulesInput>, RuleGroupUncheckedUpdateWithoutRulesInput>
  }

  export type CommandUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<CommandCreateWithoutRuleInput, CommandUncheckedCreateWithoutRuleInput> | CommandCreateWithoutRuleInput[] | CommandUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRuleInput | CommandCreateOrConnectWithoutRuleInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutRuleInput | CommandUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: CommandCreateManyRuleInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutRuleInput | CommandUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutRuleInput | CommandUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type CommandMatchUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<CommandMatchCreateWithoutRuleInput, CommandMatchUncheckedCreateWithoutRuleInput> | CommandMatchCreateWithoutRuleInput[] | CommandMatchUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutRuleInput | CommandMatchCreateOrConnectWithoutRuleInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutRuleInput | CommandMatchUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: CommandMatchCreateManyRuleInputEnvelope
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutRuleInput | CommandMatchUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutRuleInput | CommandMatchUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type RuleCreateNestedManyWithoutGroupInput = {
    create?: XOR<RuleCreateWithoutGroupInput, RuleUncheckedCreateWithoutGroupInput> | RuleCreateWithoutGroupInput[] | RuleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutGroupInput | RuleCreateOrConnectWithoutGroupInput[]
    createMany?: RuleCreateManyGroupInputEnvelope
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutRuleGroupInput = {
    create?: XOR<EmailTemplateCreateWithoutRuleGroupInput, EmailTemplateUncheckedCreateWithoutRuleGroupInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutRuleGroupInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type RuleUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<RuleCreateWithoutGroupInput, RuleUncheckedCreateWithoutGroupInput> | RuleCreateWithoutGroupInput[] | RuleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutGroupInput | RuleCreateOrConnectWithoutGroupInput[]
    createMany?: RuleCreateManyGroupInputEnvelope
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
  }

  export type RuleUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RuleCreateWithoutGroupInput, RuleUncheckedCreateWithoutGroupInput> | RuleCreateWithoutGroupInput[] | RuleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutGroupInput | RuleCreateOrConnectWithoutGroupInput[]
    upsert?: RuleUpsertWithWhereUniqueWithoutGroupInput | RuleUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RuleCreateManyGroupInputEnvelope
    set?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    disconnect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    delete?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    update?: RuleUpdateWithWhereUniqueWithoutGroupInput | RuleUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RuleUpdateManyWithWhereWithoutGroupInput | RuleUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RuleScalarWhereInput | RuleScalarWhereInput[]
  }

  export type EmailTemplateUpdateOneWithoutRuleGroupNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutRuleGroupInput, EmailTemplateUncheckedCreateWithoutRuleGroupInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutRuleGroupInput
    upsert?: EmailTemplateUpsertWithoutRuleGroupInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutRuleGroupInput, EmailTemplateUpdateWithoutRuleGroupInput>, EmailTemplateUncheckedUpdateWithoutRuleGroupInput>
  }

  export type RuleUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RuleCreateWithoutGroupInput, RuleUncheckedCreateWithoutGroupInput> | RuleCreateWithoutGroupInput[] | RuleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutGroupInput | RuleCreateOrConnectWithoutGroupInput[]
    upsert?: RuleUpsertWithWhereUniqueWithoutGroupInput | RuleUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RuleCreateManyGroupInputEnvelope
    set?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    disconnect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    delete?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    update?: RuleUpdateWithWhereUniqueWithoutGroupInput | RuleUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RuleUpdateManyWithWhereWithoutGroupInput | RuleUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RuleScalarWhereInput | RuleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCommandMatchInput = {
    create?: XOR<UserCreateWithoutCommandMatchInput, UserUncheckedCreateWithoutCommandMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandMatchInput
    connect?: UserWhereUniqueInput
  }

  export type CommandCreateNestedOneWithoutMatchesInput = {
    create?: XOR<CommandCreateWithoutMatchesInput, CommandUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: CommandCreateOrConnectWithoutMatchesInput
    connect?: CommandWhereUniqueInput
  }

  export type RuleCreateNestedOneWithoutMatchesInput = {
    create?: XOR<RuleCreateWithoutMatchesInput, RuleUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: RuleCreateOrConnectWithoutMatchesInput
    connect?: RuleWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAddressedMatchesInput = {
    create?: XOR<UserCreateWithoutAddressedMatchesInput, UserUncheckedCreateWithoutAddressedMatchesInput> | UserCreateWithoutAddressedMatchesInput[] | UserUncheckedCreateWithoutAddressedMatchesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressedMatchesInput | UserCreateOrConnectWithoutAddressedMatchesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAddressedMatchesInput = {
    create?: XOR<UserCreateWithoutAddressedMatchesInput, UserUncheckedCreateWithoutAddressedMatchesInput> | UserCreateWithoutAddressedMatchesInput[] | UserUncheckedCreateWithoutAddressedMatchesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressedMatchesInput | UserCreateOrConnectWithoutAddressedMatchesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutCommandMatchNestedInput = {
    create?: XOR<UserCreateWithoutCommandMatchInput, UserUncheckedCreateWithoutCommandMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandMatchInput
    upsert?: UserUpsertWithoutCommandMatchInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommandMatchInput, UserUpdateWithoutCommandMatchInput>, UserUncheckedUpdateWithoutCommandMatchInput>
  }

  export type CommandUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<CommandCreateWithoutMatchesInput, CommandUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: CommandCreateOrConnectWithoutMatchesInput
    upsert?: CommandUpsertWithoutMatchesInput
    connect?: CommandWhereUniqueInput
    update?: XOR<XOR<CommandUpdateToOneWithWhereWithoutMatchesInput, CommandUpdateWithoutMatchesInput>, CommandUncheckedUpdateWithoutMatchesInput>
  }

  export type RuleUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<RuleCreateWithoutMatchesInput, RuleUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: RuleCreateOrConnectWithoutMatchesInput
    upsert?: RuleUpsertWithoutMatchesInput
    connect?: RuleWhereUniqueInput
    update?: XOR<XOR<RuleUpdateToOneWithWhereWithoutMatchesInput, RuleUpdateWithoutMatchesInput>, RuleUncheckedUpdateWithoutMatchesInput>
  }

  export type UserUpdateManyWithoutAddressedMatchesNestedInput = {
    create?: XOR<UserCreateWithoutAddressedMatchesInput, UserUncheckedCreateWithoutAddressedMatchesInput> | UserCreateWithoutAddressedMatchesInput[] | UserUncheckedCreateWithoutAddressedMatchesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressedMatchesInput | UserCreateOrConnectWithoutAddressedMatchesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAddressedMatchesInput | UserUpsertWithWhereUniqueWithoutAddressedMatchesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAddressedMatchesInput | UserUpdateWithWhereUniqueWithoutAddressedMatchesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAddressedMatchesInput | UserUpdateManyWithWhereWithoutAddressedMatchesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAddressedMatchesNestedInput = {
    create?: XOR<UserCreateWithoutAddressedMatchesInput, UserUncheckedCreateWithoutAddressedMatchesInput> | UserCreateWithoutAddressedMatchesInput[] | UserUncheckedCreateWithoutAddressedMatchesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddressedMatchesInput | UserCreateOrConnectWithoutAddressedMatchesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAddressedMatchesInput | UserUpsertWithWhereUniqueWithoutAddressedMatchesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAddressedMatchesInput | UserUpdateWithWhereUniqueWithoutAddressedMatchesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAddressedMatchesInput | UserUpdateManyWithWhereWithoutAddressedMatchesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogInput
    upsert?: UserUpsertWithoutActivityLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogInput, UserUpdateWithoutActivityLogInput>, UserUncheckedUpdateWithoutActivityLogInput>
  }

  export type AlertConditionCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<AlertConditionCreateWithoutEmailTemplateInput, AlertConditionUncheckedCreateWithoutEmailTemplateInput> | AlertConditionCreateWithoutEmailTemplateInput[] | AlertConditionUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: AlertConditionCreateOrConnectWithoutEmailTemplateInput | AlertConditionCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: AlertConditionCreateManyEmailTemplateInputEnvelope
    connect?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
  }

  export type CommandCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<CommandCreateWithoutEmailTemplateInput, CommandUncheckedCreateWithoutEmailTemplateInput> | CommandCreateWithoutEmailTemplateInput[] | CommandUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutEmailTemplateInput | CommandCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: CommandCreateManyEmailTemplateInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type RuleCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<RuleCreateWithoutEmailTemplateInput, RuleUncheckedCreateWithoutEmailTemplateInput> | RuleCreateWithoutEmailTemplateInput[] | RuleUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutEmailTemplateInput | RuleCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: RuleCreateManyEmailTemplateInputEnvelope
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
  }

  export type RuleGroupCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<RuleGroupCreateWithoutEmailTemplateInput, RuleGroupUncheckedCreateWithoutEmailTemplateInput> | RuleGroupCreateWithoutEmailTemplateInput[] | RuleGroupUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleGroupCreateOrConnectWithoutEmailTemplateInput | RuleGroupCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: RuleGroupCreateManyEmailTemplateInputEnvelope
    connect?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
  }

  export type SavedQueryCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<SavedQueryCreateWithoutEmailTemplateInput, SavedQueryUncheckedCreateWithoutEmailTemplateInput> | SavedQueryCreateWithoutEmailTemplateInput[] | SavedQueryUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: SavedQueryCreateOrConnectWithoutEmailTemplateInput | SavedQueryCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: SavedQueryCreateManyEmailTemplateInputEnvelope
    connect?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
  }

  export type UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<UserEmailTemplateCreateWithoutEmailTemplateInput, UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput> | UserEmailTemplateCreateWithoutEmailTemplateInput[] | UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput | UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: UserEmailTemplateCreateManyEmailTemplateInputEnvelope
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
  }

  export type AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<AlertConditionCreateWithoutEmailTemplateInput, AlertConditionUncheckedCreateWithoutEmailTemplateInput> | AlertConditionCreateWithoutEmailTemplateInput[] | AlertConditionUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: AlertConditionCreateOrConnectWithoutEmailTemplateInput | AlertConditionCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: AlertConditionCreateManyEmailTemplateInputEnvelope
    connect?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
  }

  export type CommandUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<CommandCreateWithoutEmailTemplateInput, CommandUncheckedCreateWithoutEmailTemplateInput> | CommandCreateWithoutEmailTemplateInput[] | CommandUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutEmailTemplateInput | CommandCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: CommandCreateManyEmailTemplateInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type RuleUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<RuleCreateWithoutEmailTemplateInput, RuleUncheckedCreateWithoutEmailTemplateInput> | RuleCreateWithoutEmailTemplateInput[] | RuleUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutEmailTemplateInput | RuleCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: RuleCreateManyEmailTemplateInputEnvelope
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
  }

  export type RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<RuleGroupCreateWithoutEmailTemplateInput, RuleGroupUncheckedCreateWithoutEmailTemplateInput> | RuleGroupCreateWithoutEmailTemplateInput[] | RuleGroupUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleGroupCreateOrConnectWithoutEmailTemplateInput | RuleGroupCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: RuleGroupCreateManyEmailTemplateInputEnvelope
    connect?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
  }

  export type SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<SavedQueryCreateWithoutEmailTemplateInput, SavedQueryUncheckedCreateWithoutEmailTemplateInput> | SavedQueryCreateWithoutEmailTemplateInput[] | SavedQueryUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: SavedQueryCreateOrConnectWithoutEmailTemplateInput | SavedQueryCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: SavedQueryCreateManyEmailTemplateInputEnvelope
    connect?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
  }

  export type UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<UserEmailTemplateCreateWithoutEmailTemplateInput, UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput> | UserEmailTemplateCreateWithoutEmailTemplateInput[] | UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput | UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: UserEmailTemplateCreateManyEmailTemplateInputEnvelope
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
  }

  export type AlertConditionUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<AlertConditionCreateWithoutEmailTemplateInput, AlertConditionUncheckedCreateWithoutEmailTemplateInput> | AlertConditionCreateWithoutEmailTemplateInput[] | AlertConditionUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: AlertConditionCreateOrConnectWithoutEmailTemplateInput | AlertConditionCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: AlertConditionUpsertWithWhereUniqueWithoutEmailTemplateInput | AlertConditionUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: AlertConditionCreateManyEmailTemplateInputEnvelope
    set?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    disconnect?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    delete?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    connect?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    update?: AlertConditionUpdateWithWhereUniqueWithoutEmailTemplateInput | AlertConditionUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: AlertConditionUpdateManyWithWhereWithoutEmailTemplateInput | AlertConditionUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: AlertConditionScalarWhereInput | AlertConditionScalarWhereInput[]
  }

  export type CommandUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<CommandCreateWithoutEmailTemplateInput, CommandUncheckedCreateWithoutEmailTemplateInput> | CommandCreateWithoutEmailTemplateInput[] | CommandUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutEmailTemplateInput | CommandCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutEmailTemplateInput | CommandUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: CommandCreateManyEmailTemplateInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutEmailTemplateInput | CommandUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutEmailTemplateInput | CommandUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type RuleUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<RuleCreateWithoutEmailTemplateInput, RuleUncheckedCreateWithoutEmailTemplateInput> | RuleCreateWithoutEmailTemplateInput[] | RuleUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutEmailTemplateInput | RuleCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: RuleUpsertWithWhereUniqueWithoutEmailTemplateInput | RuleUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: RuleCreateManyEmailTemplateInputEnvelope
    set?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    disconnect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    delete?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    update?: RuleUpdateWithWhereUniqueWithoutEmailTemplateInput | RuleUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: RuleUpdateManyWithWhereWithoutEmailTemplateInput | RuleUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: RuleScalarWhereInput | RuleScalarWhereInput[]
  }

  export type RuleGroupUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<RuleGroupCreateWithoutEmailTemplateInput, RuleGroupUncheckedCreateWithoutEmailTemplateInput> | RuleGroupCreateWithoutEmailTemplateInput[] | RuleGroupUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleGroupCreateOrConnectWithoutEmailTemplateInput | RuleGroupCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: RuleGroupUpsertWithWhereUniqueWithoutEmailTemplateInput | RuleGroupUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: RuleGroupCreateManyEmailTemplateInputEnvelope
    set?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    disconnect?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    delete?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    connect?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    update?: RuleGroupUpdateWithWhereUniqueWithoutEmailTemplateInput | RuleGroupUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: RuleGroupUpdateManyWithWhereWithoutEmailTemplateInput | RuleGroupUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: RuleGroupScalarWhereInput | RuleGroupScalarWhereInput[]
  }

  export type SavedQueryUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<SavedQueryCreateWithoutEmailTemplateInput, SavedQueryUncheckedCreateWithoutEmailTemplateInput> | SavedQueryCreateWithoutEmailTemplateInput[] | SavedQueryUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: SavedQueryCreateOrConnectWithoutEmailTemplateInput | SavedQueryCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: SavedQueryUpsertWithWhereUniqueWithoutEmailTemplateInput | SavedQueryUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: SavedQueryCreateManyEmailTemplateInputEnvelope
    set?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    disconnect?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    delete?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    connect?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    update?: SavedQueryUpdateWithWhereUniqueWithoutEmailTemplateInput | SavedQueryUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: SavedQueryUpdateManyWithWhereWithoutEmailTemplateInput | SavedQueryUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: SavedQueryScalarWhereInput | SavedQueryScalarWhereInput[]
  }

  export type UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<UserEmailTemplateCreateWithoutEmailTemplateInput, UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput> | UserEmailTemplateCreateWithoutEmailTemplateInput[] | UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput | UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: UserEmailTemplateUpsertWithWhereUniqueWithoutEmailTemplateInput | UserEmailTemplateUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: UserEmailTemplateCreateManyEmailTemplateInputEnvelope
    set?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    disconnect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    delete?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    update?: UserEmailTemplateUpdateWithWhereUniqueWithoutEmailTemplateInput | UserEmailTemplateUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: UserEmailTemplateUpdateManyWithWhereWithoutEmailTemplateInput | UserEmailTemplateUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: UserEmailTemplateScalarWhereInput | UserEmailTemplateScalarWhereInput[]
  }

  export type AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<AlertConditionCreateWithoutEmailTemplateInput, AlertConditionUncheckedCreateWithoutEmailTemplateInput> | AlertConditionCreateWithoutEmailTemplateInput[] | AlertConditionUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: AlertConditionCreateOrConnectWithoutEmailTemplateInput | AlertConditionCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: AlertConditionUpsertWithWhereUniqueWithoutEmailTemplateInput | AlertConditionUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: AlertConditionCreateManyEmailTemplateInputEnvelope
    set?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    disconnect?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    delete?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    connect?: AlertConditionWhereUniqueInput | AlertConditionWhereUniqueInput[]
    update?: AlertConditionUpdateWithWhereUniqueWithoutEmailTemplateInput | AlertConditionUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: AlertConditionUpdateManyWithWhereWithoutEmailTemplateInput | AlertConditionUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: AlertConditionScalarWhereInput | AlertConditionScalarWhereInput[]
  }

  export type CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<CommandCreateWithoutEmailTemplateInput, CommandUncheckedCreateWithoutEmailTemplateInput> | CommandCreateWithoutEmailTemplateInput[] | CommandUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutEmailTemplateInput | CommandCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutEmailTemplateInput | CommandUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: CommandCreateManyEmailTemplateInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutEmailTemplateInput | CommandUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutEmailTemplateInput | CommandUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<RuleCreateWithoutEmailTemplateInput, RuleUncheckedCreateWithoutEmailTemplateInput> | RuleCreateWithoutEmailTemplateInput[] | RuleUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleCreateOrConnectWithoutEmailTemplateInput | RuleCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: RuleUpsertWithWhereUniqueWithoutEmailTemplateInput | RuleUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: RuleCreateManyEmailTemplateInputEnvelope
    set?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    disconnect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    delete?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    connect?: RuleWhereUniqueInput | RuleWhereUniqueInput[]
    update?: RuleUpdateWithWhereUniqueWithoutEmailTemplateInput | RuleUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: RuleUpdateManyWithWhereWithoutEmailTemplateInput | RuleUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: RuleScalarWhereInput | RuleScalarWhereInput[]
  }

  export type RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<RuleGroupCreateWithoutEmailTemplateInput, RuleGroupUncheckedCreateWithoutEmailTemplateInput> | RuleGroupCreateWithoutEmailTemplateInput[] | RuleGroupUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: RuleGroupCreateOrConnectWithoutEmailTemplateInput | RuleGroupCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: RuleGroupUpsertWithWhereUniqueWithoutEmailTemplateInput | RuleGroupUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: RuleGroupCreateManyEmailTemplateInputEnvelope
    set?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    disconnect?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    delete?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    connect?: RuleGroupWhereUniqueInput | RuleGroupWhereUniqueInput[]
    update?: RuleGroupUpdateWithWhereUniqueWithoutEmailTemplateInput | RuleGroupUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: RuleGroupUpdateManyWithWhereWithoutEmailTemplateInput | RuleGroupUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: RuleGroupScalarWhereInput | RuleGroupScalarWhereInput[]
  }

  export type SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<SavedQueryCreateWithoutEmailTemplateInput, SavedQueryUncheckedCreateWithoutEmailTemplateInput> | SavedQueryCreateWithoutEmailTemplateInput[] | SavedQueryUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: SavedQueryCreateOrConnectWithoutEmailTemplateInput | SavedQueryCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: SavedQueryUpsertWithWhereUniqueWithoutEmailTemplateInput | SavedQueryUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: SavedQueryCreateManyEmailTemplateInputEnvelope
    set?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    disconnect?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    delete?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    connect?: SavedQueryWhereUniqueInput | SavedQueryWhereUniqueInput[]
    update?: SavedQueryUpdateWithWhereUniqueWithoutEmailTemplateInput | SavedQueryUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: SavedQueryUpdateManyWithWhereWithoutEmailTemplateInput | SavedQueryUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: SavedQueryScalarWhereInput | SavedQueryScalarWhereInput[]
  }

  export type UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<UserEmailTemplateCreateWithoutEmailTemplateInput, UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput> | UserEmailTemplateCreateWithoutEmailTemplateInput[] | UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput | UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: UserEmailTemplateUpsertWithWhereUniqueWithoutEmailTemplateInput | UserEmailTemplateUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: UserEmailTemplateCreateManyEmailTemplateInputEnvelope
    set?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    disconnect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    delete?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    update?: UserEmailTemplateUpdateWithWhereUniqueWithoutEmailTemplateInput | UserEmailTemplateUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: UserEmailTemplateUpdateManyWithWhereWithoutEmailTemplateInput | UserEmailTemplateUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: UserEmailTemplateScalarWhereInput | UserEmailTemplateScalarWhereInput[]
  }

  export type UserCreateroleInput = {
    set: string[]
  }

  export type UserCreatelocationInput = {
    set: string[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type CommandMatchCreateNestedManyWithoutAddressedByUserInput = {
    create?: XOR<CommandMatchCreateWithoutAddressedByUserInput, CommandMatchUncheckedCreateWithoutAddressedByUserInput> | CommandMatchCreateWithoutAddressedByUserInput[] | CommandMatchUncheckedCreateWithoutAddressedByUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutAddressedByUserInput | CommandMatchCreateOrConnectWithoutAddressedByUserInput[]
    createMany?: CommandMatchCreateManyAddressedByUserInputEnvelope
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type DeviceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput> | DeviceUserCreateWithoutUserInput[] | DeviceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutUserInput | DeviceUserCreateOrConnectWithoutUserInput[]
    createMany?: DeviceUserCreateManyUserInputEnvelope
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
  }

  export type DriveFileCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DriveFileCreateWithoutOwnerInput, DriveFileUncheckedCreateWithoutOwnerInput> | DriveFileCreateWithoutOwnerInput[] | DriveFileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutOwnerInput | DriveFileCreateOrConnectWithoutOwnerInput[]
    createMany?: DriveFileCreateManyOwnerInputEnvelope
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
  }

  export type DriveFilePermissionCreateNestedManyWithoutGranterInput = {
    create?: XOR<DriveFilePermissionCreateWithoutGranterInput, DriveFilePermissionUncheckedCreateWithoutGranterInput> | DriveFilePermissionCreateWithoutGranterInput[] | DriveFilePermissionUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutGranterInput | DriveFilePermissionCreateOrConnectWithoutGranterInput[]
    createMany?: DriveFilePermissionCreateManyGranterInputEnvelope
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type DriveFilePermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    createMany?: DriveFilePermissionCreateManyUserInputEnvelope
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type DriveFolderCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DriveFolderCreateWithoutOwnerInput, DriveFolderUncheckedCreateWithoutOwnerInput> | DriveFolderCreateWithoutOwnerInput[] | DriveFolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutOwnerInput | DriveFolderCreateOrConnectWithoutOwnerInput[]
    createMany?: DriveFolderCreateManyOwnerInputEnvelope
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutSenderInput = {
    create?: XOR<FeedbackCreateWithoutSenderInput, FeedbackUncheckedCreateWithoutSenderInput> | FeedbackCreateWithoutSenderInput[] | FeedbackUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutSenderInput | FeedbackCreateOrConnectWithoutSenderInput[]
    createMany?: FeedbackCreateManySenderInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackRecipientCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackRecipientCreateWithoutUserInput, FeedbackRecipientUncheckedCreateWithoutUserInput> | FeedbackRecipientCreateWithoutUserInput[] | FeedbackRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutUserInput | FeedbackRecipientCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackRecipientCreateManyUserInputEnvelope
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationReadCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type ProjectAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectAssignmentCreateWithoutUserInput, ProjectAssignmentUncheckedCreateWithoutUserInput> | ProjectAssignmentCreateWithoutUserInput[] | ProjectAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutUserInput | ProjectAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: ProjectAssignmentCreateManyUserInputEnvelope
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SupportTicketCreateWithoutCreatedByInput, SupportTicketUncheckedCreateWithoutCreatedByInput> | SupportTicketCreateWithoutCreatedByInput[] | SupportTicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCreatedByInput | SupportTicketCreateOrConnectWithoutCreatedByInput[]
    createMany?: SupportTicketCreateManyCreatedByInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type TeamLeaderCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamLeaderCreateWithoutUserInput, TeamLeaderUncheckedCreateWithoutUserInput> | TeamLeaderCreateWithoutUserInput[] | TeamLeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutUserInput | TeamLeaderCreateOrConnectWithoutUserInput[]
    createMany?: TeamLeaderCreateManyUserInputEnvelope
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TicketAttachmentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploaderInput, TicketAttachmentUncheckedCreateWithoutUploaderInput> | TicketAttachmentCreateWithoutUploaderInput[] | TicketAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploaderInput | TicketAttachmentCreateOrConnectWithoutUploaderInput[]
    createMany?: TicketAttachmentCreateManyUploaderInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserEmailTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEmailTemplateCreateWithoutUserInput, UserEmailTemplateUncheckedCreateWithoutUserInput> | UserEmailTemplateCreateWithoutUserInput[] | UserEmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutUserInput | UserEmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: UserEmailTemplateCreateManyUserInputEnvelope
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
  }

  export type UserPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type AuditStepCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<AuditStepCreateWithoutAssignedToInput, AuditStepUncheckedCreateWithoutAssignedToInput> | AuditStepCreateWithoutAssignedToInput[] | AuditStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutAssignedToInput | AuditStepCreateOrConnectWithoutAssignedToInput[]
    createMany?: AuditStepCreateManyAssignedToInputEnvelope
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
  }

  export type DriveFilePermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type CommandMatchCreateNestedManyWithoutUserInput = {
    create?: XOR<CommandMatchCreateWithoutUserInput, CommandMatchUncheckedCreateWithoutUserInput> | CommandMatchCreateWithoutUserInput[] | CommandMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutUserInput | CommandMatchCreateOrConnectWithoutUserInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput = {
    create?: XOR<CommandMatchCreateWithoutAddressedByUserInput, CommandMatchUncheckedCreateWithoutAddressedByUserInput> | CommandMatchCreateWithoutAddressedByUserInput[] | CommandMatchUncheckedCreateWithoutAddressedByUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutAddressedByUserInput | CommandMatchCreateOrConnectWithoutAddressedByUserInput[]
    createMany?: CommandMatchCreateManyAddressedByUserInputEnvelope
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput> | DeviceUserCreateWithoutUserInput[] | DeviceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutUserInput | DeviceUserCreateOrConnectWithoutUserInput[]
    createMany?: DeviceUserCreateManyUserInputEnvelope
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
  }

  export type DriveFileUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DriveFileCreateWithoutOwnerInput, DriveFileUncheckedCreateWithoutOwnerInput> | DriveFileCreateWithoutOwnerInput[] | DriveFileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutOwnerInput | DriveFileCreateOrConnectWithoutOwnerInput[]
    createMany?: DriveFileCreateManyOwnerInputEnvelope
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
  }

  export type DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput = {
    create?: XOR<DriveFilePermissionCreateWithoutGranterInput, DriveFilePermissionUncheckedCreateWithoutGranterInput> | DriveFilePermissionCreateWithoutGranterInput[] | DriveFilePermissionUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutGranterInput | DriveFilePermissionCreateOrConnectWithoutGranterInput[]
    createMany?: DriveFilePermissionCreateManyGranterInputEnvelope
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    createMany?: DriveFilePermissionCreateManyUserInputEnvelope
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type DriveFolderUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DriveFolderCreateWithoutOwnerInput, DriveFolderUncheckedCreateWithoutOwnerInput> | DriveFolderCreateWithoutOwnerInput[] | DriveFolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutOwnerInput | DriveFolderCreateOrConnectWithoutOwnerInput[]
    createMany?: DriveFolderCreateManyOwnerInputEnvelope
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<FeedbackCreateWithoutSenderInput, FeedbackUncheckedCreateWithoutSenderInput> | FeedbackCreateWithoutSenderInput[] | FeedbackUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutSenderInput | FeedbackCreateOrConnectWithoutSenderInput[]
    createMany?: FeedbackCreateManySenderInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackRecipientCreateWithoutUserInput, FeedbackRecipientUncheckedCreateWithoutUserInput> | FeedbackRecipientCreateWithoutUserInput[] | FeedbackRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutUserInput | FeedbackRecipientCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackRecipientCreateManyUserInputEnvelope
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectAssignmentCreateWithoutUserInput, ProjectAssignmentUncheckedCreateWithoutUserInput> | ProjectAssignmentCreateWithoutUserInput[] | ProjectAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutUserInput | ProjectAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: ProjectAssignmentCreateManyUserInputEnvelope
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SupportTicketCreateWithoutCreatedByInput, SupportTicketUncheckedCreateWithoutCreatedByInput> | SupportTicketCreateWithoutCreatedByInput[] | SupportTicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCreatedByInput | SupportTicketCreateOrConnectWithoutCreatedByInput[]
    createMany?: SupportTicketCreateManyCreatedByInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type TeamLeaderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamLeaderCreateWithoutUserInput, TeamLeaderUncheckedCreateWithoutUserInput> | TeamLeaderCreateWithoutUserInput[] | TeamLeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutUserInput | TeamLeaderCreateOrConnectWithoutUserInput[]
    createMany?: TeamLeaderCreateManyUserInputEnvelope
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploaderInput, TicketAttachmentUncheckedCreateWithoutUploaderInput> | TicketAttachmentCreateWithoutUploaderInput[] | TicketAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploaderInput | TicketAttachmentCreateOrConnectWithoutUploaderInput[]
    createMany?: TicketAttachmentCreateManyUploaderInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEmailTemplateCreateWithoutUserInput, UserEmailTemplateUncheckedCreateWithoutUserInput> | UserEmailTemplateCreateWithoutUserInput[] | UserEmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutUserInput | UserEmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: UserEmailTemplateCreateManyUserInputEnvelope
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
  }

  export type UserPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type AuditStepUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<AuditStepCreateWithoutAssignedToInput, AuditStepUncheckedCreateWithoutAssignedToInput> | AuditStepCreateWithoutAssignedToInput[] | AuditStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutAssignedToInput | AuditStepCreateOrConnectWithoutAssignedToInput[]
    createMany?: AuditStepCreateManyAssignedToInputEnvelope
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
  }

  export type DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type CommandMatchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommandMatchCreateWithoutUserInput, CommandMatchUncheckedCreateWithoutUserInput> | CommandMatchCreateWithoutUserInput[] | CommandMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutUserInput | CommandMatchCreateOrConnectWithoutUserInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
  }

  export type UserUpdateroleInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatelocationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type CommandMatchUpdateManyWithoutAddressedByUserNestedInput = {
    create?: XOR<CommandMatchCreateWithoutAddressedByUserInput, CommandMatchUncheckedCreateWithoutAddressedByUserInput> | CommandMatchCreateWithoutAddressedByUserInput[] | CommandMatchUncheckedCreateWithoutAddressedByUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutAddressedByUserInput | CommandMatchCreateOrConnectWithoutAddressedByUserInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutAddressedByUserInput | CommandMatchUpsertWithWhereUniqueWithoutAddressedByUserInput[]
    createMany?: CommandMatchCreateManyAddressedByUserInputEnvelope
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutAddressedByUserInput | CommandMatchUpdateWithWhereUniqueWithoutAddressedByUserInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutAddressedByUserInput | CommandMatchUpdateManyWithWhereWithoutAddressedByUserInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type DeviceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput> | DeviceUserCreateWithoutUserInput[] | DeviceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutUserInput | DeviceUserCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUserUpsertWithWhereUniqueWithoutUserInput | DeviceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceUserCreateManyUserInputEnvelope
    set?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    disconnect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    delete?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    update?: DeviceUserUpdateWithWhereUniqueWithoutUserInput | DeviceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUserUpdateManyWithWhereWithoutUserInput | DeviceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
  }

  export type DriveFileUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DriveFileCreateWithoutOwnerInput, DriveFileUncheckedCreateWithoutOwnerInput> | DriveFileCreateWithoutOwnerInput[] | DriveFileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutOwnerInput | DriveFileCreateOrConnectWithoutOwnerInput[]
    upsert?: DriveFileUpsertWithWhereUniqueWithoutOwnerInput | DriveFileUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DriveFileCreateManyOwnerInputEnvelope
    set?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    disconnect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    delete?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    update?: DriveFileUpdateWithWhereUniqueWithoutOwnerInput | DriveFileUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DriveFileUpdateManyWithWhereWithoutOwnerInput | DriveFileUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DriveFileScalarWhereInput | DriveFileScalarWhereInput[]
  }

  export type DriveFilePermissionUpdateManyWithoutGranterNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutGranterInput, DriveFilePermissionUncheckedCreateWithoutGranterInput> | DriveFilePermissionCreateWithoutGranterInput[] | DriveFilePermissionUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutGranterInput | DriveFilePermissionCreateOrConnectWithoutGranterInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutGranterInput | DriveFilePermissionUpsertWithWhereUniqueWithoutGranterInput[]
    createMany?: DriveFilePermissionCreateManyGranterInputEnvelope
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutGranterInput | DriveFilePermissionUpdateWithWhereUniqueWithoutGranterInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutGranterInput | DriveFilePermissionUpdateManyWithWhereWithoutGranterInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type DriveFilePermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput | DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DriveFilePermissionCreateManyUserInputEnvelope
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput | DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutUserInput | DriveFilePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type DriveFolderUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DriveFolderCreateWithoutOwnerInput, DriveFolderUncheckedCreateWithoutOwnerInput> | DriveFolderCreateWithoutOwnerInput[] | DriveFolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutOwnerInput | DriveFolderCreateOrConnectWithoutOwnerInput[]
    upsert?: DriveFolderUpsertWithWhereUniqueWithoutOwnerInput | DriveFolderUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DriveFolderCreateManyOwnerInputEnvelope
    set?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    disconnect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    delete?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    update?: DriveFolderUpdateWithWhereUniqueWithoutOwnerInput | DriveFolderUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DriveFolderUpdateManyWithWhereWithoutOwnerInput | DriveFolderUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DriveFolderScalarWhereInput | DriveFolderScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutSenderNestedInput = {
    create?: XOR<FeedbackCreateWithoutSenderInput, FeedbackUncheckedCreateWithoutSenderInput> | FeedbackCreateWithoutSenderInput[] | FeedbackUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutSenderInput | FeedbackCreateOrConnectWithoutSenderInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutSenderInput | FeedbackUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: FeedbackCreateManySenderInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutSenderInput | FeedbackUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutSenderInput | FeedbackUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackRecipientUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackRecipientCreateWithoutUserInput, FeedbackRecipientUncheckedCreateWithoutUserInput> | FeedbackRecipientCreateWithoutUserInput[] | FeedbackRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutUserInput | FeedbackRecipientCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackRecipientUpsertWithWhereUniqueWithoutUserInput | FeedbackRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackRecipientCreateManyUserInputEnvelope
    set?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    disconnect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    delete?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    update?: FeedbackRecipientUpdateWithWhereUniqueWithoutUserInput | FeedbackRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackRecipientUpdateManyWithWhereWithoutUserInput | FeedbackRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackRecipientScalarWhereInput | FeedbackRecipientScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutUserInput | NotificationReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutUserInput | NotificationReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutUserInput | NotificationReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type ProjectAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectAssignmentCreateWithoutUserInput, ProjectAssignmentUncheckedCreateWithoutUserInput> | ProjectAssignmentCreateWithoutUserInput[] | ProjectAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutUserInput | ProjectAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: ProjectAssignmentUpsertWithWhereUniqueWithoutUserInput | ProjectAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectAssignmentCreateManyUserInputEnvelope
    set?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    disconnect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    delete?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    update?: ProjectAssignmentUpdateWithWhereUniqueWithoutUserInput | ProjectAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectAssignmentUpdateManyWithWhereWithoutUserInput | ProjectAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectAssignmentScalarWhereInput | ProjectAssignmentScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SupportTicketCreateWithoutCreatedByInput, SupportTicketUncheckedCreateWithoutCreatedByInput> | SupportTicketCreateWithoutCreatedByInput[] | SupportTicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCreatedByInput | SupportTicketCreateOrConnectWithoutCreatedByInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutCreatedByInput | SupportTicketUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SupportTicketCreateManyCreatedByInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutCreatedByInput | SupportTicketUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutCreatedByInput | SupportTicketUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TeamLeaderUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamLeaderCreateWithoutUserInput, TeamLeaderUncheckedCreateWithoutUserInput> | TeamLeaderCreateWithoutUserInput[] | TeamLeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutUserInput | TeamLeaderCreateOrConnectWithoutUserInput[]
    upsert?: TeamLeaderUpsertWithWhereUniqueWithoutUserInput | TeamLeaderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamLeaderCreateManyUserInputEnvelope
    set?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    disconnect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    delete?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    update?: TeamLeaderUpdateWithWhereUniqueWithoutUserInput | TeamLeaderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamLeaderUpdateManyWithWhereWithoutUserInput | TeamLeaderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamLeaderScalarWhereInput | TeamLeaderScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TicketAttachmentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploaderInput, TicketAttachmentUncheckedCreateWithoutUploaderInput> | TicketAttachmentCreateWithoutUploaderInput[] | TicketAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploaderInput | TicketAttachmentCreateOrConnectWithoutUploaderInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutUploaderInput | TicketAttachmentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: TicketAttachmentCreateManyUploaderInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutUploaderInput | TicketAttachmentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutUploaderInput | TicketAttachmentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type UserEmailTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEmailTemplateCreateWithoutUserInput, UserEmailTemplateUncheckedCreateWithoutUserInput> | UserEmailTemplateCreateWithoutUserInput[] | UserEmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutUserInput | UserEmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: UserEmailTemplateUpsertWithWhereUniqueWithoutUserInput | UserEmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEmailTemplateCreateManyUserInputEnvelope
    set?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    disconnect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    delete?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    update?: UserEmailTemplateUpdateWithWhereUniqueWithoutUserInput | UserEmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEmailTemplateUpdateManyWithWhereWithoutUserInput | UserEmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEmailTemplateScalarWhereInput | UserEmailTemplateScalarWhereInput[]
  }

  export type UserPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutUserInput | UserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutUserInput | UserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutUserInput | UserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type AuditStepUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<AuditStepCreateWithoutAssignedToInput, AuditStepUncheckedCreateWithoutAssignedToInput> | AuditStepCreateWithoutAssignedToInput[] | AuditStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutAssignedToInput | AuditStepCreateOrConnectWithoutAssignedToInput[]
    upsert?: AuditStepUpsertWithWhereUniqueWithoutAssignedToInput | AuditStepUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: AuditStepCreateManyAssignedToInputEnvelope
    set?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    disconnect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    delete?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    update?: AuditStepUpdateWithWhereUniqueWithoutAssignedToInput | AuditStepUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: AuditStepUpdateManyWithWhereWithoutAssignedToInput | AuditStepUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: AuditStepScalarWhereInput | AuditStepScalarWhereInput[]
  }

  export type DriveFilePermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput | DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput[]
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput | DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutUserInput | DriveFilePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type CommandMatchUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommandMatchCreateWithoutUserInput, CommandMatchUncheckedCreateWithoutUserInput> | CommandMatchCreateWithoutUserInput[] | CommandMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutUserInput | CommandMatchCreateOrConnectWithoutUserInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutUserInput | CommandMatchUpsertWithWhereUniqueWithoutUserInput[]
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutUserInput | CommandMatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutUserInput | CommandMatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput = {
    create?: XOR<CommandMatchCreateWithoutAddressedByUserInput, CommandMatchUncheckedCreateWithoutAddressedByUserInput> | CommandMatchCreateWithoutAddressedByUserInput[] | CommandMatchUncheckedCreateWithoutAddressedByUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutAddressedByUserInput | CommandMatchCreateOrConnectWithoutAddressedByUserInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutAddressedByUserInput | CommandMatchUpsertWithWhereUniqueWithoutAddressedByUserInput[]
    createMany?: CommandMatchCreateManyAddressedByUserInputEnvelope
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutAddressedByUserInput | CommandMatchUpdateWithWhereUniqueWithoutAddressedByUserInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutAddressedByUserInput | CommandMatchUpdateManyWithWhereWithoutAddressedByUserInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type DeviceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput> | DeviceUserCreateWithoutUserInput[] | DeviceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutUserInput | DeviceUserCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUserUpsertWithWhereUniqueWithoutUserInput | DeviceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceUserCreateManyUserInputEnvelope
    set?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    disconnect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    delete?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    update?: DeviceUserUpdateWithWhereUniqueWithoutUserInput | DeviceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUserUpdateManyWithWhereWithoutUserInput | DeviceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
  }

  export type DriveFileUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DriveFileCreateWithoutOwnerInput, DriveFileUncheckedCreateWithoutOwnerInput> | DriveFileCreateWithoutOwnerInput[] | DriveFileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutOwnerInput | DriveFileCreateOrConnectWithoutOwnerInput[]
    upsert?: DriveFileUpsertWithWhereUniqueWithoutOwnerInput | DriveFileUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DriveFileCreateManyOwnerInputEnvelope
    set?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    disconnect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    delete?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    update?: DriveFileUpdateWithWhereUniqueWithoutOwnerInput | DriveFileUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DriveFileUpdateManyWithWhereWithoutOwnerInput | DriveFileUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DriveFileScalarWhereInput | DriveFileScalarWhereInput[]
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutGranterInput, DriveFilePermissionUncheckedCreateWithoutGranterInput> | DriveFilePermissionCreateWithoutGranterInput[] | DriveFilePermissionUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutGranterInput | DriveFilePermissionCreateOrConnectWithoutGranterInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutGranterInput | DriveFilePermissionUpsertWithWhereUniqueWithoutGranterInput[]
    createMany?: DriveFilePermissionCreateManyGranterInputEnvelope
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutGranterInput | DriveFilePermissionUpdateWithWhereUniqueWithoutGranterInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutGranterInput | DriveFilePermissionUpdateManyWithWhereWithoutGranterInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput | DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DriveFilePermissionCreateManyUserInputEnvelope
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput | DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutUserInput | DriveFilePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DriveFolderCreateWithoutOwnerInput, DriveFolderUncheckedCreateWithoutOwnerInput> | DriveFolderCreateWithoutOwnerInput[] | DriveFolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutOwnerInput | DriveFolderCreateOrConnectWithoutOwnerInput[]
    upsert?: DriveFolderUpsertWithWhereUniqueWithoutOwnerInput | DriveFolderUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DriveFolderCreateManyOwnerInputEnvelope
    set?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    disconnect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    delete?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    update?: DriveFolderUpdateWithWhereUniqueWithoutOwnerInput | DriveFolderUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DriveFolderUpdateManyWithWhereWithoutOwnerInput | DriveFolderUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DriveFolderScalarWhereInput | DriveFolderScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<FeedbackCreateWithoutSenderInput, FeedbackUncheckedCreateWithoutSenderInput> | FeedbackCreateWithoutSenderInput[] | FeedbackUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutSenderInput | FeedbackCreateOrConnectWithoutSenderInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutSenderInput | FeedbackUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: FeedbackCreateManySenderInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutSenderInput | FeedbackUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutSenderInput | FeedbackUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackRecipientCreateWithoutUserInput, FeedbackRecipientUncheckedCreateWithoutUserInput> | FeedbackRecipientCreateWithoutUserInput[] | FeedbackRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutUserInput | FeedbackRecipientCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackRecipientUpsertWithWhereUniqueWithoutUserInput | FeedbackRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackRecipientCreateManyUserInputEnvelope
    set?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    disconnect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    delete?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    update?: FeedbackRecipientUpdateWithWhereUniqueWithoutUserInput | FeedbackRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackRecipientUpdateManyWithWhereWithoutUserInput | FeedbackRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackRecipientScalarWhereInput | FeedbackRecipientScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutUserInput | NotificationReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutUserInput | NotificationReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutUserInput | NotificationReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectAssignmentCreateWithoutUserInput, ProjectAssignmentUncheckedCreateWithoutUserInput> | ProjectAssignmentCreateWithoutUserInput[] | ProjectAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutUserInput | ProjectAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: ProjectAssignmentUpsertWithWhereUniqueWithoutUserInput | ProjectAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectAssignmentCreateManyUserInputEnvelope
    set?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    disconnect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    delete?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    update?: ProjectAssignmentUpdateWithWhereUniqueWithoutUserInput | ProjectAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectAssignmentUpdateManyWithWhereWithoutUserInput | ProjectAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectAssignmentScalarWhereInput | ProjectAssignmentScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SupportTicketCreateWithoutCreatedByInput, SupportTicketUncheckedCreateWithoutCreatedByInput> | SupportTicketCreateWithoutCreatedByInput[] | SupportTicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCreatedByInput | SupportTicketCreateOrConnectWithoutCreatedByInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutCreatedByInput | SupportTicketUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SupportTicketCreateManyCreatedByInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutCreatedByInput | SupportTicketUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutCreatedByInput | SupportTicketUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TeamLeaderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamLeaderCreateWithoutUserInput, TeamLeaderUncheckedCreateWithoutUserInput> | TeamLeaderCreateWithoutUserInput[] | TeamLeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutUserInput | TeamLeaderCreateOrConnectWithoutUserInput[]
    upsert?: TeamLeaderUpsertWithWhereUniqueWithoutUserInput | TeamLeaderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamLeaderCreateManyUserInputEnvelope
    set?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    disconnect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    delete?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    update?: TeamLeaderUpdateWithWhereUniqueWithoutUserInput | TeamLeaderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamLeaderUpdateManyWithWhereWithoutUserInput | TeamLeaderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamLeaderScalarWhereInput | TeamLeaderScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploaderInput, TicketAttachmentUncheckedCreateWithoutUploaderInput> | TicketAttachmentCreateWithoutUploaderInput[] | TicketAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploaderInput | TicketAttachmentCreateOrConnectWithoutUploaderInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutUploaderInput | TicketAttachmentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: TicketAttachmentCreateManyUploaderInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutUploaderInput | TicketAttachmentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutUploaderInput | TicketAttachmentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEmailTemplateCreateWithoutUserInput, UserEmailTemplateUncheckedCreateWithoutUserInput> | UserEmailTemplateCreateWithoutUserInput[] | UserEmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailTemplateCreateOrConnectWithoutUserInput | UserEmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: UserEmailTemplateUpsertWithWhereUniqueWithoutUserInput | UserEmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEmailTemplateCreateManyUserInputEnvelope
    set?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    disconnect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    delete?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    connect?: UserEmailTemplateWhereUniqueInput | UserEmailTemplateWhereUniqueInput[]
    update?: UserEmailTemplateUpdateWithWhereUniqueWithoutUserInput | UserEmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEmailTemplateUpdateManyWithWhereWithoutUserInput | UserEmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEmailTemplateScalarWhereInput | UserEmailTemplateScalarWhereInput[]
  }

  export type UserPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutUserInput | UserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutUserInput | UserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutUserInput | UserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<AuditStepCreateWithoutAssignedToInput, AuditStepUncheckedCreateWithoutAssignedToInput> | AuditStepCreateWithoutAssignedToInput[] | AuditStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutAssignedToInput | AuditStepCreateOrConnectWithoutAssignedToInput[]
    upsert?: AuditStepUpsertWithWhereUniqueWithoutAssignedToInput | AuditStepUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: AuditStepCreateManyAssignedToInputEnvelope
    set?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    disconnect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    delete?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    update?: AuditStepUpdateWithWhereUniqueWithoutAssignedToInput | AuditStepUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: AuditStepUpdateManyWithWhereWithoutAssignedToInput | AuditStepUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: AuditStepScalarWhereInput | AuditStepScalarWhereInput[]
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput> | DriveFilePermissionCreateWithoutUserInput[] | DriveFilePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutUserInput | DriveFilePermissionCreateOrConnectWithoutUserInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput | DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput[]
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput | DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutUserInput | DriveFilePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type CommandMatchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommandMatchCreateWithoutUserInput, CommandMatchUncheckedCreateWithoutUserInput> | CommandMatchCreateWithoutUserInput[] | CommandMatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommandMatchCreateOrConnectWithoutUserInput | CommandMatchCreateOrConnectWithoutUserInput[]
    upsert?: CommandMatchUpsertWithWhereUniqueWithoutUserInput | CommandMatchUpsertWithWhereUniqueWithoutUserInput[]
    set?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    disconnect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    delete?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    connect?: CommandMatchWhereUniqueInput | CommandMatchWhereUniqueInput[]
    update?: CommandMatchUpdateWithWhereUniqueWithoutUserInput | CommandMatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommandMatchUpdateManyWithWhereWithoutUserInput | CommandMatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupInput | MessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupInput | MessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupInput | MessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupInput | MessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupInput | MessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupInput | MessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMemberInput = {
    create?: XOR<UserCreateWithoutGroupMemberInput, UserUncheckedCreateWithoutGroupMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMemberInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMemberNestedInput = {
    create?: XOR<UserCreateWithoutGroupMemberInput, UserUncheckedCreateWithoutGroupMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMemberInput
    upsert?: UserUpsertWithoutGroupMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMemberInput, UserUpdateWithoutGroupMemberInput>, UserUncheckedUpdateWithoutGroupMemberInput>
  }

  export type GroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput
    upsert?: GroupUpsertWithoutMessagesInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMessagesInput, GroupUpdateWithoutMessagesInput>, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    upsert?: UserUpsertWithoutMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageInput, UserUpdateWithoutMessageInput>, UserUncheckedUpdateWithoutMessageInput>
  }

  export type EmailTemplateCreateNestedOneWithoutAssignedUsersInput = {
    create?: XOR<EmailTemplateCreateWithoutAssignedUsersInput, EmailTemplateUncheckedCreateWithoutAssignedUsersInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutAssignedUsersInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailTemplatesInput = {
    create?: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type EmailTemplateUpdateOneRequiredWithoutAssignedUsersNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutAssignedUsersInput, EmailTemplateUncheckedCreateWithoutAssignedUsersInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutAssignedUsersInput
    upsert?: EmailTemplateUpsertWithoutAssignedUsersInput
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutAssignedUsersInput, EmailTemplateUpdateWithoutAssignedUsersInput>, EmailTemplateUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutEmailTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplatesInput
    upsert?: UserUpsertWithoutEmailTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailTemplatesInput, UserUpdateWithoutEmailTemplatesInput>, UserUncheckedUpdateWithoutEmailTemplatesInput>
  }

  export type NotificationReadCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type NotificationReadUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NotificationReadUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutNotificationInput | NotificationReadUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutNotificationInput | NotificationReadUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutNotificationInput | NotificationReadUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type NotificationReadUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutNotificationInput | NotificationReadUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutNotificationInput | NotificationReadUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutNotificationInput | NotificationReadUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutReadsInput = {
    create?: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutReadsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationReadInput = {
    create?: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReadInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutReadsInput
    upsert?: NotificationUpsertWithoutReadsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutReadsInput, NotificationUpdateWithoutReadsInput>, NotificationUncheckedUpdateWithoutReadsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationReadNestedInput = {
    create?: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReadInput
    upsert?: UserUpsertWithoutNotificationReadInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationReadInput, UserUpdateWithoutNotificationReadInput>, UserUncheckedUpdateWithoutNotificationReadInput>
  }

  export type SavedQueryCreatecolumnsInput = {
    set: string[]
  }

  export type EmailTemplateCreateNestedOneWithoutSavedQueryInput = {
    create?: XOR<EmailTemplateCreateWithoutSavedQueryInput, EmailTemplateUncheckedCreateWithoutSavedQueryInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutSavedQueryInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type SavedQueryUpdatecolumnsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailTemplateUpdateOneWithoutSavedQueryNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutSavedQueryInput, EmailTemplateUncheckedCreateWithoutSavedQueryInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutSavedQueryInput
    upsert?: EmailTemplateUpsertWithoutSavedQueryInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutSavedQueryInput, EmailTemplateUpdateWithoutSavedQueryInput>, EmailTemplateUncheckedUpdateWithoutSavedQueryInput>
  }

  export type TicketAttachmentCreateNestedManyWithoutCommentInput = {
    create?: XOR<TicketAttachmentCreateWithoutCommentInput, TicketAttachmentUncheckedCreateWithoutCommentInput> | TicketAttachmentCreateWithoutCommentInput[] | TicketAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutCommentInput | TicketAttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: TicketAttachmentCreateManyCommentInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCommentsInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<TicketAttachmentCreateWithoutCommentInput, TicketAttachmentUncheckedCreateWithoutCommentInput> | TicketAttachmentCreateWithoutCommentInput[] | TicketAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutCommentInput | TicketAttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: TicketAttachmentCreateManyCommentInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketAttachmentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutCommentInput, TicketAttachmentUncheckedCreateWithoutCommentInput> | TicketAttachmentCreateWithoutCommentInput[] | TicketAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutCommentInput | TicketAttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutCommentInput | TicketAttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: TicketAttachmentCreateManyCommentInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutCommentInput | TicketAttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutCommentInput | TicketAttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type SupportTicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCommentsInput
    upsert?: SupportTicketUpsertWithoutCommentsInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutCommentsInput, SupportTicketUpdateWithoutCommentsInput>, SupportTicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    upsert?: UserUpsertWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentsInput, UserUpdateWithoutTicketCommentsInput>, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutCommentInput, TicketAttachmentUncheckedCreateWithoutCommentInput> | TicketAttachmentCreateWithoutCommentInput[] | TicketAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutCommentInput | TicketAttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutCommentInput | TicketAttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: TicketAttachmentCreateManyCommentInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutCommentInput | TicketAttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutCommentInput | TicketAttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTicketsInput = {
    create?: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type devicesCreateNestedOneWithoutSupportTicketInput = {
    create?: XOR<devicesCreateWithoutSupportTicketInput, devicesUncheckedCreateWithoutSupportTicketInput>
    connectOrCreate?: devicesCreateOrConnectWithoutSupportTicketInput
    connect?: devicesWhereUniqueInput
  }

  export type TicketAttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTicketsInput
    upsert?: UserUpsertWithoutCreatedTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTicketsInput, UserUpdateWithoutCreatedTicketsInput>, UserUncheckedUpdateWithoutCreatedTicketsInput>
  }

  export type devicesUpdateOneWithoutSupportTicketNestedInput = {
    create?: XOR<devicesCreateWithoutSupportTicketInput, devicesUncheckedCreateWithoutSupportTicketInput>
    connectOrCreate?: devicesCreateOrConnectWithoutSupportTicketInput
    upsert?: devicesUpsertWithoutSupportTicketInput
    disconnect?: devicesWhereInput | boolean
    delete?: devicesWhereInput | boolean
    connect?: devicesWhereUniqueInput
    update?: XOR<XOR<devicesUpdateToOneWithWhereWithoutSupportTicketInput, devicesUpdateWithoutSupportTicketInput>, devicesUncheckedUpdateWithoutSupportTicketInput>
  }

  export type TicketAttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCommentCreateNestedOneWithoutTicketAttachmentInput = {
    create?: XOR<TicketCommentCreateWithoutTicketAttachmentInput, TicketCommentUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketAttachmentInput
    connect?: TicketCommentWhereUniqueInput
  }

  export type SupportTicketCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<SupportTicketCreateWithoutAttachmentsInput, SupportTicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAttachmentsInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketAttachmentInput = {
    create?: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketAttachmentInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCommentUpdateOneWithoutTicketAttachmentNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketAttachmentInput, TicketCommentUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketAttachmentInput
    upsert?: TicketCommentUpsertWithoutTicketAttachmentInput
    disconnect?: TicketCommentWhereInput | boolean
    delete?: TicketCommentWhereInput | boolean
    connect?: TicketCommentWhereUniqueInput
    update?: XOR<XOR<TicketCommentUpdateToOneWithWhereWithoutTicketAttachmentInput, TicketCommentUpdateWithoutTicketAttachmentInput>, TicketCommentUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type SupportTicketUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAttachmentsInput, SupportTicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAttachmentsInput
    upsert?: SupportTicketUpsertWithoutAttachmentsInput
    disconnect?: SupportTicketWhereInput | boolean
    delete?: SupportTicketWhereInput | boolean
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutAttachmentsInput, SupportTicketUpdateWithoutAttachmentsInput>, SupportTicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketAttachmentNestedInput = {
    create?: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketAttachmentInput
    upsert?: UserUpsertWithoutTicketAttachmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketAttachmentInput, UserUpdateWithoutTicketAttachmentInput>, UserUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type EmailTemplateCreateNestedOneWithoutAlertConditionInput = {
    create?: XOR<EmailTemplateCreateWithoutAlertConditionInput, EmailTemplateUncheckedCreateWithoutAlertConditionInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutAlertConditionInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type AlertEventCreateNestedManyWithoutAlertConditionInput = {
    create?: XOR<AlertEventCreateWithoutAlertConditionInput, AlertEventUncheckedCreateWithoutAlertConditionInput> | AlertEventCreateWithoutAlertConditionInput[] | AlertEventUncheckedCreateWithoutAlertConditionInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutAlertConditionInput | AlertEventCreateOrConnectWithoutAlertConditionInput[]
    createMany?: AlertEventCreateManyAlertConditionInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type AlertEventUncheckedCreateNestedManyWithoutAlertConditionInput = {
    create?: XOR<AlertEventCreateWithoutAlertConditionInput, AlertEventUncheckedCreateWithoutAlertConditionInput> | AlertEventCreateWithoutAlertConditionInput[] | AlertEventUncheckedCreateWithoutAlertConditionInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutAlertConditionInput | AlertEventCreateOrConnectWithoutAlertConditionInput[]
    createMany?: AlertEventCreateManyAlertConditionInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type EmailTemplateUpdateOneWithoutAlertConditionNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutAlertConditionInput, EmailTemplateUncheckedCreateWithoutAlertConditionInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutAlertConditionInput
    upsert?: EmailTemplateUpsertWithoutAlertConditionInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutAlertConditionInput, EmailTemplateUpdateWithoutAlertConditionInput>, EmailTemplateUncheckedUpdateWithoutAlertConditionInput>
  }

  export type AlertEventUpdateManyWithoutAlertConditionNestedInput = {
    create?: XOR<AlertEventCreateWithoutAlertConditionInput, AlertEventUncheckedCreateWithoutAlertConditionInput> | AlertEventCreateWithoutAlertConditionInput[] | AlertEventUncheckedCreateWithoutAlertConditionInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutAlertConditionInput | AlertEventCreateOrConnectWithoutAlertConditionInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutAlertConditionInput | AlertEventUpsertWithWhereUniqueWithoutAlertConditionInput[]
    createMany?: AlertEventCreateManyAlertConditionInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutAlertConditionInput | AlertEventUpdateWithWhereUniqueWithoutAlertConditionInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutAlertConditionInput | AlertEventUpdateManyWithWhereWithoutAlertConditionInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type AlertEventUncheckedUpdateManyWithoutAlertConditionNestedInput = {
    create?: XOR<AlertEventCreateWithoutAlertConditionInput, AlertEventUncheckedCreateWithoutAlertConditionInput> | AlertEventCreateWithoutAlertConditionInput[] | AlertEventUncheckedCreateWithoutAlertConditionInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutAlertConditionInput | AlertEventCreateOrConnectWithoutAlertConditionInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutAlertConditionInput | AlertEventUpsertWithWhereUniqueWithoutAlertConditionInput[]
    createMany?: AlertEventCreateManyAlertConditionInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutAlertConditionInput | AlertEventUpdateWithWhereUniqueWithoutAlertConditionInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutAlertConditionInput | AlertEventUpdateManyWithWhereWithoutAlertConditionInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type AlertConditionCreateNestedOneWithoutTriggeredAlertsInput = {
    create?: XOR<AlertConditionCreateWithoutTriggeredAlertsInput, AlertConditionUncheckedCreateWithoutTriggeredAlertsInput>
    connectOrCreate?: AlertConditionCreateOrConnectWithoutTriggeredAlertsInput
    connect?: AlertConditionWhereUniqueInput
  }

  export type AlertConditionUpdateOneRequiredWithoutTriggeredAlertsNestedInput = {
    create?: XOR<AlertConditionCreateWithoutTriggeredAlertsInput, AlertConditionUncheckedCreateWithoutTriggeredAlertsInput>
    connectOrCreate?: AlertConditionCreateOrConnectWithoutTriggeredAlertsInput
    upsert?: AlertConditionUpsertWithoutTriggeredAlertsInput
    connect?: AlertConditionWhereUniqueInput
    update?: XOR<XOR<AlertConditionUpdateToOneWithWhereWithoutTriggeredAlertsInput, AlertConditionUpdateWithoutTriggeredAlertsInput>, AlertConditionUncheckedUpdateWithoutTriggeredAlertsInput>
  }

  export type UserCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type FeedbackRecipientCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackRecipientCreateWithoutFeedbackInput, FeedbackRecipientUncheckedCreateWithoutFeedbackInput> | FeedbackRecipientCreateWithoutFeedbackInput[] | FeedbackRecipientUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutFeedbackInput | FeedbackRecipientCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackRecipientCreateManyFeedbackInputEnvelope
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
  }

  export type FeedbackRecipientUncheckedCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackRecipientCreateWithoutFeedbackInput, FeedbackRecipientUncheckedCreateWithoutFeedbackInput> | FeedbackRecipientCreateWithoutFeedbackInput[] | FeedbackRecipientUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutFeedbackInput | FeedbackRecipientCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackRecipientCreateManyFeedbackInputEnvelope
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    upsert?: UserUpsertWithoutFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackInput, UserUpdateWithoutFeedbackInput>, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type FeedbackRecipientUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackRecipientCreateWithoutFeedbackInput, FeedbackRecipientUncheckedCreateWithoutFeedbackInput> | FeedbackRecipientCreateWithoutFeedbackInput[] | FeedbackRecipientUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutFeedbackInput | FeedbackRecipientCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackRecipientUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackRecipientUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackRecipientCreateManyFeedbackInputEnvelope
    set?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    disconnect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    delete?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    update?: FeedbackRecipientUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackRecipientUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackRecipientUpdateManyWithWhereWithoutFeedbackInput | FeedbackRecipientUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackRecipientScalarWhereInput | FeedbackRecipientScalarWhereInput[]
  }

  export type FeedbackRecipientUncheckedUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackRecipientCreateWithoutFeedbackInput, FeedbackRecipientUncheckedCreateWithoutFeedbackInput> | FeedbackRecipientCreateWithoutFeedbackInput[] | FeedbackRecipientUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackRecipientCreateOrConnectWithoutFeedbackInput | FeedbackRecipientCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackRecipientUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackRecipientUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackRecipientCreateManyFeedbackInputEnvelope
    set?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    disconnect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    delete?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    connect?: FeedbackRecipientWhereUniqueInput | FeedbackRecipientWhereUniqueInput[]
    update?: FeedbackRecipientUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackRecipientUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackRecipientUpdateManyWithWhereWithoutFeedbackInput | FeedbackRecipientUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackRecipientScalarWhereInput | FeedbackRecipientScalarWhereInput[]
  }

  export type FeedbackCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<FeedbackCreateWithoutRecipientsInput, FeedbackUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutRecipientsInput
    connect?: FeedbackWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbackRecipientInput = {
    create?: XOR<UserCreateWithoutFeedbackRecipientInput, UserUncheckedCreateWithoutFeedbackRecipientInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackRecipientInput
    connect?: UserWhereUniqueInput
  }

  export type FeedbackUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<FeedbackCreateWithoutRecipientsInput, FeedbackUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutRecipientsInput
    upsert?: FeedbackUpsertWithoutRecipientsInput
    connect?: FeedbackWhereUniqueInput
    update?: XOR<XOR<FeedbackUpdateToOneWithWhereWithoutRecipientsInput, FeedbackUpdateWithoutRecipientsInput>, FeedbackUncheckedUpdateWithoutRecipientsInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbackRecipientNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackRecipientInput, UserUncheckedCreateWithoutFeedbackRecipientInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackRecipientInput
    upsert?: UserUpsertWithoutFeedbackRecipientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackRecipientInput, UserUpdateWithoutFeedbackRecipientInput>, UserUncheckedUpdateWithoutFeedbackRecipientInput>
  }

  export type RolePermissionCreateNestedManyWithoutPagePermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPagePermissionInput, RolePermissionUncheckedCreateWithoutPagePermissionInput> | RolePermissionCreateWithoutPagePermissionInput[] | RolePermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPagePermissionInput | RolePermissionCreateOrConnectWithoutPagePermissionInput[]
    createMany?: RolePermissionCreateManyPagePermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserPermissionCreateNestedManyWithoutPagePermissionInput = {
    create?: XOR<UserPermissionCreateWithoutPagePermissionInput, UserPermissionUncheckedCreateWithoutPagePermissionInput> | UserPermissionCreateWithoutPagePermissionInput[] | UserPermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPagePermissionInput | UserPermissionCreateOrConnectWithoutPagePermissionInput[]
    createMany?: UserPermissionCreateManyPagePermissionInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPagePermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPagePermissionInput, RolePermissionUncheckedCreateWithoutPagePermissionInput> | RolePermissionCreateWithoutPagePermissionInput[] | RolePermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPagePermissionInput | RolePermissionCreateOrConnectWithoutPagePermissionInput[]
    createMany?: RolePermissionCreateManyPagePermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserPermissionUncheckedCreateNestedManyWithoutPagePermissionInput = {
    create?: XOR<UserPermissionCreateWithoutPagePermissionInput, UserPermissionUncheckedCreateWithoutPagePermissionInput> | UserPermissionCreateWithoutPagePermissionInput[] | UserPermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPagePermissionInput | UserPermissionCreateOrConnectWithoutPagePermissionInput[]
    createMany?: UserPermissionCreateManyPagePermissionInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPagePermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPagePermissionInput, RolePermissionUncheckedCreateWithoutPagePermissionInput> | RolePermissionCreateWithoutPagePermissionInput[] | RolePermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPagePermissionInput | RolePermissionCreateOrConnectWithoutPagePermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPagePermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPagePermissionInput[]
    createMany?: RolePermissionCreateManyPagePermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPagePermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPagePermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPagePermissionInput | RolePermissionUpdateManyWithWhereWithoutPagePermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserPermissionUpdateManyWithoutPagePermissionNestedInput = {
    create?: XOR<UserPermissionCreateWithoutPagePermissionInput, UserPermissionUncheckedCreateWithoutPagePermissionInput> | UserPermissionCreateWithoutPagePermissionInput[] | UserPermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPagePermissionInput | UserPermissionCreateOrConnectWithoutPagePermissionInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutPagePermissionInput | UserPermissionUpsertWithWhereUniqueWithoutPagePermissionInput[]
    createMany?: UserPermissionCreateManyPagePermissionInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutPagePermissionInput | UserPermissionUpdateWithWhereUniqueWithoutPagePermissionInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutPagePermissionInput | UserPermissionUpdateManyWithWhereWithoutPagePermissionInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPagePermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPagePermissionInput, RolePermissionUncheckedCreateWithoutPagePermissionInput> | RolePermissionCreateWithoutPagePermissionInput[] | RolePermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPagePermissionInput | RolePermissionCreateOrConnectWithoutPagePermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPagePermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPagePermissionInput[]
    createMany?: RolePermissionCreateManyPagePermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPagePermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPagePermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPagePermissionInput | RolePermissionUpdateManyWithWhereWithoutPagePermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserPermissionUncheckedUpdateManyWithoutPagePermissionNestedInput = {
    create?: XOR<UserPermissionCreateWithoutPagePermissionInput, UserPermissionUncheckedCreateWithoutPagePermissionInput> | UserPermissionCreateWithoutPagePermissionInput[] | UserPermissionUncheckedCreateWithoutPagePermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPagePermissionInput | UserPermissionCreateOrConnectWithoutPagePermissionInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutPagePermissionInput | UserPermissionUpsertWithWhereUniqueWithoutPagePermissionInput[]
    createMany?: UserPermissionCreateManyPagePermissionInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutPagePermissionInput | UserPermissionUpdateWithWhereUniqueWithoutPagePermissionInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutPagePermissionInput | UserPermissionUpdateManyWithWhereWithoutPagePermissionInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type PagePermissionCreateNestedOneWithoutAllowedRolesInput = {
    create?: XOR<PagePermissionCreateWithoutAllowedRolesInput, PagePermissionUncheckedCreateWithoutAllowedRolesInput>
    connectOrCreate?: PagePermissionCreateOrConnectWithoutAllowedRolesInput
    connect?: PagePermissionWhereUniqueInput
  }

  export type PagePermissionUpdateOneRequiredWithoutAllowedRolesNestedInput = {
    create?: XOR<PagePermissionCreateWithoutAllowedRolesInput, PagePermissionUncheckedCreateWithoutAllowedRolesInput>
    connectOrCreate?: PagePermissionCreateOrConnectWithoutAllowedRolesInput
    upsert?: PagePermissionUpsertWithoutAllowedRolesInput
    connect?: PagePermissionWhereUniqueInput
    update?: XOR<XOR<PagePermissionUpdateToOneWithWhereWithoutAllowedRolesInput, PagePermissionUpdateWithoutAllowedRolesInput>, PagePermissionUncheckedUpdateWithoutAllowedRolesInput>
  }

  export type PagePermissionCreateNestedOneWithoutAllowedUsersInput = {
    create?: XOR<PagePermissionCreateWithoutAllowedUsersInput, PagePermissionUncheckedCreateWithoutAllowedUsersInput>
    connectOrCreate?: PagePermissionCreateOrConnectWithoutAllowedUsersInput
    connect?: PagePermissionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserPermissionInput = {
    create?: XOR<UserCreateWithoutUserPermissionInput, UserUncheckedCreateWithoutUserPermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPermissionInput
    connect?: UserWhereUniqueInput
  }

  export type PagePermissionUpdateOneRequiredWithoutAllowedUsersNestedInput = {
    create?: XOR<PagePermissionCreateWithoutAllowedUsersInput, PagePermissionUncheckedCreateWithoutAllowedUsersInput>
    connectOrCreate?: PagePermissionCreateOrConnectWithoutAllowedUsersInput
    upsert?: PagePermissionUpsertWithoutAllowedUsersInput
    connect?: PagePermissionWhereUniqueInput
    update?: XOR<XOR<PagePermissionUpdateToOneWithWhereWithoutAllowedUsersInput, PagePermissionUpdateWithoutAllowedUsersInput>, PagePermissionUncheckedUpdateWithoutAllowedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutUserPermissionNestedInput = {
    create?: XOR<UserCreateWithoutUserPermissionInput, UserUncheckedCreateWithoutUserPermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPermissionInput
    upsert?: UserUpsertWithoutUserPermissionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPermissionInput, UserUpdateWithoutUserPermissionInput>, UserUncheckedUpdateWithoutUserPermissionInput>
  }

  export type ProjectCreateNestedManyWithoutProjectTypeInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProjectTypeInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutProjectTypeNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectTypeInput | ProjectUpsertWithWhereUniqueWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectTypeInput | ProjectUpdateWithWhereUniqueWithoutProjectTypeInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectTypeInput | ProjectUpdateManyWithWhereWithoutProjectTypeInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProjectTypeNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectTypeInput | ProjectUpsertWithWhereUniqueWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectTypeInput | ProjectUpdateWithWhereUniqueWithoutProjectTypeInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectTypeInput | ProjectUpdateManyWithWhereWithoutProjectTypeInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ModelEntryCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModelEntryCreateWithoutProjectInput, ModelEntryUncheckedCreateWithoutProjectInput> | ModelEntryCreateWithoutProjectInput[] | ModelEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelEntryCreateOrConnectWithoutProjectInput | ModelEntryCreateOrConnectWithoutProjectInput[]
    createMany?: ModelEntryCreateManyProjectInputEnvelope
    connect?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
  }

  export type ProjectTypeCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectTypeCreateOrConnectWithoutProjectsInput
    connect?: ProjectTypeWhereUniqueInput
  }

  export type ProjectAssignmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectAssignmentCreateWithoutProjectInput, ProjectAssignmentUncheckedCreateWithoutProjectInput> | ProjectAssignmentCreateWithoutProjectInput[] | ProjectAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutProjectInput | ProjectAssignmentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectAssignmentCreateManyProjectInputEnvelope
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
  }

  export type ModelEntryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModelEntryCreateWithoutProjectInput, ModelEntryUncheckedCreateWithoutProjectInput> | ModelEntryCreateWithoutProjectInput[] | ModelEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelEntryCreateOrConnectWithoutProjectInput | ModelEntryCreateOrConnectWithoutProjectInput[]
    createMany?: ModelEntryCreateManyProjectInputEnvelope
    connect?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
  }

  export type ProjectAssignmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectAssignmentCreateWithoutProjectInput, ProjectAssignmentUncheckedCreateWithoutProjectInput> | ProjectAssignmentCreateWithoutProjectInput[] | ProjectAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutProjectInput | ProjectAssignmentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectAssignmentCreateManyProjectInputEnvelope
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
  }

  export type ModelEntryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModelEntryCreateWithoutProjectInput, ModelEntryUncheckedCreateWithoutProjectInput> | ModelEntryCreateWithoutProjectInput[] | ModelEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelEntryCreateOrConnectWithoutProjectInput | ModelEntryCreateOrConnectWithoutProjectInput[]
    upsert?: ModelEntryUpsertWithWhereUniqueWithoutProjectInput | ModelEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModelEntryCreateManyProjectInputEnvelope
    set?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    disconnect?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    delete?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    connect?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    update?: ModelEntryUpdateWithWhereUniqueWithoutProjectInput | ModelEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModelEntryUpdateManyWithWhereWithoutProjectInput | ModelEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModelEntryScalarWhereInput | ModelEntryScalarWhereInput[]
  }

  export type ProjectTypeUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectTypeCreateOrConnectWithoutProjectsInput
    upsert?: ProjectTypeUpsertWithoutProjectsInput
    disconnect?: ProjectTypeWhereInput | boolean
    delete?: ProjectTypeWhereInput | boolean
    connect?: ProjectTypeWhereUniqueInput
    update?: XOR<XOR<ProjectTypeUpdateToOneWithWhereWithoutProjectsInput, ProjectTypeUpdateWithoutProjectsInput>, ProjectTypeUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectAssignmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectAssignmentCreateWithoutProjectInput, ProjectAssignmentUncheckedCreateWithoutProjectInput> | ProjectAssignmentCreateWithoutProjectInput[] | ProjectAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutProjectInput | ProjectAssignmentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectAssignmentUpsertWithWhereUniqueWithoutProjectInput | ProjectAssignmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectAssignmentCreateManyProjectInputEnvelope
    set?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    disconnect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    delete?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    update?: ProjectAssignmentUpdateWithWhereUniqueWithoutProjectInput | ProjectAssignmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectAssignmentUpdateManyWithWhereWithoutProjectInput | ProjectAssignmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectAssignmentScalarWhereInput | ProjectAssignmentScalarWhereInput[]
  }

  export type ModelEntryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModelEntryCreateWithoutProjectInput, ModelEntryUncheckedCreateWithoutProjectInput> | ModelEntryCreateWithoutProjectInput[] | ModelEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelEntryCreateOrConnectWithoutProjectInput | ModelEntryCreateOrConnectWithoutProjectInput[]
    upsert?: ModelEntryUpsertWithWhereUniqueWithoutProjectInput | ModelEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModelEntryCreateManyProjectInputEnvelope
    set?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    disconnect?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    delete?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    connect?: ModelEntryWhereUniqueInput | ModelEntryWhereUniqueInput[]
    update?: ModelEntryUpdateWithWhereUniqueWithoutProjectInput | ModelEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModelEntryUpdateManyWithWhereWithoutProjectInput | ModelEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModelEntryScalarWhereInput | ModelEntryScalarWhereInput[]
  }

  export type ProjectAssignmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectAssignmentCreateWithoutProjectInput, ProjectAssignmentUncheckedCreateWithoutProjectInput> | ProjectAssignmentCreateWithoutProjectInput[] | ProjectAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAssignmentCreateOrConnectWithoutProjectInput | ProjectAssignmentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectAssignmentUpsertWithWhereUniqueWithoutProjectInput | ProjectAssignmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectAssignmentCreateManyProjectInputEnvelope
    set?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    disconnect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    delete?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    connect?: ProjectAssignmentWhereUniqueInput | ProjectAssignmentWhereUniqueInput[]
    update?: ProjectAssignmentUpdateWithWhereUniqueWithoutProjectInput | ProjectAssignmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectAssignmentUpdateManyWithWhereWithoutProjectInput | ProjectAssignmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectAssignmentScalarWhereInput | ProjectAssignmentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutModelsInput = {
    create?: XOR<ProjectCreateWithoutModelsInput, ProjectUncheckedCreateWithoutModelsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModelsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<ProjectCreateWithoutModelsInput, ProjectUncheckedCreateWithoutModelsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModelsInput
    upsert?: ProjectUpsertWithoutModelsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutModelsInput, ProjectUpdateWithoutModelsInput>, ProjectUncheckedUpdateWithoutModelsInput>
  }

  export type ProjectCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ProjectCreateWithoutAssignmentsInput, ProjectUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAssignmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectAssignmentInput = {
    create?: XOR<UserCreateWithoutProjectAssignmentInput, UserUncheckedCreateWithoutProjectAssignmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectAssignmentInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutAssignmentsInput, ProjectUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAssignmentsInput
    upsert?: ProjectUpsertWithoutAssignmentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAssignmentsInput, ProjectUpdateWithoutAssignmentsInput>, ProjectUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectAssignmentNestedInput = {
    create?: XOR<UserCreateWithoutProjectAssignmentInput, UserUncheckedCreateWithoutProjectAssignmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectAssignmentInput
    upsert?: UserUpsertWithoutProjectAssignmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectAssignmentInput, UserUpdateWithoutProjectAssignmentInput>, UserUncheckedUpdateWithoutProjectAssignmentInput>
  }

  export type TeamLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<TeamLocationCreateWithoutLocationInput, TeamLocationUncheckedCreateWithoutLocationInput> | TeamLocationCreateWithoutLocationInput[] | TeamLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutLocationInput | TeamLocationCreateOrConnectWithoutLocationInput[]
    createMany?: TeamLocationCreateManyLocationInputEnvelope
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
  }

  export type TeamLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<TeamLocationCreateWithoutLocationInput, TeamLocationUncheckedCreateWithoutLocationInput> | TeamLocationCreateWithoutLocationInput[] | TeamLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutLocationInput | TeamLocationCreateOrConnectWithoutLocationInput[]
    createMany?: TeamLocationCreateManyLocationInputEnvelope
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
  }

  export type TeamLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<TeamLocationCreateWithoutLocationInput, TeamLocationUncheckedCreateWithoutLocationInput> | TeamLocationCreateWithoutLocationInput[] | TeamLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutLocationInput | TeamLocationCreateOrConnectWithoutLocationInput[]
    upsert?: TeamLocationUpsertWithWhereUniqueWithoutLocationInput | TeamLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: TeamLocationCreateManyLocationInputEnvelope
    set?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    disconnect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    delete?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    update?: TeamLocationUpdateWithWhereUniqueWithoutLocationInput | TeamLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: TeamLocationUpdateManyWithWhereWithoutLocationInput | TeamLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: TeamLocationScalarWhereInput | TeamLocationScalarWhereInput[]
  }

  export type TeamLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<TeamLocationCreateWithoutLocationInput, TeamLocationUncheckedCreateWithoutLocationInput> | TeamLocationCreateWithoutLocationInput[] | TeamLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutLocationInput | TeamLocationCreateOrConnectWithoutLocationInput[]
    upsert?: TeamLocationUpsertWithWhereUniqueWithoutLocationInput | TeamLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: TeamLocationCreateManyLocationInputEnvelope
    set?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    disconnect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    delete?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    update?: TeamLocationUpdateWithWhereUniqueWithoutLocationInput | TeamLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: TeamLocationUpdateManyWithWhereWithoutLocationInput | TeamLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: TeamLocationScalarWhereInput | TeamLocationScalarWhereInput[]
  }

  export type ldapuserCreateobjectClassInput = {
    set: string[]
  }

  export type ldapuserUpdateobjectClassInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DriveFileCreateNestedManyWithoutFolderInput = {
    create?: XOR<DriveFileCreateWithoutFolderInput, DriveFileUncheckedCreateWithoutFolderInput> | DriveFileCreateWithoutFolderInput[] | DriveFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutFolderInput | DriveFileCreateOrConnectWithoutFolderInput[]
    createMany?: DriveFileCreateManyFolderInputEnvelope
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDriveFolderInput = {
    create?: XOR<UserCreateWithoutDriveFolderInput, UserUncheckedCreateWithoutDriveFolderInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriveFolderInput
    connect?: UserWhereUniqueInput
  }

  export type DriveFolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<DriveFolderCreateWithoutChildrenInput, DriveFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DriveFolderCreateOrConnectWithoutChildrenInput
    connect?: DriveFolderWhereUniqueInput
  }

  export type DriveFolderCreateNestedManyWithoutParentInput = {
    create?: XOR<DriveFolderCreateWithoutParentInput, DriveFolderUncheckedCreateWithoutParentInput> | DriveFolderCreateWithoutParentInput[] | DriveFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutParentInput | DriveFolderCreateOrConnectWithoutParentInput[]
    createMany?: DriveFolderCreateManyParentInputEnvelope
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
  }

  export type DriveFileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<DriveFileCreateWithoutFolderInput, DriveFileUncheckedCreateWithoutFolderInput> | DriveFileCreateWithoutFolderInput[] | DriveFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutFolderInput | DriveFileCreateOrConnectWithoutFolderInput[]
    createMany?: DriveFileCreateManyFolderInputEnvelope
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
  }

  export type DriveFolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DriveFolderCreateWithoutParentInput, DriveFolderUncheckedCreateWithoutParentInput> | DriveFolderCreateWithoutParentInput[] | DriveFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutParentInput | DriveFolderCreateOrConnectWithoutParentInput[]
    createMany?: DriveFolderCreateManyParentInputEnvelope
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
  }

  export type DriveFileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<DriveFileCreateWithoutFolderInput, DriveFileUncheckedCreateWithoutFolderInput> | DriveFileCreateWithoutFolderInput[] | DriveFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutFolderInput | DriveFileCreateOrConnectWithoutFolderInput[]
    upsert?: DriveFileUpsertWithWhereUniqueWithoutFolderInput | DriveFileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: DriveFileCreateManyFolderInputEnvelope
    set?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    disconnect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    delete?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    update?: DriveFileUpdateWithWhereUniqueWithoutFolderInput | DriveFileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: DriveFileUpdateManyWithWhereWithoutFolderInput | DriveFileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: DriveFileScalarWhereInput | DriveFileScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutDriveFolderNestedInput = {
    create?: XOR<UserCreateWithoutDriveFolderInput, UserUncheckedCreateWithoutDriveFolderInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriveFolderInput
    upsert?: UserUpsertWithoutDriveFolderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriveFolderInput, UserUpdateWithoutDriveFolderInput>, UserUncheckedUpdateWithoutDriveFolderInput>
  }

  export type DriveFolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<DriveFolderCreateWithoutChildrenInput, DriveFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DriveFolderCreateOrConnectWithoutChildrenInput
    upsert?: DriveFolderUpsertWithoutChildrenInput
    disconnect?: DriveFolderWhereInput | boolean
    delete?: DriveFolderWhereInput | boolean
    connect?: DriveFolderWhereUniqueInput
    update?: XOR<XOR<DriveFolderUpdateToOneWithWhereWithoutChildrenInput, DriveFolderUpdateWithoutChildrenInput>, DriveFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type DriveFolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<DriveFolderCreateWithoutParentInput, DriveFolderUncheckedCreateWithoutParentInput> | DriveFolderCreateWithoutParentInput[] | DriveFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutParentInput | DriveFolderCreateOrConnectWithoutParentInput[]
    upsert?: DriveFolderUpsertWithWhereUniqueWithoutParentInput | DriveFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DriveFolderCreateManyParentInputEnvelope
    set?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    disconnect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    delete?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    update?: DriveFolderUpdateWithWhereUniqueWithoutParentInput | DriveFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DriveFolderUpdateManyWithWhereWithoutParentInput | DriveFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DriveFolderScalarWhereInput | DriveFolderScalarWhereInput[]
  }

  export type DriveFileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<DriveFileCreateWithoutFolderInput, DriveFileUncheckedCreateWithoutFolderInput> | DriveFileCreateWithoutFolderInput[] | DriveFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DriveFileCreateOrConnectWithoutFolderInput | DriveFileCreateOrConnectWithoutFolderInput[]
    upsert?: DriveFileUpsertWithWhereUniqueWithoutFolderInput | DriveFileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: DriveFileCreateManyFolderInputEnvelope
    set?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    disconnect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    delete?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    connect?: DriveFileWhereUniqueInput | DriveFileWhereUniqueInput[]
    update?: DriveFileUpdateWithWhereUniqueWithoutFolderInput | DriveFileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: DriveFileUpdateManyWithWhereWithoutFolderInput | DriveFileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: DriveFileScalarWhereInput | DriveFileScalarWhereInput[]
  }

  export type DriveFolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DriveFolderCreateWithoutParentInput, DriveFolderUncheckedCreateWithoutParentInput> | DriveFolderCreateWithoutParentInput[] | DriveFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DriveFolderCreateOrConnectWithoutParentInput | DriveFolderCreateOrConnectWithoutParentInput[]
    upsert?: DriveFolderUpsertWithWhereUniqueWithoutParentInput | DriveFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DriveFolderCreateManyParentInputEnvelope
    set?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    disconnect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    delete?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    connect?: DriveFolderWhereUniqueInput | DriveFolderWhereUniqueInput[]
    update?: DriveFolderUpdateWithWhereUniqueWithoutParentInput | DriveFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DriveFolderUpdateManyWithWhereWithoutParentInput | DriveFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DriveFolderScalarWhereInput | DriveFolderScalarWhereInput[]
  }

  export type DriveFolderCreateNestedOneWithoutFilesInput = {
    create?: XOR<DriveFolderCreateWithoutFilesInput, DriveFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: DriveFolderCreateOrConnectWithoutFilesInput
    connect?: DriveFolderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDriveFileInput = {
    create?: XOR<UserCreateWithoutDriveFileInput, UserUncheckedCreateWithoutDriveFileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriveFileInput
    connect?: UserWhereUniqueInput
  }

  export type DriveFilePermissionCreateNestedManyWithoutFileInput = {
    create?: XOR<DriveFilePermissionCreateWithoutFileInput, DriveFilePermissionUncheckedCreateWithoutFileInput> | DriveFilePermissionCreateWithoutFileInput[] | DriveFilePermissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutFileInput | DriveFilePermissionCreateOrConnectWithoutFileInput[]
    createMany?: DriveFilePermissionCreateManyFileInputEnvelope
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type DriveFilePermissionUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<DriveFilePermissionCreateWithoutFileInput, DriveFilePermissionUncheckedCreateWithoutFileInput> | DriveFilePermissionCreateWithoutFileInput[] | DriveFilePermissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutFileInput | DriveFilePermissionCreateOrConnectWithoutFileInput[]
    createMany?: DriveFilePermissionCreateManyFileInputEnvelope
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
  }

  export type DriveFolderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<DriveFolderCreateWithoutFilesInput, DriveFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: DriveFolderCreateOrConnectWithoutFilesInput
    upsert?: DriveFolderUpsertWithoutFilesInput
    disconnect?: DriveFolderWhereInput | boolean
    delete?: DriveFolderWhereInput | boolean
    connect?: DriveFolderWhereUniqueInput
    update?: XOR<XOR<DriveFolderUpdateToOneWithWhereWithoutFilesInput, DriveFolderUpdateWithoutFilesInput>, DriveFolderUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateOneRequiredWithoutDriveFileNestedInput = {
    create?: XOR<UserCreateWithoutDriveFileInput, UserUncheckedCreateWithoutDriveFileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriveFileInput
    upsert?: UserUpsertWithoutDriveFileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriveFileInput, UserUpdateWithoutDriveFileInput>, UserUncheckedUpdateWithoutDriveFileInput>
  }

  export type DriveFilePermissionUpdateManyWithoutFileNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutFileInput, DriveFilePermissionUncheckedCreateWithoutFileInput> | DriveFilePermissionCreateWithoutFileInput[] | DriveFilePermissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutFileInput | DriveFilePermissionCreateOrConnectWithoutFileInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutFileInput | DriveFilePermissionUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DriveFilePermissionCreateManyFileInputEnvelope
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutFileInput | DriveFilePermissionUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutFileInput | DriveFilePermissionUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<DriveFilePermissionCreateWithoutFileInput, DriveFilePermissionUncheckedCreateWithoutFileInput> | DriveFilePermissionCreateWithoutFileInput[] | DriveFilePermissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DriveFilePermissionCreateOrConnectWithoutFileInput | DriveFilePermissionCreateOrConnectWithoutFileInput[]
    upsert?: DriveFilePermissionUpsertWithWhereUniqueWithoutFileInput | DriveFilePermissionUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DriveFilePermissionCreateManyFileInputEnvelope
    set?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    disconnect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    delete?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    connect?: DriveFilePermissionWhereUniqueInput | DriveFilePermissionWhereUniqueInput[]
    update?: DriveFilePermissionUpdateWithWhereUniqueWithoutFileInput | DriveFilePermissionUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DriveFilePermissionUpdateManyWithWhereWithoutFileInput | DriveFilePermissionUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
  }

  export type DriveFileCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<DriveFileCreateWithoutPermissionsInput, DriveFileUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: DriveFileCreateOrConnectWithoutPermissionsInput
    connect?: DriveFileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGrantedPermissionsInput = {
    create?: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrantedPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDriveFilePermissionInput = {
    create?: XOR<UserCreateWithoutDriveFilePermissionInput, UserUncheckedCreateWithoutDriveFilePermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriveFilePermissionInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReceivedPermissionsInput = {
    create?: XOR<UserCreateWithoutReceivedPermissionsInput, UserUncheckedCreateWithoutReceivedPermissionsInput> | UserCreateWithoutReceivedPermissionsInput[] | UserUncheckedCreateWithoutReceivedPermissionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedPermissionsInput | UserCreateOrConnectWithoutReceivedPermissionsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReceivedPermissionsInput = {
    create?: XOR<UserCreateWithoutReceivedPermissionsInput, UserUncheckedCreateWithoutReceivedPermissionsInput> | UserCreateWithoutReceivedPermissionsInput[] | UserUncheckedCreateWithoutReceivedPermissionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedPermissionsInput | UserCreateOrConnectWithoutReceivedPermissionsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DriveFileUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<DriveFileCreateWithoutPermissionsInput, DriveFileUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: DriveFileCreateOrConnectWithoutPermissionsInput
    upsert?: DriveFileUpsertWithoutPermissionsInput
    connect?: DriveFileWhereUniqueInput
    update?: XOR<XOR<DriveFileUpdateToOneWithWhereWithoutPermissionsInput, DriveFileUpdateWithoutPermissionsInput>, DriveFileUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrantedPermissionsInput
    upsert?: UserUpsertWithoutGrantedPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGrantedPermissionsInput, UserUpdateWithoutGrantedPermissionsInput>, UserUncheckedUpdateWithoutGrantedPermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutDriveFilePermissionNestedInput = {
    create?: XOR<UserCreateWithoutDriveFilePermissionInput, UserUncheckedCreateWithoutDriveFilePermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriveFilePermissionInput
    upsert?: UserUpsertWithoutDriveFilePermissionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriveFilePermissionInput, UserUpdateWithoutDriveFilePermissionInput>, UserUncheckedUpdateWithoutDriveFilePermissionInput>
  }

  export type UserUpdateManyWithoutReceivedPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedPermissionsInput, UserUncheckedCreateWithoutReceivedPermissionsInput> | UserCreateWithoutReceivedPermissionsInput[] | UserUncheckedCreateWithoutReceivedPermissionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedPermissionsInput | UserCreateOrConnectWithoutReceivedPermissionsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReceivedPermissionsInput | UserUpsertWithWhereUniqueWithoutReceivedPermissionsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReceivedPermissionsInput | UserUpdateWithWhereUniqueWithoutReceivedPermissionsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReceivedPermissionsInput | UserUpdateManyWithWhereWithoutReceivedPermissionsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReceivedPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedPermissionsInput, UserUncheckedCreateWithoutReceivedPermissionsInput> | UserCreateWithoutReceivedPermissionsInput[] | UserUncheckedCreateWithoutReceivedPermissionsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedPermissionsInput | UserCreateOrConnectWithoutReceivedPermissionsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReceivedPermissionsInput | UserUpsertWithWhereUniqueWithoutReceivedPermissionsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReceivedPermissionsInput | UserUpdateWithWhereUniqueWithoutReceivedPermissionsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReceivedPermissionsInput | UserUpdateManyWithWhereWithoutReceivedPermissionsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamLeaderCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamLeaderCreateWithoutTeamInput, TeamLeaderUncheckedCreateWithoutTeamInput> | TeamLeaderCreateWithoutTeamInput[] | TeamLeaderUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutTeamInput | TeamLeaderCreateOrConnectWithoutTeamInput[]
    createMany?: TeamLeaderCreateManyTeamInputEnvelope
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
  }

  export type TeamLocationCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamLocationCreateWithoutTeamInput, TeamLocationUncheckedCreateWithoutTeamInput> | TeamLocationCreateWithoutTeamInput[] | TeamLocationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutTeamInput | TeamLocationCreateOrConnectWithoutTeamInput[]
    createMany?: TeamLocationCreateManyTeamInputEnvelope
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamLeaderUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamLeaderCreateWithoutTeamInput, TeamLeaderUncheckedCreateWithoutTeamInput> | TeamLeaderCreateWithoutTeamInput[] | TeamLeaderUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutTeamInput | TeamLeaderCreateOrConnectWithoutTeamInput[]
    createMany?: TeamLeaderCreateManyTeamInputEnvelope
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
  }

  export type TeamLocationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamLocationCreateWithoutTeamInput, TeamLocationUncheckedCreateWithoutTeamInput> | TeamLocationCreateWithoutTeamInput[] | TeamLocationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutTeamInput | TeamLocationCreateOrConnectWithoutTeamInput[]
    createMany?: TeamLocationCreateManyTeamInputEnvelope
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamLeaderUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamLeaderCreateWithoutTeamInput, TeamLeaderUncheckedCreateWithoutTeamInput> | TeamLeaderCreateWithoutTeamInput[] | TeamLeaderUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutTeamInput | TeamLeaderCreateOrConnectWithoutTeamInput[]
    upsert?: TeamLeaderUpsertWithWhereUniqueWithoutTeamInput | TeamLeaderUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamLeaderCreateManyTeamInputEnvelope
    set?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    disconnect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    delete?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    update?: TeamLeaderUpdateWithWhereUniqueWithoutTeamInput | TeamLeaderUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamLeaderUpdateManyWithWhereWithoutTeamInput | TeamLeaderUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamLeaderScalarWhereInput | TeamLeaderScalarWhereInput[]
  }

  export type TeamLocationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamLocationCreateWithoutTeamInput, TeamLocationUncheckedCreateWithoutTeamInput> | TeamLocationCreateWithoutTeamInput[] | TeamLocationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutTeamInput | TeamLocationCreateOrConnectWithoutTeamInput[]
    upsert?: TeamLocationUpsertWithWhereUniqueWithoutTeamInput | TeamLocationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamLocationCreateManyTeamInputEnvelope
    set?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    disconnect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    delete?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    update?: TeamLocationUpdateWithWhereUniqueWithoutTeamInput | TeamLocationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamLocationUpdateManyWithWhereWithoutTeamInput | TeamLocationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamLocationScalarWhereInput | TeamLocationScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamLeaderUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamLeaderCreateWithoutTeamInput, TeamLeaderUncheckedCreateWithoutTeamInput> | TeamLeaderCreateWithoutTeamInput[] | TeamLeaderUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLeaderCreateOrConnectWithoutTeamInput | TeamLeaderCreateOrConnectWithoutTeamInput[]
    upsert?: TeamLeaderUpsertWithWhereUniqueWithoutTeamInput | TeamLeaderUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamLeaderCreateManyTeamInputEnvelope
    set?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    disconnect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    delete?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    connect?: TeamLeaderWhereUniqueInput | TeamLeaderWhereUniqueInput[]
    update?: TeamLeaderUpdateWithWhereUniqueWithoutTeamInput | TeamLeaderUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamLeaderUpdateManyWithWhereWithoutTeamInput | TeamLeaderUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamLeaderScalarWhereInput | TeamLeaderScalarWhereInput[]
  }

  export type TeamLocationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamLocationCreateWithoutTeamInput, TeamLocationUncheckedCreateWithoutTeamInput> | TeamLocationCreateWithoutTeamInput[] | TeamLocationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamLocationCreateOrConnectWithoutTeamInput | TeamLocationCreateOrConnectWithoutTeamInput[]
    upsert?: TeamLocationUpsertWithWhereUniqueWithoutTeamInput | TeamLocationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamLocationCreateManyTeamInputEnvelope
    set?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    disconnect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    delete?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    connect?: TeamLocationWhereUniqueInput | TeamLocationWhereUniqueInput[]
    update?: TeamLocationUpdateWithWhereUniqueWithoutTeamInput | TeamLocationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamLocationUpdateManyWithWhereWithoutTeamInput | TeamLocationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamLocationScalarWhereInput | TeamLocationScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutLeadersInput = {
    create?: XOR<TeamCreateWithoutLeadersInput, TeamUncheckedCreateWithoutLeadersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLeadersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamLeaderInput = {
    create?: XOR<UserCreateWithoutTeamLeaderInput, UserUncheckedCreateWithoutTeamLeaderInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamLeaderInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutLeadersNestedInput = {
    create?: XOR<TeamCreateWithoutLeadersInput, TeamUncheckedCreateWithoutLeadersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLeadersInput
    upsert?: TeamUpsertWithoutLeadersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutLeadersInput, TeamUpdateWithoutLeadersInput>, TeamUncheckedUpdateWithoutLeadersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamLeaderNestedInput = {
    create?: XOR<UserCreateWithoutTeamLeaderInput, UserUncheckedCreateWithoutTeamLeaderInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamLeaderInput
    upsert?: UserUpsertWithoutTeamLeaderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamLeaderInput, UserUpdateWithoutTeamLeaderInput>, UserUncheckedUpdateWithoutTeamLeaderInput>
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMemberInput = {
    create?: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMemberInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMemberNestedInput = {
    create?: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMemberInput
    upsert?: UserUpsertWithoutTeamMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMemberInput, UserUpdateWithoutTeamMemberInput>, UserUncheckedUpdateWithoutTeamMemberInput>
  }

  export type locationCreateNestedOneWithoutTeamLocationInput = {
    create?: XOR<locationCreateWithoutTeamLocationInput, locationUncheckedCreateWithoutTeamLocationInput>
    connectOrCreate?: locationCreateOrConnectWithoutTeamLocationInput
    connect?: locationWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutLocationsInput = {
    create?: XOR<TeamCreateWithoutLocationsInput, TeamUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLocationsInput
    connect?: TeamWhereUniqueInput
  }

  export type locationUpdateOneRequiredWithoutTeamLocationNestedInput = {
    create?: XOR<locationCreateWithoutTeamLocationInput, locationUncheckedCreateWithoutTeamLocationInput>
    connectOrCreate?: locationCreateOrConnectWithoutTeamLocationInput
    upsert?: locationUpsertWithoutTeamLocationInput
    connect?: locationWhereUniqueInput
    update?: XOR<XOR<locationUpdateToOneWithWhereWithoutTeamLocationInput, locationUpdateWithoutTeamLocationInput>, locationUncheckedUpdateWithoutTeamLocationInput>
  }

  export type TeamUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<TeamCreateWithoutLocationsInput, TeamUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLocationsInput
    upsert?: TeamUpsertWithoutLocationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutLocationsInput, TeamUpdateWithoutLocationsInput>, TeamUncheckedUpdateWithoutLocationsInput>
  }

  export type AuditStepCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<AuditStepCreateWithoutWorkflowInput, AuditStepUncheckedCreateWithoutWorkflowInput> | AuditStepCreateWithoutWorkflowInput[] | AuditStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutWorkflowInput | AuditStepCreateOrConnectWithoutWorkflowInput[]
    createMany?: AuditStepCreateManyWorkflowInputEnvelope
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
  }

  export type AuditStepUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<AuditStepCreateWithoutWorkflowInput, AuditStepUncheckedCreateWithoutWorkflowInput> | AuditStepCreateWithoutWorkflowInput[] | AuditStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutWorkflowInput | AuditStepCreateOrConnectWithoutWorkflowInput[]
    createMany?: AuditStepCreateManyWorkflowInputEnvelope
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
  }

  export type AuditStepUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<AuditStepCreateWithoutWorkflowInput, AuditStepUncheckedCreateWithoutWorkflowInput> | AuditStepCreateWithoutWorkflowInput[] | AuditStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutWorkflowInput | AuditStepCreateOrConnectWithoutWorkflowInput[]
    upsert?: AuditStepUpsertWithWhereUniqueWithoutWorkflowInput | AuditStepUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: AuditStepCreateManyWorkflowInputEnvelope
    set?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    disconnect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    delete?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    update?: AuditStepUpdateWithWhereUniqueWithoutWorkflowInput | AuditStepUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: AuditStepUpdateManyWithWhereWithoutWorkflowInput | AuditStepUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: AuditStepScalarWhereInput | AuditStepScalarWhereInput[]
  }

  export type AuditStepUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<AuditStepCreateWithoutWorkflowInput, AuditStepUncheckedCreateWithoutWorkflowInput> | AuditStepCreateWithoutWorkflowInput[] | AuditStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: AuditStepCreateOrConnectWithoutWorkflowInput | AuditStepCreateOrConnectWithoutWorkflowInput[]
    upsert?: AuditStepUpsertWithWhereUniqueWithoutWorkflowInput | AuditStepUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: AuditStepCreateManyWorkflowInputEnvelope
    set?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    disconnect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    delete?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    connect?: AuditStepWhereUniqueInput | AuditStepWhereUniqueInput[]
    update?: AuditStepUpdateWithWhereUniqueWithoutWorkflowInput | AuditStepUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: AuditStepUpdateManyWithWhereWithoutWorkflowInput | AuditStepUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: AuditStepScalarWhereInput | AuditStepScalarWhereInput[]
  }

  export type AuditWorkflowCreateNestedOneWithoutStepsInput = {
    create?: XOR<AuditWorkflowCreateWithoutStepsInput, AuditWorkflowUncheckedCreateWithoutStepsInput>
    connectOrCreate?: AuditWorkflowCreateOrConnectWithoutStepsInput
    connect?: AuditWorkflowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAudit_stepsInput = {
    create?: XOR<UserCreateWithoutAudit_stepsInput, UserUncheckedCreateWithoutAudit_stepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudit_stepsInput
    connect?: UserWhereUniqueInput
  }

  export type StepLogCreateNestedManyWithoutStepInput = {
    create?: XOR<StepLogCreateWithoutStepInput, StepLogUncheckedCreateWithoutStepInput> | StepLogCreateWithoutStepInput[] | StepLogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepLogCreateOrConnectWithoutStepInput | StepLogCreateOrConnectWithoutStepInput[]
    createMany?: StepLogCreateManyStepInputEnvelope
    connect?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
  }

  export type StepLogUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<StepLogCreateWithoutStepInput, StepLogUncheckedCreateWithoutStepInput> | StepLogCreateWithoutStepInput[] | StepLogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepLogCreateOrConnectWithoutStepInput | StepLogCreateOrConnectWithoutStepInput[]
    createMany?: StepLogCreateManyStepInputEnvelope
    connect?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
  }

  export type EnumStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.StepStatus
  }

  export type AuditWorkflowUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<AuditWorkflowCreateWithoutStepsInput, AuditWorkflowUncheckedCreateWithoutStepsInput>
    connectOrCreate?: AuditWorkflowCreateOrConnectWithoutStepsInput
    upsert?: AuditWorkflowUpsertWithoutStepsInput
    connect?: AuditWorkflowWhereUniqueInput
    update?: XOR<XOR<AuditWorkflowUpdateToOneWithWhereWithoutStepsInput, AuditWorkflowUpdateWithoutStepsInput>, AuditWorkflowUncheckedUpdateWithoutStepsInput>
  }

  export type UserUpdateOneWithoutAudit_stepsNestedInput = {
    create?: XOR<UserCreateWithoutAudit_stepsInput, UserUncheckedCreateWithoutAudit_stepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudit_stepsInput
    upsert?: UserUpsertWithoutAudit_stepsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudit_stepsInput, UserUpdateWithoutAudit_stepsInput>, UserUncheckedUpdateWithoutAudit_stepsInput>
  }

  export type StepLogUpdateManyWithoutStepNestedInput = {
    create?: XOR<StepLogCreateWithoutStepInput, StepLogUncheckedCreateWithoutStepInput> | StepLogCreateWithoutStepInput[] | StepLogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepLogCreateOrConnectWithoutStepInput | StepLogCreateOrConnectWithoutStepInput[]
    upsert?: StepLogUpsertWithWhereUniqueWithoutStepInput | StepLogUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: StepLogCreateManyStepInputEnvelope
    set?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    disconnect?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    delete?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    connect?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    update?: StepLogUpdateWithWhereUniqueWithoutStepInput | StepLogUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: StepLogUpdateManyWithWhereWithoutStepInput | StepLogUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: StepLogScalarWhereInput | StepLogScalarWhereInput[]
  }

  export type StepLogUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<StepLogCreateWithoutStepInput, StepLogUncheckedCreateWithoutStepInput> | StepLogCreateWithoutStepInput[] | StepLogUncheckedCreateWithoutStepInput[]
    connectOrCreate?: StepLogCreateOrConnectWithoutStepInput | StepLogCreateOrConnectWithoutStepInput[]
    upsert?: StepLogUpsertWithWhereUniqueWithoutStepInput | StepLogUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: StepLogCreateManyStepInputEnvelope
    set?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    disconnect?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    delete?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    connect?: StepLogWhereUniqueInput | StepLogWhereUniqueInput[]
    update?: StepLogUpdateWithWhereUniqueWithoutStepInput | StepLogUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: StepLogUpdateManyWithWhereWithoutStepInput | StepLogUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: StepLogScalarWhereInput | StepLogScalarWhereInput[]
  }

  export type AuditStepCreateNestedOneWithoutLogsInput = {
    create?: XOR<AuditStepCreateWithoutLogsInput, AuditStepUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AuditStepCreateOrConnectWithoutLogsInput
    connect?: AuditStepWhereUniqueInput
  }

  export type AuditStepUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<AuditStepCreateWithoutLogsInput, AuditStepUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AuditStepCreateOrConnectWithoutLogsInput
    upsert?: AuditStepUpsertWithoutLogsInput
    connect?: AuditStepWhereUniqueInput
    update?: XOR<XOR<AuditStepUpdateToOneWithWhereWithoutLogsInput, AuditStepUpdateWithoutLogsInput>, AuditStepUncheckedUpdateWithoutLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type NestedEnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type DeviceUserCreateWithoutDeviceInput = {
    role: string
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUserUncheckedCreateWithoutDeviceInput = {
    id?: number
    userId: number
    role: string
  }

  export type DeviceUserCreateOrConnectWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserCreateManyDeviceInputEnvelope = {
    data: DeviceUserCreateManyDeviceInput | DeviceUserCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutRelatedDeviceInput = {
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy: UserCreateNestedOneWithoutCreatedTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutRelatedDeviceInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    createdById: number
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutRelatedDeviceInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutRelatedDeviceInput, SupportTicketUncheckedCreateWithoutRelatedDeviceInput>
  }

  export type SupportTicketCreateManyRelatedDeviceInputEnvelope = {
    data: SupportTicketCreateManyRelatedDeviceInput | SupportTicketCreateManyRelatedDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceUserScalarWhereInput = {
    AND?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
    OR?: DeviceUserScalarWhereInput[]
    NOT?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
    id?: IntFilter<"DeviceUser"> | number
    userId?: IntFilter<"DeviceUser"> | number
    deviceId?: IntFilter<"DeviceUser"> | number
    role?: StringFilter<"DeviceUser"> | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutRelatedDeviceInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutRelatedDeviceInput, SupportTicketUncheckedUpdateWithoutRelatedDeviceInput>
    create: XOR<SupportTicketCreateWithoutRelatedDeviceInput, SupportTicketUncheckedCreateWithoutRelatedDeviceInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutRelatedDeviceInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutRelatedDeviceInput, SupportTicketUncheckedUpdateWithoutRelatedDeviceInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutRelatedDeviceInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutRelatedDeviceInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    assignedToId?: IntNullableFilter<"SupportTicket"> | number | null
    createdById?: IntFilter<"SupportTicket"> | number
    relatedDeviceId?: IntNullableFilter<"SupportTicket"> | number | null
  }

  export type devicesCreateWithoutUsersInput = {
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
    SupportTicket?: SupportTicketCreateNestedManyWithoutRelatedDeviceInput
  }

  export type devicesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutRelatedDeviceInput
  }

  export type devicesCreateOrConnectWithoutUsersInput = {
    where: devicesWhereUniqueInput
    create: XOR<devicesCreateWithoutUsersInput, devicesUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutDevicesInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type devicesUpsertWithoutUsersInput = {
    update: XOR<devicesUpdateWithoutUsersInput, devicesUncheckedUpdateWithoutUsersInput>
    create: XOR<devicesCreateWithoutUsersInput, devicesUncheckedCreateWithoutUsersInput>
    where?: devicesWhereInput
  }

  export type devicesUpdateToOneWithWhereWithoutUsersInput = {
    where?: devicesWhereInput
    data: XOR<devicesUpdateWithoutUsersInput, devicesUncheckedUpdateWithoutUsersInput>
  }

  export type devicesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    SupportTicket?: SupportTicketUpdateManyWithoutRelatedDeviceNestedInput
  }

  export type devicesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutRelatedDeviceNestedInput
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailTemplateCreateWithoutCommandInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutCommandInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleUncheckedCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutCommandInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutCommandInput, EmailTemplateUncheckedCreateWithoutCommandInput>
  }

  export type RuleCreateWithoutCommandsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: CommandMatchCreateNestedManyWithoutRuleInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutRuleInput
    group?: RuleGroupCreateNestedOneWithoutRulesInput
  }

  export type RuleUncheckedCreateWithoutCommandsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupId?: number | null
    emailTemplateId?: number | null
    matches?: CommandMatchUncheckedCreateNestedManyWithoutRuleInput
  }

  export type RuleCreateOrConnectWithoutCommandsInput = {
    where: RuleWhereUniqueInput
    create: XOR<RuleCreateWithoutCommandsInput, RuleUncheckedCreateWithoutCommandsInput>
  }

  export type CommandMatchCreateWithoutCommandInput = {
    logId: number
    logType: string
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    addressedByUser?: UserCreateNestedOneWithoutCommandMatchInput
    rule: RuleCreateNestedOneWithoutMatchesInput
    User?: UserCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchUncheckedCreateWithoutCommandInput = {
    id?: number
    logId: number
    logType: string
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    User?: UserUncheckedCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchCreateOrConnectWithoutCommandInput = {
    where: CommandMatchWhereUniqueInput
    create: XOR<CommandMatchCreateWithoutCommandInput, CommandMatchUncheckedCreateWithoutCommandInput>
  }

  export type CommandMatchCreateManyCommandInputEnvelope = {
    data: CommandMatchCreateManyCommandInput | CommandMatchCreateManyCommandInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateUpsertWithoutCommandInput = {
    update: XOR<EmailTemplateUpdateWithoutCommandInput, EmailTemplateUncheckedUpdateWithoutCommandInput>
    create: XOR<EmailTemplateCreateWithoutCommandInput, EmailTemplateUncheckedCreateWithoutCommandInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutCommandInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutCommandInput, EmailTemplateUncheckedUpdateWithoutCommandInput>
  }

  export type EmailTemplateUpdateWithoutCommandInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutCommandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type RuleUpsertWithoutCommandsInput = {
    update: XOR<RuleUpdateWithoutCommandsInput, RuleUncheckedUpdateWithoutCommandsInput>
    create: XOR<RuleCreateWithoutCommandsInput, RuleUncheckedCreateWithoutCommandsInput>
    where?: RuleWhereInput
  }

  export type RuleUpdateToOneWithWhereWithoutCommandsInput = {
    where?: RuleWhereInput
    data: XOR<RuleUpdateWithoutCommandsInput, RuleUncheckedUpdateWithoutCommandsInput>
  }

  export type RuleUpdateWithoutCommandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: CommandMatchUpdateManyWithoutRuleNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutRuleNestedInput
    group?: RuleGroupUpdateOneWithoutRulesNestedInput
  }

  export type RuleUncheckedUpdateWithoutCommandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    matches?: CommandMatchUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type CommandMatchUpsertWithWhereUniqueWithoutCommandInput = {
    where: CommandMatchWhereUniqueInput
    update: XOR<CommandMatchUpdateWithoutCommandInput, CommandMatchUncheckedUpdateWithoutCommandInput>
    create: XOR<CommandMatchCreateWithoutCommandInput, CommandMatchUncheckedCreateWithoutCommandInput>
  }

  export type CommandMatchUpdateWithWhereUniqueWithoutCommandInput = {
    where: CommandMatchWhereUniqueInput
    data: XOR<CommandMatchUpdateWithoutCommandInput, CommandMatchUncheckedUpdateWithoutCommandInput>
  }

  export type CommandMatchUpdateManyWithWhereWithoutCommandInput = {
    where: CommandMatchScalarWhereInput
    data: XOR<CommandMatchUpdateManyMutationInput, CommandMatchUncheckedUpdateManyWithoutCommandInput>
  }

  export type CommandMatchScalarWhereInput = {
    AND?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
    OR?: CommandMatchScalarWhereInput[]
    NOT?: CommandMatchScalarWhereInput | CommandMatchScalarWhereInput[]
    id?: IntFilter<"CommandMatch"> | number
    logId?: IntFilter<"CommandMatch"> | number
    logType?: StringFilter<"CommandMatch"> | string
    commandId?: IntFilter<"CommandMatch"> | number
    ruleId?: IntFilter<"CommandMatch"> | number
    commandText?: StringFilter<"CommandMatch"> | string
    logEntry?: StringFilter<"CommandMatch"> | string
    timestamp?: DateTimeFilter<"CommandMatch"> | Date | string
    addressed?: BoolFilter<"CommandMatch"> | boolean
    addressedBy?: IntNullableFilter<"CommandMatch"> | number | null
    addressedAt?: DateTimeFilter<"CommandMatch"> | Date | string
    notes?: StringNullableFilter<"CommandMatch"> | string | null
    emailSent?: BoolFilter<"CommandMatch"> | boolean
  }

  export type CommandCreateWithoutRuleInput = {
    command: string
    emailTemplate?: EmailTemplateCreateNestedOneWithoutCommandInput
    matches?: CommandMatchCreateNestedManyWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutRuleInput = {
    id?: number
    command: string
    emailTemplateId?: number | null
    matches?: CommandMatchUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutRuleInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutRuleInput, CommandUncheckedCreateWithoutRuleInput>
  }

  export type CommandCreateManyRuleInputEnvelope = {
    data: CommandCreateManyRuleInput | CommandCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type CommandMatchCreateWithoutRuleInput = {
    logId: number
    logType: string
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    addressedByUser?: UserCreateNestedOneWithoutCommandMatchInput
    command: CommandCreateNestedOneWithoutMatchesInput
    User?: UserCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchUncheckedCreateWithoutRuleInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    User?: UserUncheckedCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchCreateOrConnectWithoutRuleInput = {
    where: CommandMatchWhereUniqueInput
    create: XOR<CommandMatchCreateWithoutRuleInput, CommandMatchUncheckedCreateWithoutRuleInput>
  }

  export type CommandMatchCreateManyRuleInputEnvelope = {
    data: CommandMatchCreateManyRuleInput | CommandMatchCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutRuleInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutRuleInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandUncheckedCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutRuleInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutRuleInput, EmailTemplateUncheckedCreateWithoutRuleInput>
  }

  export type RuleGroupCreateWithoutRulesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplate?: EmailTemplateCreateNestedOneWithoutRuleGroupInput
  }

  export type RuleGroupUncheckedCreateWithoutRulesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: number | null
  }

  export type RuleGroupCreateOrConnectWithoutRulesInput = {
    where: RuleGroupWhereUniqueInput
    create: XOR<RuleGroupCreateWithoutRulesInput, RuleGroupUncheckedCreateWithoutRulesInput>
  }

  export type CommandUpsertWithWhereUniqueWithoutRuleInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutRuleInput, CommandUncheckedUpdateWithoutRuleInput>
    create: XOR<CommandCreateWithoutRuleInput, CommandUncheckedCreateWithoutRuleInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutRuleInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutRuleInput, CommandUncheckedUpdateWithoutRuleInput>
  }

  export type CommandUpdateManyWithWhereWithoutRuleInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutRuleInput>
  }

  export type CommandScalarWhereInput = {
    AND?: CommandScalarWhereInput | CommandScalarWhereInput[]
    OR?: CommandScalarWhereInput[]
    NOT?: CommandScalarWhereInput | CommandScalarWhereInput[]
    id?: IntFilter<"Command"> | number
    ruleId?: IntFilter<"Command"> | number
    command?: StringFilter<"Command"> | string
    emailTemplateId?: IntNullableFilter<"Command"> | number | null
  }

  export type CommandMatchUpsertWithWhereUniqueWithoutRuleInput = {
    where: CommandMatchWhereUniqueInput
    update: XOR<CommandMatchUpdateWithoutRuleInput, CommandMatchUncheckedUpdateWithoutRuleInput>
    create: XOR<CommandMatchCreateWithoutRuleInput, CommandMatchUncheckedCreateWithoutRuleInput>
  }

  export type CommandMatchUpdateWithWhereUniqueWithoutRuleInput = {
    where: CommandMatchWhereUniqueInput
    data: XOR<CommandMatchUpdateWithoutRuleInput, CommandMatchUncheckedUpdateWithoutRuleInput>
  }

  export type CommandMatchUpdateManyWithWhereWithoutRuleInput = {
    where: CommandMatchScalarWhereInput
    data: XOR<CommandMatchUpdateManyMutationInput, CommandMatchUncheckedUpdateManyWithoutRuleInput>
  }

  export type EmailTemplateUpsertWithoutRuleInput = {
    update: XOR<EmailTemplateUpdateWithoutRuleInput, EmailTemplateUncheckedUpdateWithoutRuleInput>
    create: XOR<EmailTemplateCreateWithoutRuleInput, EmailTemplateUncheckedCreateWithoutRuleInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutRuleInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutRuleInput, EmailTemplateUncheckedUpdateWithoutRuleInput>
  }

  export type EmailTemplateUpdateWithoutRuleInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type RuleGroupUpsertWithoutRulesInput = {
    update: XOR<RuleGroupUpdateWithoutRulesInput, RuleGroupUncheckedUpdateWithoutRulesInput>
    create: XOR<RuleGroupCreateWithoutRulesInput, RuleGroupUncheckedCreateWithoutRulesInput>
    where?: RuleGroupWhereInput
  }

  export type RuleGroupUpdateToOneWithWhereWithoutRulesInput = {
    where?: RuleGroupWhereInput
    data: XOR<RuleGroupUpdateWithoutRulesInput, RuleGroupUncheckedUpdateWithoutRulesInput>
  }

  export type RuleGroupUpdateWithoutRulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplate?: EmailTemplateUpdateOneWithoutRuleGroupNestedInput
  }

  export type RuleGroupUncheckedUpdateWithoutRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuleCreateWithoutGroupInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutRuleInput
    matches?: CommandMatchCreateNestedManyWithoutRuleInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutRuleInput
  }

  export type RuleUncheckedCreateWithoutGroupInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: number | null
    commands?: CommandUncheckedCreateNestedManyWithoutRuleInput
    matches?: CommandMatchUncheckedCreateNestedManyWithoutRuleInput
  }

  export type RuleCreateOrConnectWithoutGroupInput = {
    where: RuleWhereUniqueInput
    create: XOR<RuleCreateWithoutGroupInput, RuleUncheckedCreateWithoutGroupInput>
  }

  export type RuleCreateManyGroupInputEnvelope = {
    data: RuleCreateManyGroupInput | RuleCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutRuleGroupInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutRuleGroupInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandUncheckedCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleUncheckedCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutRuleGroupInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutRuleGroupInput, EmailTemplateUncheckedCreateWithoutRuleGroupInput>
  }

  export type RuleUpsertWithWhereUniqueWithoutGroupInput = {
    where: RuleWhereUniqueInput
    update: XOR<RuleUpdateWithoutGroupInput, RuleUncheckedUpdateWithoutGroupInput>
    create: XOR<RuleCreateWithoutGroupInput, RuleUncheckedCreateWithoutGroupInput>
  }

  export type RuleUpdateWithWhereUniqueWithoutGroupInput = {
    where: RuleWhereUniqueInput
    data: XOR<RuleUpdateWithoutGroupInput, RuleUncheckedUpdateWithoutGroupInput>
  }

  export type RuleUpdateManyWithWhereWithoutGroupInput = {
    where: RuleScalarWhereInput
    data: XOR<RuleUpdateManyMutationInput, RuleUncheckedUpdateManyWithoutGroupInput>
  }

  export type RuleScalarWhereInput = {
    AND?: RuleScalarWhereInput | RuleScalarWhereInput[]
    OR?: RuleScalarWhereInput[]
    NOT?: RuleScalarWhereInput | RuleScalarWhereInput[]
    id?: IntFilter<"Rule"> | number
    name?: StringFilter<"Rule"> | string
    description?: StringNullableFilter<"Rule"> | string | null
    createdAt?: DateTimeFilter<"Rule"> | Date | string
    updatedAt?: DateTimeFilter<"Rule"> | Date | string
    groupId?: IntNullableFilter<"Rule"> | number | null
    emailTemplateId?: IntNullableFilter<"Rule"> | number | null
  }

  export type EmailTemplateUpsertWithoutRuleGroupInput = {
    update: XOR<EmailTemplateUpdateWithoutRuleGroupInput, EmailTemplateUncheckedUpdateWithoutRuleGroupInput>
    create: XOR<EmailTemplateCreateWithoutRuleGroupInput, EmailTemplateUncheckedCreateWithoutRuleGroupInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutRuleGroupInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutRuleGroupInput, EmailTemplateUncheckedUpdateWithoutRuleGroupInput>
  }

  export type EmailTemplateUpdateWithoutRuleGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutRuleGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type UserCreateWithoutCommandMatchInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommandMatchInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommandMatchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommandMatchInput, UserUncheckedCreateWithoutCommandMatchInput>
  }

  export type CommandCreateWithoutMatchesInput = {
    command: string
    emailTemplate?: EmailTemplateCreateNestedOneWithoutCommandInput
    rule: RuleCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateWithoutMatchesInput = {
    id?: number
    ruleId: number
    command: string
    emailTemplateId?: number | null
  }

  export type CommandCreateOrConnectWithoutMatchesInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutMatchesInput, CommandUncheckedCreateWithoutMatchesInput>
  }

  export type RuleCreateWithoutMatchesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutRuleInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutRuleInput
    group?: RuleGroupCreateNestedOneWithoutRulesInput
  }

  export type RuleUncheckedCreateWithoutMatchesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupId?: number | null
    emailTemplateId?: number | null
    commands?: CommandUncheckedCreateNestedManyWithoutRuleInput
  }

  export type RuleCreateOrConnectWithoutMatchesInput = {
    where: RuleWhereUniqueInput
    create: XOR<RuleCreateWithoutMatchesInput, RuleUncheckedCreateWithoutMatchesInput>
  }

  export type UserCreateWithoutAddressedMatchesInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressedMatchesInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressedMatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressedMatchesInput, UserUncheckedCreateWithoutAddressedMatchesInput>
  }

  export type UserUpsertWithoutCommandMatchInput = {
    update: XOR<UserUpdateWithoutCommandMatchInput, UserUncheckedUpdateWithoutCommandMatchInput>
    create: XOR<UserCreateWithoutCommandMatchInput, UserUncheckedCreateWithoutCommandMatchInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommandMatchInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommandMatchInput, UserUncheckedUpdateWithoutCommandMatchInput>
  }

  export type UserUpdateWithoutCommandMatchInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommandMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommandUpsertWithoutMatchesInput = {
    update: XOR<CommandUpdateWithoutMatchesInput, CommandUncheckedUpdateWithoutMatchesInput>
    create: XOR<CommandCreateWithoutMatchesInput, CommandUncheckedCreateWithoutMatchesInput>
    where?: CommandWhereInput
  }

  export type CommandUpdateToOneWithWhereWithoutMatchesInput = {
    where?: CommandWhereInput
    data: XOR<CommandUpdateWithoutMatchesInput, CommandUncheckedUpdateWithoutMatchesInput>
  }

  export type CommandUpdateWithoutMatchesInput = {
    command?: StringFieldUpdateOperationsInput | string
    emailTemplate?: EmailTemplateUpdateOneWithoutCommandNestedInput
    rule?: RuleUpdateOneRequiredWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateWithoutMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuleUpsertWithoutMatchesInput = {
    update: XOR<RuleUpdateWithoutMatchesInput, RuleUncheckedUpdateWithoutMatchesInput>
    create: XOR<RuleCreateWithoutMatchesInput, RuleUncheckedCreateWithoutMatchesInput>
    where?: RuleWhereInput
  }

  export type RuleUpdateToOneWithWhereWithoutMatchesInput = {
    where?: RuleWhereInput
    data: XOR<RuleUpdateWithoutMatchesInput, RuleUncheckedUpdateWithoutMatchesInput>
  }

  export type RuleUpdateWithoutMatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutRuleNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutRuleNestedInput
    group?: RuleGroupUpdateOneWithoutRulesNestedInput
  }

  export type RuleUncheckedUpdateWithoutMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    commands?: CommandUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAddressedMatchesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAddressedMatchesInput, UserUncheckedUpdateWithoutAddressedMatchesInput>
    create: XOR<UserCreateWithoutAddressedMatchesInput, UserUncheckedCreateWithoutAddressedMatchesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAddressedMatchesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAddressedMatchesInput, UserUncheckedUpdateWithoutAddressedMatchesInput>
  }

  export type UserUpdateManyWithWhereWithoutAddressedMatchesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAddressedMatchesInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    role?: StringNullableListFilter<"User">
    Mobile?: IntNullableFilter<"User"> | number | null
    PrimaryContact?: StringNullableFilter<"User"> | string | null
    MobileContact?: IntNullableFilter<"User"> | number | null
    Relationship?: StringNullableFilter<"User"> | string | null
    SecondContact?: StringNullableFilter<"User"> | string | null
    SecondMobile?: IntNullableFilter<"User"> | number | null
    SecondRelationship?: StringNullableFilter<"User"> | string | null
    Remarks?: StringNullableFilter<"User"> | string | null
    ndafile?: StringNullableFilter<"User"> | string | null
    ndasubmissiondate?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    location?: StringNullableListFilter<"User">
  }

  export type UserCreateWithoutActivityLogInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
  }

  export type UserUpsertWithoutActivityLogInput = {
    update: XOR<UserUpdateWithoutActivityLogInput, UserUncheckedUpdateWithoutActivityLogInput>
    create: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogInput, UserUncheckedUpdateWithoutActivityLogInput>
  }

  export type UserUpdateWithoutActivityLogInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlertConditionCreateWithoutEmailTemplateInput = {
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    triggeredAlerts?: AlertEventCreateNestedManyWithoutAlertConditionInput
  }

  export type AlertConditionUncheckedCreateWithoutEmailTemplateInput = {
    id?: number
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    triggeredAlerts?: AlertEventUncheckedCreateNestedManyWithoutAlertConditionInput
  }

  export type AlertConditionCreateOrConnectWithoutEmailTemplateInput = {
    where: AlertConditionWhereUniqueInput
    create: XOR<AlertConditionCreateWithoutEmailTemplateInput, AlertConditionUncheckedCreateWithoutEmailTemplateInput>
  }

  export type AlertConditionCreateManyEmailTemplateInputEnvelope = {
    data: AlertConditionCreateManyEmailTemplateInput | AlertConditionCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type CommandCreateWithoutEmailTemplateInput = {
    command: string
    rule: RuleCreateNestedOneWithoutCommandsInput
    matches?: CommandMatchCreateNestedManyWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutEmailTemplateInput = {
    id?: number
    ruleId: number
    command: string
    matches?: CommandMatchUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutEmailTemplateInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutEmailTemplateInput, CommandUncheckedCreateWithoutEmailTemplateInput>
  }

  export type CommandCreateManyEmailTemplateInputEnvelope = {
    data: CommandCreateManyEmailTemplateInput | CommandCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type RuleCreateWithoutEmailTemplateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutRuleInput
    matches?: CommandMatchCreateNestedManyWithoutRuleInput
    group?: RuleGroupCreateNestedOneWithoutRulesInput
  }

  export type RuleUncheckedCreateWithoutEmailTemplateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupId?: number | null
    commands?: CommandUncheckedCreateNestedManyWithoutRuleInput
    matches?: CommandMatchUncheckedCreateNestedManyWithoutRuleInput
  }

  export type RuleCreateOrConnectWithoutEmailTemplateInput = {
    where: RuleWhereUniqueInput
    create: XOR<RuleCreateWithoutEmailTemplateInput, RuleUncheckedCreateWithoutEmailTemplateInput>
  }

  export type RuleCreateManyEmailTemplateInputEnvelope = {
    data: RuleCreateManyEmailTemplateInput | RuleCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type RuleGroupCreateWithoutEmailTemplateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: RuleCreateNestedManyWithoutGroupInput
  }

  export type RuleGroupUncheckedCreateWithoutEmailTemplateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: RuleUncheckedCreateNestedManyWithoutGroupInput
  }

  export type RuleGroupCreateOrConnectWithoutEmailTemplateInput = {
    where: RuleGroupWhereUniqueInput
    create: XOR<RuleGroupCreateWithoutEmailTemplateInput, RuleGroupUncheckedCreateWithoutEmailTemplateInput>
  }

  export type RuleGroupCreateManyEmailTemplateInputEnvelope = {
    data: RuleGroupCreateManyEmailTemplateInput | RuleGroupCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type SavedQueryCreateWithoutEmailTemplateInput = {
    name: string
    description?: string | null
    tableName: string
    columns?: SavedQueryCreatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedQueryUncheckedCreateWithoutEmailTemplateInput = {
    id?: number
    name: string
    description?: string | null
    tableName: string
    columns?: SavedQueryCreatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedQueryCreateOrConnectWithoutEmailTemplateInput = {
    where: SavedQueryWhereUniqueInput
    create: XOR<SavedQueryCreateWithoutEmailTemplateInput, SavedQueryUncheckedCreateWithoutEmailTemplateInput>
  }

  export type SavedQueryCreateManyEmailTemplateInputEnvelope = {
    data: SavedQueryCreateManyEmailTemplateInput | SavedQueryCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserEmailTemplateCreateWithoutEmailTemplateInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailTemplatesInput
  }

  export type UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type UserEmailTemplateCreateOrConnectWithoutEmailTemplateInput = {
    where: UserEmailTemplateWhereUniqueInput
    create: XOR<UserEmailTemplateCreateWithoutEmailTemplateInput, UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput>
  }

  export type UserEmailTemplateCreateManyEmailTemplateInputEnvelope = {
    data: UserEmailTemplateCreateManyEmailTemplateInput | UserEmailTemplateCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type AlertConditionUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: AlertConditionWhereUniqueInput
    update: XOR<AlertConditionUpdateWithoutEmailTemplateInput, AlertConditionUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<AlertConditionCreateWithoutEmailTemplateInput, AlertConditionUncheckedCreateWithoutEmailTemplateInput>
  }

  export type AlertConditionUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: AlertConditionWhereUniqueInput
    data: XOR<AlertConditionUpdateWithoutEmailTemplateInput, AlertConditionUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type AlertConditionUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: AlertConditionScalarWhereInput
    data: XOR<AlertConditionUpdateManyMutationInput, AlertConditionUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type AlertConditionScalarWhereInput = {
    AND?: AlertConditionScalarWhereInput | AlertConditionScalarWhereInput[]
    OR?: AlertConditionScalarWhereInput[]
    NOT?: AlertConditionScalarWhereInput | AlertConditionScalarWhereInput[]
    id?: IntFilter<"AlertCondition"> | number
    name?: StringFilter<"AlertCondition"> | string
    sourceTable?: StringFilter<"AlertCondition"> | string
    fieldName?: StringFilter<"AlertCondition"> | string
    comparator?: StringFilter<"AlertCondition"> | string
    thresholdValue?: StringFilter<"AlertCondition"> | string
    timeWindowMin?: IntNullableFilter<"AlertCondition"> | number | null
    repeatIntervalMin?: IntNullableFilter<"AlertCondition"> | number | null
    countThreshold?: IntNullableFilter<"AlertCondition"> | number | null
    lastTriggeredAt?: DateTimeNullableFilter<"AlertCondition"> | Date | string | null
    active?: BoolFilter<"AlertCondition"> | boolean
    emailTemplateId?: IntNullableFilter<"AlertCondition"> | number | null
  }

  export type CommandUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutEmailTemplateInput, CommandUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<CommandCreateWithoutEmailTemplateInput, CommandUncheckedCreateWithoutEmailTemplateInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutEmailTemplateInput, CommandUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type CommandUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type RuleUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: RuleWhereUniqueInput
    update: XOR<RuleUpdateWithoutEmailTemplateInput, RuleUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<RuleCreateWithoutEmailTemplateInput, RuleUncheckedCreateWithoutEmailTemplateInput>
  }

  export type RuleUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: RuleWhereUniqueInput
    data: XOR<RuleUpdateWithoutEmailTemplateInput, RuleUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type RuleUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: RuleScalarWhereInput
    data: XOR<RuleUpdateManyMutationInput, RuleUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type RuleGroupUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: RuleGroupWhereUniqueInput
    update: XOR<RuleGroupUpdateWithoutEmailTemplateInput, RuleGroupUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<RuleGroupCreateWithoutEmailTemplateInput, RuleGroupUncheckedCreateWithoutEmailTemplateInput>
  }

  export type RuleGroupUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: RuleGroupWhereUniqueInput
    data: XOR<RuleGroupUpdateWithoutEmailTemplateInput, RuleGroupUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type RuleGroupUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: RuleGroupScalarWhereInput
    data: XOR<RuleGroupUpdateManyMutationInput, RuleGroupUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type RuleGroupScalarWhereInput = {
    AND?: RuleGroupScalarWhereInput | RuleGroupScalarWhereInput[]
    OR?: RuleGroupScalarWhereInput[]
    NOT?: RuleGroupScalarWhereInput | RuleGroupScalarWhereInput[]
    id?: IntFilter<"RuleGroup"> | number
    name?: StringFilter<"RuleGroup"> | string
    createdAt?: DateTimeFilter<"RuleGroup"> | Date | string
    updatedAt?: DateTimeFilter<"RuleGroup"> | Date | string
    emailTemplateId?: IntNullableFilter<"RuleGroup"> | number | null
  }

  export type SavedQueryUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: SavedQueryWhereUniqueInput
    update: XOR<SavedQueryUpdateWithoutEmailTemplateInput, SavedQueryUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<SavedQueryCreateWithoutEmailTemplateInput, SavedQueryUncheckedCreateWithoutEmailTemplateInput>
  }

  export type SavedQueryUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: SavedQueryWhereUniqueInput
    data: XOR<SavedQueryUpdateWithoutEmailTemplateInput, SavedQueryUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type SavedQueryUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: SavedQueryScalarWhereInput
    data: XOR<SavedQueryUpdateManyMutationInput, SavedQueryUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type SavedQueryScalarWhereInput = {
    AND?: SavedQueryScalarWhereInput | SavedQueryScalarWhereInput[]
    OR?: SavedQueryScalarWhereInput[]
    NOT?: SavedQueryScalarWhereInput | SavedQueryScalarWhereInput[]
    id?: IntFilter<"SavedQuery"> | number
    name?: StringFilter<"SavedQuery"> | string
    description?: StringNullableFilter<"SavedQuery"> | string | null
    tableName?: StringFilter<"SavedQuery"> | string
    columns?: StringNullableListFilter<"SavedQuery">
    conditions?: JsonNullableFilter<"SavedQuery">
    emailTemplateId?: IntNullableFilter<"SavedQuery"> | number | null
    createdAt?: DateTimeFilter<"SavedQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SavedQuery"> | Date | string
  }

  export type UserEmailTemplateUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: UserEmailTemplateWhereUniqueInput
    update: XOR<UserEmailTemplateUpdateWithoutEmailTemplateInput, UserEmailTemplateUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<UserEmailTemplateCreateWithoutEmailTemplateInput, UserEmailTemplateUncheckedCreateWithoutEmailTemplateInput>
  }

  export type UserEmailTemplateUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: UserEmailTemplateWhereUniqueInput
    data: XOR<UserEmailTemplateUpdateWithoutEmailTemplateInput, UserEmailTemplateUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type UserEmailTemplateUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: UserEmailTemplateScalarWhereInput
    data: XOR<UserEmailTemplateUpdateManyMutationInput, UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type UserEmailTemplateScalarWhereInput = {
    AND?: UserEmailTemplateScalarWhereInput | UserEmailTemplateScalarWhereInput[]
    OR?: UserEmailTemplateScalarWhereInput[]
    NOT?: UserEmailTemplateScalarWhereInput | UserEmailTemplateScalarWhereInput[]
    userId?: IntFilter<"UserEmailTemplate"> | number
    emailTemplateId?: IntFilter<"UserEmailTemplate"> | number
    assignedAt?: DateTimeFilter<"UserEmailTemplate"> | Date | string
  }

  export type ActivityLogCreateWithoutUserInput = {
    actionType: string
    targetType: string
    targetId?: number | null
    details?: string | null
    timestamp?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: number
    actionType: string
    targetType: string
    targetId?: number | null
    details?: string | null
    timestamp?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommandMatchCreateWithoutAddressedByUserInput = {
    logId: number
    logType: string
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    command: CommandCreateNestedOneWithoutMatchesInput
    rule: RuleCreateNestedOneWithoutMatchesInput
    User?: UserCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchUncheckedCreateWithoutAddressedByUserInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    User?: UserUncheckedCreateNestedManyWithoutAddressedMatchesInput
  }

  export type CommandMatchCreateOrConnectWithoutAddressedByUserInput = {
    where: CommandMatchWhereUniqueInput
    create: XOR<CommandMatchCreateWithoutAddressedByUserInput, CommandMatchUncheckedCreateWithoutAddressedByUserInput>
  }

  export type CommandMatchCreateManyAddressedByUserInputEnvelope = {
    data: CommandMatchCreateManyAddressedByUserInput | CommandMatchCreateManyAddressedByUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceUserCreateWithoutUserInput = {
    role: string
    device: devicesCreateNestedOneWithoutUsersInput
  }

  export type DeviceUserUncheckedCreateWithoutUserInput = {
    id?: number
    deviceId: number
    role: string
  }

  export type DeviceUserCreateOrConnectWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput>
  }

  export type DeviceUserCreateManyUserInputEnvelope = {
    data: DeviceUserCreateManyUserInput | DeviceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DriveFileCreateWithoutOwnerInput = {
    name: string
    type: string
    size: number
    order?: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: DriveFolderCreateNestedOneWithoutFilesInput
    permissions?: DriveFilePermissionCreateNestedManyWithoutFileInput
  }

  export type DriveFileUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    folderId?: number | null
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type DriveFileCreateOrConnectWithoutOwnerInput = {
    where: DriveFileWhereUniqueInput
    create: XOR<DriveFileCreateWithoutOwnerInput, DriveFileUncheckedCreateWithoutOwnerInput>
  }

  export type DriveFileCreateManyOwnerInputEnvelope = {
    data: DriveFileCreateManyOwnerInput | DriveFileCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type DriveFilePermissionCreateWithoutGranterInput = {
    access: string
    grantedAt?: Date | string
    file: DriveFileCreateNestedOneWithoutPermissionsInput
    user: UserCreateNestedOneWithoutDriveFilePermissionInput
    User?: UserCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionUncheckedCreateWithoutGranterInput = {
    id?: number
    fileId: number
    userId: number
    access: string
    grantedAt?: Date | string
    User?: UserUncheckedCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionCreateOrConnectWithoutGranterInput = {
    where: DriveFilePermissionWhereUniqueInput
    create: XOR<DriveFilePermissionCreateWithoutGranterInput, DriveFilePermissionUncheckedCreateWithoutGranterInput>
  }

  export type DriveFilePermissionCreateManyGranterInputEnvelope = {
    data: DriveFilePermissionCreateManyGranterInput | DriveFilePermissionCreateManyGranterInput[]
    skipDuplicates?: boolean
  }

  export type DriveFilePermissionCreateWithoutUserInput = {
    access: string
    grantedAt?: Date | string
    file: DriveFileCreateNestedOneWithoutPermissionsInput
    granter: UserCreateNestedOneWithoutGrantedPermissionsInput
    User?: UserCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionUncheckedCreateWithoutUserInput = {
    id?: number
    fileId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
    User?: UserUncheckedCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionCreateOrConnectWithoutUserInput = {
    where: DriveFilePermissionWhereUniqueInput
    create: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput>
  }

  export type DriveFilePermissionCreateManyUserInputEnvelope = {
    data: DriveFilePermissionCreateManyUserInput | DriveFilePermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DriveFolderCreateWithoutOwnerInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileCreateNestedManyWithoutFolderInput
    parent?: DriveFolderCreateNestedOneWithoutChildrenInput
    children?: DriveFolderCreateNestedManyWithoutParentInput
  }

  export type DriveFolderUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileUncheckedCreateNestedManyWithoutFolderInput
    children?: DriveFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type DriveFolderCreateOrConnectWithoutOwnerInput = {
    where: DriveFolderWhereUniqueInput
    create: XOR<DriveFolderCreateWithoutOwnerInput, DriveFolderUncheckedCreateWithoutOwnerInput>
  }

  export type DriveFolderCreateManyOwnerInputEnvelope = {
    data: DriveFolderCreateManyOwnerInput | DriveFolderCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutSenderInput = {
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    recipients?: FeedbackRecipientCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutSenderInput = {
    id?: number
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    recipients?: FeedbackRecipientUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackCreateOrConnectWithoutSenderInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutSenderInput, FeedbackUncheckedCreateWithoutSenderInput>
  }

  export type FeedbackCreateManySenderInputEnvelope = {
    data: FeedbackCreateManySenderInput | FeedbackCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackRecipientCreateWithoutUserInput = {
    feedback: FeedbackCreateNestedOneWithoutRecipientsInput
  }

  export type FeedbackRecipientUncheckedCreateWithoutUserInput = {
    id?: number
    feedbackId: number
  }

  export type FeedbackRecipientCreateOrConnectWithoutUserInput = {
    where: FeedbackRecipientWhereUniqueInput
    create: XOR<FeedbackRecipientCreateWithoutUserInput, FeedbackRecipientUncheckedCreateWithoutUserInput>
  }

  export type FeedbackRecipientCreateManyUserInputEnvelope = {
    data: FeedbackRecipientCreateManyUserInput | FeedbackRecipientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutUserInput = {
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: number
    groupId: number
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    content: string
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
    group: GroupCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: number
    content: string
    groupId: number
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationReadCreateWithoutUserInput = {
    readAt?: Date | string
    notification: NotificationCreateNestedOneWithoutReadsInput
  }

  export type NotificationReadUncheckedCreateWithoutUserInput = {
    id?: number
    notificationId: number
    readAt?: Date | string
  }

  export type NotificationReadCreateOrConnectWithoutUserInput = {
    where: NotificationReadWhereUniqueInput
    create: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput>
  }

  export type NotificationReadCreateManyUserInputEnvelope = {
    data: NotificationReadCreateManyUserInput | NotificationReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectAssignmentCreateWithoutUserInput = {
    role: string
    project: ProjectCreateNestedOneWithoutAssignmentsInput
  }

  export type ProjectAssignmentUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    role: string
  }

  export type ProjectAssignmentCreateOrConnectWithoutUserInput = {
    where: ProjectAssignmentWhereUniqueInput
    create: XOR<ProjectAssignmentCreateWithoutUserInput, ProjectAssignmentUncheckedCreateWithoutUserInput>
  }

  export type ProjectAssignmentCreateManyUserInputEnvelope = {
    data: ProjectAssignmentCreateManyUserInput | ProjectAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutAssignedToInput = {
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTicketsInput
    relatedDevice?: devicesCreateNestedOneWithoutSupportTicketInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    relatedDeviceId?: number | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketCreateManyAssignedToInputEnvelope = {
    data: SupportTicketCreateManyAssignedToInput | SupportTicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutCreatedByInput = {
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    relatedDevice?: devicesCreateNestedOneWithoutSupportTicketInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    relatedDeviceId?: number | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutCreatedByInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutCreatedByInput, SupportTicketUncheckedCreateWithoutCreatedByInput>
  }

  export type SupportTicketCreateManyCreatedByInputEnvelope = {
    data: SupportTicketCreateManyCreatedByInput | SupportTicketCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TeamLeaderCreateWithoutUserInput = {
    team: TeamCreateNestedOneWithoutLeadersInput
  }

  export type TeamLeaderUncheckedCreateWithoutUserInput = {
    id?: number
    teamId: number
  }

  export type TeamLeaderCreateOrConnectWithoutUserInput = {
    where: TeamLeaderWhereUniqueInput
    create: XOR<TeamLeaderCreateWithoutUserInput, TeamLeaderUncheckedCreateWithoutUserInput>
  }

  export type TeamLeaderCreateManyUserInputEnvelope = {
    data: TeamLeaderCreateManyUserInput | TeamLeaderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: number
    teamId: number
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketAttachmentCreateWithoutUploaderInput = {
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    comment?: TicketCommentCreateNestedOneWithoutTicketAttachmentInput
    ticket?: SupportTicketCreateNestedOneWithoutAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateWithoutUploaderInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticketId?: number | null
    commentId?: number | null
  }

  export type TicketAttachmentCreateOrConnectWithoutUploaderInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutUploaderInput, TicketAttachmentUncheckedCreateWithoutUploaderInput>
  }

  export type TicketAttachmentCreateManyUploaderInputEnvelope = {
    data: TicketAttachmentCreateManyUploaderInput | TicketAttachmentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutCommentInput
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId: number
    content: string
    createdAt?: Date | string
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type TicketCommentCreateOrConnectWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentCreateManyUserInputEnvelope = {
    data: TicketCommentCreateManyUserInput | TicketCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserEmailTemplateCreateWithoutUserInput = {
    assignedAt?: Date | string
    emailTemplate: EmailTemplateCreateNestedOneWithoutAssignedUsersInput
  }

  export type UserEmailTemplateUncheckedCreateWithoutUserInput = {
    emailTemplateId: number
    assignedAt?: Date | string
  }

  export type UserEmailTemplateCreateOrConnectWithoutUserInput = {
    where: UserEmailTemplateWhereUniqueInput
    create: XOR<UserEmailTemplateCreateWithoutUserInput, UserEmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type UserEmailTemplateCreateManyUserInputEnvelope = {
    data: UserEmailTemplateCreateManyUserInput | UserEmailTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPermissionCreateWithoutUserInput = {
    pagePermission: PagePermissionCreateNestedOneWithoutAllowedUsersInput
  }

  export type UserPermissionUncheckedCreateWithoutUserInput = {
    id?: number
    pagePermissionId: number
  }

  export type UserPermissionCreateOrConnectWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    create: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionCreateManyUserInputEnvelope = {
    data: UserPermissionCreateManyUserInput | UserPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditStepCreateWithoutAssignedToInput = {
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    dueDate?: Date | string | null
    workflow: AuditWorkflowCreateNestedOneWithoutStepsInput
    logs?: StepLogCreateNestedManyWithoutStepInput
  }

  export type AuditStepUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    dueDate?: Date | string | null
    workflowId: number
    logs?: StepLogUncheckedCreateNestedManyWithoutStepInput
  }

  export type AuditStepCreateOrConnectWithoutAssignedToInput = {
    where: AuditStepWhereUniqueInput
    create: XOR<AuditStepCreateWithoutAssignedToInput, AuditStepUncheckedCreateWithoutAssignedToInput>
  }

  export type AuditStepCreateManyAssignedToInputEnvelope = {
    data: AuditStepCreateManyAssignedToInput | AuditStepCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type DriveFilePermissionCreateWithoutUserInput = {
    access: string
    grantedAt?: Date | string
    file: DriveFileCreateNestedOneWithoutPermissionsInput
    granter: UserCreateNestedOneWithoutGrantedPermissionsInput
    user: UserCreateNestedOneWithoutDriveFilePermissionInput
  }

  export type DriveFilePermissionUncheckedCreateWithoutUserInput = {
    id?: number
    fileId: number
    userId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
  }

  export type CommandMatchCreateWithoutUserInput = {
    logId: number
    logType: string
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
    addressedByUser?: UserCreateNestedOneWithoutCommandMatchInput
    command: CommandCreateNestedOneWithoutMatchesInput
    rule: RuleCreateNestedOneWithoutMatchesInput
  }

  export type CommandMatchUncheckedCreateWithoutUserInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
  }

  export type CommandMatchCreateOrConnectWithoutUserInput = {
    where: CommandMatchWhereUniqueInput
    create: XOR<CommandMatchCreateWithoutUserInput, CommandMatchUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    userId?: IntFilter<"ActivityLog"> | number
    actionType?: StringFilter<"ActivityLog"> | string
    targetType?: StringFilter<"ActivityLog"> | string
    targetId?: IntNullableFilter<"ActivityLog"> | number | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type CommandMatchUpsertWithWhereUniqueWithoutAddressedByUserInput = {
    where: CommandMatchWhereUniqueInput
    update: XOR<CommandMatchUpdateWithoutAddressedByUserInput, CommandMatchUncheckedUpdateWithoutAddressedByUserInput>
    create: XOR<CommandMatchCreateWithoutAddressedByUserInput, CommandMatchUncheckedCreateWithoutAddressedByUserInput>
  }

  export type CommandMatchUpdateWithWhereUniqueWithoutAddressedByUserInput = {
    where: CommandMatchWhereUniqueInput
    data: XOR<CommandMatchUpdateWithoutAddressedByUserInput, CommandMatchUncheckedUpdateWithoutAddressedByUserInput>
  }

  export type CommandMatchUpdateManyWithWhereWithoutAddressedByUserInput = {
    where: CommandMatchScalarWhereInput
    data: XOR<CommandMatchUpdateManyMutationInput, CommandMatchUncheckedUpdateManyWithoutAddressedByUserInput>
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutUserInput, DeviceUserUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutUserInput, DeviceUserUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutUserInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type DriveFileUpsertWithWhereUniqueWithoutOwnerInput = {
    where: DriveFileWhereUniqueInput
    update: XOR<DriveFileUpdateWithoutOwnerInput, DriveFileUncheckedUpdateWithoutOwnerInput>
    create: XOR<DriveFileCreateWithoutOwnerInput, DriveFileUncheckedCreateWithoutOwnerInput>
  }

  export type DriveFileUpdateWithWhereUniqueWithoutOwnerInput = {
    where: DriveFileWhereUniqueInput
    data: XOR<DriveFileUpdateWithoutOwnerInput, DriveFileUncheckedUpdateWithoutOwnerInput>
  }

  export type DriveFileUpdateManyWithWhereWithoutOwnerInput = {
    where: DriveFileScalarWhereInput
    data: XOR<DriveFileUpdateManyMutationInput, DriveFileUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DriveFileScalarWhereInput = {
    AND?: DriveFileScalarWhereInput | DriveFileScalarWhereInput[]
    OR?: DriveFileScalarWhereInput[]
    NOT?: DriveFileScalarWhereInput | DriveFileScalarWhereInput[]
    id?: IntFilter<"DriveFile"> | number
    name?: StringFilter<"DriveFile"> | string
    type?: StringFilter<"DriveFile"> | string
    size?: IntFilter<"DriveFile"> | number
    order?: IntFilter<"DriveFile"> | number
    folderId?: IntNullableFilter<"DriveFile"> | number | null
    ownerId?: IntFilter<"DriveFile"> | number
    url?: StringFilter<"DriveFile"> | string
    createdAt?: DateTimeFilter<"DriveFile"> | Date | string
    updatedAt?: DateTimeFilter<"DriveFile"> | Date | string
  }

  export type DriveFilePermissionUpsertWithWhereUniqueWithoutGranterInput = {
    where: DriveFilePermissionWhereUniqueInput
    update: XOR<DriveFilePermissionUpdateWithoutGranterInput, DriveFilePermissionUncheckedUpdateWithoutGranterInput>
    create: XOR<DriveFilePermissionCreateWithoutGranterInput, DriveFilePermissionUncheckedCreateWithoutGranterInput>
  }

  export type DriveFilePermissionUpdateWithWhereUniqueWithoutGranterInput = {
    where: DriveFilePermissionWhereUniqueInput
    data: XOR<DriveFilePermissionUpdateWithoutGranterInput, DriveFilePermissionUncheckedUpdateWithoutGranterInput>
  }

  export type DriveFilePermissionUpdateManyWithWhereWithoutGranterInput = {
    where: DriveFilePermissionScalarWhereInput
    data: XOR<DriveFilePermissionUpdateManyMutationInput, DriveFilePermissionUncheckedUpdateManyWithoutGranterInput>
  }

  export type DriveFilePermissionScalarWhereInput = {
    AND?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
    OR?: DriveFilePermissionScalarWhereInput[]
    NOT?: DriveFilePermissionScalarWhereInput | DriveFilePermissionScalarWhereInput[]
    id?: IntFilter<"DriveFilePermission"> | number
    fileId?: IntFilter<"DriveFilePermission"> | number
    userId?: IntFilter<"DriveFilePermission"> | number
    access?: StringFilter<"DriveFilePermission"> | string
    grantedBy?: IntFilter<"DriveFilePermission"> | number
    grantedAt?: DateTimeFilter<"DriveFilePermission"> | Date | string
  }

  export type DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: DriveFilePermissionWhereUniqueInput
    update: XOR<DriveFilePermissionUpdateWithoutUserInput, DriveFilePermissionUncheckedUpdateWithoutUserInput>
    create: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput>
  }

  export type DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: DriveFilePermissionWhereUniqueInput
    data: XOR<DriveFilePermissionUpdateWithoutUserInput, DriveFilePermissionUncheckedUpdateWithoutUserInput>
  }

  export type DriveFilePermissionUpdateManyWithWhereWithoutUserInput = {
    where: DriveFilePermissionScalarWhereInput
    data: XOR<DriveFilePermissionUpdateManyMutationInput, DriveFilePermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type DriveFolderUpsertWithWhereUniqueWithoutOwnerInput = {
    where: DriveFolderWhereUniqueInput
    update: XOR<DriveFolderUpdateWithoutOwnerInput, DriveFolderUncheckedUpdateWithoutOwnerInput>
    create: XOR<DriveFolderCreateWithoutOwnerInput, DriveFolderUncheckedCreateWithoutOwnerInput>
  }

  export type DriveFolderUpdateWithWhereUniqueWithoutOwnerInput = {
    where: DriveFolderWhereUniqueInput
    data: XOR<DriveFolderUpdateWithoutOwnerInput, DriveFolderUncheckedUpdateWithoutOwnerInput>
  }

  export type DriveFolderUpdateManyWithWhereWithoutOwnerInput = {
    where: DriveFolderScalarWhereInput
    data: XOR<DriveFolderUpdateManyMutationInput, DriveFolderUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DriveFolderScalarWhereInput = {
    AND?: DriveFolderScalarWhereInput | DriveFolderScalarWhereInput[]
    OR?: DriveFolderScalarWhereInput[]
    NOT?: DriveFolderScalarWhereInput | DriveFolderScalarWhereInput[]
    id?: IntFilter<"DriveFolder"> | number
    name?: StringFilter<"DriveFolder"> | string
    parentId?: IntNullableFilter<"DriveFolder"> | number | null
    ownerId?: IntFilter<"DriveFolder"> | number
    createdAt?: DateTimeFilter<"DriveFolder"> | Date | string
    updatedAt?: DateTimeFilter<"DriveFolder"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutSenderInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutSenderInput, FeedbackUncheckedUpdateWithoutSenderInput>
    create: XOR<FeedbackCreateWithoutSenderInput, FeedbackUncheckedCreateWithoutSenderInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutSenderInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutSenderInput, FeedbackUncheckedUpdateWithoutSenderInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutSenderInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutSenderInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    isRead?: BoolFilter<"Feedback"> | boolean
    senderId?: IntFilter<"Feedback"> | number
  }

  export type FeedbackRecipientUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackRecipientWhereUniqueInput
    update: XOR<FeedbackRecipientUpdateWithoutUserInput, FeedbackRecipientUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackRecipientCreateWithoutUserInput, FeedbackRecipientUncheckedCreateWithoutUserInput>
  }

  export type FeedbackRecipientUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackRecipientWhereUniqueInput
    data: XOR<FeedbackRecipientUpdateWithoutUserInput, FeedbackRecipientUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackRecipientUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackRecipientScalarWhereInput
    data: XOR<FeedbackRecipientUpdateManyMutationInput, FeedbackRecipientUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackRecipientScalarWhereInput = {
    AND?: FeedbackRecipientScalarWhereInput | FeedbackRecipientScalarWhereInput[]
    OR?: FeedbackRecipientScalarWhereInput[]
    NOT?: FeedbackRecipientScalarWhereInput | FeedbackRecipientScalarWhereInput[]
    id?: IntFilter<"FeedbackRecipient"> | number
    feedbackId?: IntFilter<"FeedbackRecipient"> | number
    userId?: IntFilter<"FeedbackRecipient"> | number
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: IntFilter<"GroupMember"> | number
    userId?: IntFilter<"GroupMember"> | number
    groupId?: IntFilter<"GroupMember"> | number
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    content?: StringFilter<"Message"> | string
    senderId?: IntFilter<"Message"> | number
    groupId?: IntFilter<"Message"> | number
    edited?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    fileAttachment?: StringNullableFilter<"Message"> | string | null
    fileOriginalName?: StringNullableFilter<"Message"> | string | null
    fileType?: StringNullableFilter<"Message"> | string | null
  }

  export type NotificationReadUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationReadWhereUniqueInput
    update: XOR<NotificationReadUpdateWithoutUserInput, NotificationReadUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput>
  }

  export type NotificationReadUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationReadWhereUniqueInput
    data: XOR<NotificationReadUpdateWithoutUserInput, NotificationReadUncheckedUpdateWithoutUserInput>
  }

  export type NotificationReadUpdateManyWithWhereWithoutUserInput = {
    where: NotificationReadScalarWhereInput
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationReadScalarWhereInput = {
    AND?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
    OR?: NotificationReadScalarWhereInput[]
    NOT?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
    id?: IntFilter<"NotificationRead"> | number
    notificationId?: IntFilter<"NotificationRead"> | number
    userId?: IntFilter<"NotificationRead"> | number
    readAt?: DateTimeFilter<"NotificationRead"> | Date | string
  }

  export type ProjectAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectAssignmentWhereUniqueInput
    update: XOR<ProjectAssignmentUpdateWithoutUserInput, ProjectAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectAssignmentCreateWithoutUserInput, ProjectAssignmentUncheckedCreateWithoutUserInput>
  }

  export type ProjectAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectAssignmentWhereUniqueInput
    data: XOR<ProjectAssignmentUpdateWithoutUserInput, ProjectAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type ProjectAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: ProjectAssignmentScalarWhereInput
    data: XOR<ProjectAssignmentUpdateManyMutationInput, ProjectAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectAssignmentScalarWhereInput = {
    AND?: ProjectAssignmentScalarWhereInput | ProjectAssignmentScalarWhereInput[]
    OR?: ProjectAssignmentScalarWhereInput[]
    NOT?: ProjectAssignmentScalarWhereInput | ProjectAssignmentScalarWhereInput[]
    id?: IntFilter<"ProjectAssignment"> | number
    userId?: IntFilter<"ProjectAssignment"> | number
    projectId?: IntFilter<"ProjectAssignment"> | number
    role?: StringFilter<"ProjectAssignment"> | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutCreatedByInput, SupportTicketUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SupportTicketCreateWithoutCreatedByInput, SupportTicketUncheckedCreateWithoutCreatedByInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutCreatedByInput, SupportTicketUncheckedUpdateWithoutCreatedByInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutCreatedByInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TeamLeaderUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamLeaderWhereUniqueInput
    update: XOR<TeamLeaderUpdateWithoutUserInput, TeamLeaderUncheckedUpdateWithoutUserInput>
    create: XOR<TeamLeaderCreateWithoutUserInput, TeamLeaderUncheckedCreateWithoutUserInput>
  }

  export type TeamLeaderUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamLeaderWhereUniqueInput
    data: XOR<TeamLeaderUpdateWithoutUserInput, TeamLeaderUncheckedUpdateWithoutUserInput>
  }

  export type TeamLeaderUpdateManyWithWhereWithoutUserInput = {
    where: TeamLeaderScalarWhereInput
    data: XOR<TeamLeaderUpdateManyMutationInput, TeamLeaderUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamLeaderScalarWhereInput = {
    AND?: TeamLeaderScalarWhereInput | TeamLeaderScalarWhereInput[]
    OR?: TeamLeaderScalarWhereInput[]
    NOT?: TeamLeaderScalarWhereInput | TeamLeaderScalarWhereInput[]
    id?: IntFilter<"TeamLeader"> | number
    teamId?: IntFilter<"TeamLeader"> | number
    userId?: IntFilter<"TeamLeader"> | number
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutUploaderInput, TicketAttachmentUncheckedUpdateWithoutUploaderInput>
    create: XOR<TicketAttachmentCreateWithoutUploaderInput, TicketAttachmentUncheckedCreateWithoutUploaderInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutUploaderInput, TicketAttachmentUncheckedUpdateWithoutUploaderInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutUploaderInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type TicketAttachmentScalarWhereInput = {
    AND?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    OR?: TicketAttachmentScalarWhereInput[]
    NOT?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    id?: IntFilter<"TicketAttachment"> | number
    filename?: StringFilter<"TicketAttachment"> | string
    originalFilename?: StringFilter<"TicketAttachment"> | string
    fileSize?: IntFilter<"TicketAttachment"> | number
    mimeType?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: IntNullableFilter<"TicketAttachment"> | number | null
    commentId?: IntNullableFilter<"TicketAttachment"> | number | null
    uploaderId?: IntFilter<"TicketAttachment"> | number
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutUserInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: IntFilter<"TicketComment"> | number
    ticketId?: IntFilter<"TicketComment"> | number
    userId?: IntFilter<"TicketComment"> | number
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
  }

  export type UserEmailTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEmailTemplateWhereUniqueInput
    update: XOR<UserEmailTemplateUpdateWithoutUserInput, UserEmailTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<UserEmailTemplateCreateWithoutUserInput, UserEmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type UserEmailTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEmailTemplateWhereUniqueInput
    data: XOR<UserEmailTemplateUpdateWithoutUserInput, UserEmailTemplateUncheckedUpdateWithoutUserInput>
  }

  export type UserEmailTemplateUpdateManyWithWhereWithoutUserInput = {
    where: UserEmailTemplateScalarWhereInput
    data: XOR<UserEmailTemplateUpdateManyMutationInput, UserEmailTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    update: XOR<UserPermissionUpdateWithoutUserInput, UserPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    data: XOR<UserPermissionUpdateWithoutUserInput, UserPermissionUncheckedUpdateWithoutUserInput>
  }

  export type UserPermissionUpdateManyWithWhereWithoutUserInput = {
    where: UserPermissionScalarWhereInput
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPermissionScalarWhereInput = {
    AND?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
    OR?: UserPermissionScalarWhereInput[]
    NOT?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
    id?: IntFilter<"UserPermission"> | number
    userId?: IntFilter<"UserPermission"> | number
    pagePermissionId?: IntFilter<"UserPermission"> | number
  }

  export type AuditStepUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: AuditStepWhereUniqueInput
    update: XOR<AuditStepUpdateWithoutAssignedToInput, AuditStepUncheckedUpdateWithoutAssignedToInput>
    create: XOR<AuditStepCreateWithoutAssignedToInput, AuditStepUncheckedCreateWithoutAssignedToInput>
  }

  export type AuditStepUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: AuditStepWhereUniqueInput
    data: XOR<AuditStepUpdateWithoutAssignedToInput, AuditStepUncheckedUpdateWithoutAssignedToInput>
  }

  export type AuditStepUpdateManyWithWhereWithoutAssignedToInput = {
    where: AuditStepScalarWhereInput
    data: XOR<AuditStepUpdateManyMutationInput, AuditStepUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type AuditStepScalarWhereInput = {
    AND?: AuditStepScalarWhereInput | AuditStepScalarWhereInput[]
    OR?: AuditStepScalarWhereInput[]
    NOT?: AuditStepScalarWhereInput | AuditStepScalarWhereInput[]
    id?: IntFilter<"AuditStep"> | number
    title?: StringFilter<"AuditStep"> | string
    description?: StringNullableFilter<"AuditStep"> | string | null
    position?: IntFilter<"AuditStep"> | number
    status?: EnumStepStatusFilter<"AuditStep"> | $Enums.StepStatus
    assignedToId?: IntNullableFilter<"AuditStep"> | number | null
    dueDate?: DateTimeNullableFilter<"AuditStep"> | Date | string | null
    workflowId?: IntFilter<"AuditStep"> | number
  }

  export type DriveFilePermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: DriveFilePermissionWhereUniqueInput
    update: XOR<DriveFilePermissionUpdateWithoutUserInput, DriveFilePermissionUncheckedUpdateWithoutUserInput>
    create: XOR<DriveFilePermissionCreateWithoutUserInput, DriveFilePermissionUncheckedCreateWithoutUserInput>
  }

  export type DriveFilePermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: DriveFilePermissionWhereUniqueInput
    data: XOR<DriveFilePermissionUpdateWithoutUserInput, DriveFilePermissionUncheckedUpdateWithoutUserInput>
  }

  export type DriveFilePermissionUpdateManyWithWhereWithoutUserInput = {
    where: DriveFilePermissionScalarWhereInput
    data: XOR<DriveFilePermissionUpdateManyMutationInput, DriveFilePermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type CommandMatchUpsertWithWhereUniqueWithoutUserInput = {
    where: CommandMatchWhereUniqueInput
    update: XOR<CommandMatchUpdateWithoutUserInput, CommandMatchUncheckedUpdateWithoutUserInput>
    create: XOR<CommandMatchCreateWithoutUserInput, CommandMatchUncheckedCreateWithoutUserInput>
  }

  export type CommandMatchUpdateWithWhereUniqueWithoutUserInput = {
    where: CommandMatchWhereUniqueInput
    data: XOR<CommandMatchUpdateWithoutUserInput, CommandMatchUncheckedUpdateWithoutUserInput>
  }

  export type CommandMatchUpdateManyWithWhereWithoutUserInput = {
    where: CommandMatchScalarWhereInput
    data: XOR<CommandMatchUpdateManyMutationInput, CommandMatchUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberCreateWithoutGroupInput = {
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMemberInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: number
    userId: number
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutGroupInput = {
    content: string
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
    sender: UserCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutGroupInput = {
    id?: number
    content: string
    senderId: number
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
  }

  export type MessageCreateOrConnectWithoutGroupInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput>
  }

  export type MessageCreateManyGroupInputEnvelope = {
    data: MessageCreateManyGroupInput | MessageCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutGroupInput, MessageUncheckedUpdateWithoutGroupInput>
    create: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutGroupInput, MessageUncheckedUpdateWithoutGroupInput>
  }

  export type MessageUpdateManyWithWhereWithoutGroupInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupCreateWithoutMembersInput = {
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMemberInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMemberInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMemberInput, UserUncheckedCreateWithoutGroupMemberInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutGroupMemberInput = {
    update: XOR<UserUpdateWithoutGroupMemberInput, UserUncheckedUpdateWithoutGroupMemberInput>
    create: XOR<UserCreateWithoutGroupMemberInput, UserUncheckedCreateWithoutGroupMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMemberInput, UserUncheckedUpdateWithoutGroupMemberInput>
  }

  export type UserUpdateWithoutGroupMemberInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupCreateWithoutMessagesInput = {
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMessagesInput = {
    id?: number
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMessagesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessageInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
  }

  export type GroupUpsertWithoutMessagesInput = {
    update: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type GroupUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutMessageInput = {
    update: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
  }

  export type UserUpdateWithoutMessageInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailTemplateCreateWithoutAssignedUsersInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutAssignedUsersInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandUncheckedCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleUncheckedCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutAssignedUsersInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutAssignedUsersInput, EmailTemplateUncheckedCreateWithoutAssignedUsersInput>
  }

  export type UserCreateWithoutEmailTemplatesInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailTemplatesInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
  }

  export type EmailTemplateUpsertWithoutAssignedUsersInput = {
    update: XOR<EmailTemplateUpdateWithoutAssignedUsersInput, EmailTemplateUncheckedUpdateWithoutAssignedUsersInput>
    create: XOR<EmailTemplateCreateWithoutAssignedUsersInput, EmailTemplateUncheckedCreateWithoutAssignedUsersInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutAssignedUsersInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutAssignedUsersInput, EmailTemplateUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type EmailTemplateUpdateWithoutAssignedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutAssignedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type UserUpsertWithoutEmailTemplatesInput = {
    update: XOR<UserUpdateWithoutEmailTemplatesInput, UserUncheckedUpdateWithoutEmailTemplatesInput>
    create: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailTemplatesInput, UserUncheckedUpdateWithoutEmailTemplatesInput>
  }

  export type UserUpdateWithoutEmailTemplatesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationReadCreateWithoutNotificationInput = {
    readAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationReadInput
  }

  export type NotificationReadUncheckedCreateWithoutNotificationInput = {
    id?: number
    userId: number
    readAt?: Date | string
  }

  export type NotificationReadCreateOrConnectWithoutNotificationInput = {
    where: NotificationReadWhereUniqueInput
    create: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReadCreateManyNotificationInputEnvelope = {
    data: NotificationReadCreateManyNotificationInput | NotificationReadCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationReadUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationReadWhereUniqueInput
    update: XOR<NotificationReadUpdateWithoutNotificationInput, NotificationReadUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReadUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationReadWhereUniqueInput
    data: XOR<NotificationReadUpdateWithoutNotificationInput, NotificationReadUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationReadUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationReadScalarWhereInput
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationCreateWithoutReadsInput = {
    title: string
    content: string
    postDate?: Date | string
    expiryDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    important?: boolean
  }

  export type NotificationUncheckedCreateWithoutReadsInput = {
    id?: number
    title: string
    content: string
    postDate?: Date | string
    expiryDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    important?: boolean
  }

  export type NotificationCreateOrConnectWithoutReadsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
  }

  export type UserCreateWithoutNotificationReadInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationReadInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationReadInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
  }

  export type NotificationUpsertWithoutReadsInput = {
    update: XOR<NotificationUpdateWithoutReadsInput, NotificationUncheckedUpdateWithoutReadsInput>
    create: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutReadsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutReadsInput, NotificationUncheckedUpdateWithoutReadsInput>
  }

  export type NotificationUpdateWithoutReadsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateWithoutReadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutNotificationReadInput = {
    update: XOR<UserUpdateWithoutNotificationReadInput, UserUncheckedUpdateWithoutNotificationReadInput>
    create: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationReadInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationReadInput, UserUncheckedUpdateWithoutNotificationReadInput>
  }

  export type UserUpdateWithoutNotificationReadInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationReadInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailTemplateCreateWithoutSavedQueryInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutSavedQueryInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    AlertCondition?: AlertConditionUncheckedCreateNestedManyWithoutEmailTemplateInput
    Command?: CommandUncheckedCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleUncheckedCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutSavedQueryInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutSavedQueryInput, EmailTemplateUncheckedCreateWithoutSavedQueryInput>
  }

  export type EmailTemplateUpsertWithoutSavedQueryInput = {
    update: XOR<EmailTemplateUpdateWithoutSavedQueryInput, EmailTemplateUncheckedUpdateWithoutSavedQueryInput>
    create: XOR<EmailTemplateCreateWithoutSavedQueryInput, EmailTemplateUncheckedCreateWithoutSavedQueryInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutSavedQueryInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutSavedQueryInput, EmailTemplateUncheckedUpdateWithoutSavedQueryInput>
  }

  export type EmailTemplateUpdateWithoutSavedQueryInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutSavedQueryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AlertCondition?: AlertConditionUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Command?: CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type TicketAttachmentCreateWithoutCommentInput = {
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticket?: SupportTicketCreateNestedOneWithoutAttachmentsInput
    uploader: UserCreateNestedOneWithoutTicketAttachmentInput
  }

  export type TicketAttachmentUncheckedCreateWithoutCommentInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticketId?: number | null
    uploaderId: number
  }

  export type TicketAttachmentCreateOrConnectWithoutCommentInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutCommentInput, TicketAttachmentUncheckedCreateWithoutCommentInput>
  }

  export type TicketAttachmentCreateManyCommentInputEnvelope = {
    data: TicketAttachmentCreateManyCommentInput | TicketAttachmentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutCommentsInput = {
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy: UserCreateNestedOneWithoutCreatedTicketsInput
    relatedDevice?: devicesCreateNestedOneWithoutSupportTicketInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    createdById: number
    relatedDeviceId?: number | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutCommentsInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTicketCommentsInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketCommentsInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutCommentInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutCommentInput, TicketAttachmentUncheckedUpdateWithoutCommentInput>
    create: XOR<TicketAttachmentCreateWithoutCommentInput, TicketAttachmentUncheckedCreateWithoutCommentInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutCommentInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutCommentInput, TicketAttachmentUncheckedUpdateWithoutCommentInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutCommentInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutCommentInput>
  }

  export type SupportTicketUpsertWithoutCommentsInput = {
    update: XOR<SupportTicketUpdateWithoutCommentsInput, SupportTicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutCommentsInput, SupportTicketUncheckedUpdateWithoutCommentsInput>
  }

  export type SupportTicketUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTicketsNestedInput
    relatedDevice?: devicesUpdateOneWithoutSupportTicketNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketCommentsInput = {
    update: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserUpdateWithoutTicketCommentsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutCreatedTicketsInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTicketsInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
  }

  export type devicesCreateWithoutSupportTicketInput = {
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
    users?: DeviceUserCreateNestedManyWithoutDeviceInput
  }

  export type devicesUncheckedCreateWithoutSupportTicketInput = {
    id?: number
    name: string
    ip_address?: string | null
    mac_address?: string | null
    password?: string | null
    time?: Date | string
    notes: string
    status?: string
    users?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type devicesCreateOrConnectWithoutSupportTicketInput = {
    where: devicesWhereUniqueInput
    create: XOR<devicesCreateWithoutSupportTicketInput, devicesUncheckedCreateWithoutSupportTicketInput>
  }

  export type TicketAttachmentCreateWithoutTicketInput = {
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    comment?: TicketCommentCreateNestedOneWithoutTicketAttachmentInput
    uploader: UserCreateNestedOneWithoutTicketAttachmentInput
  }

  export type TicketAttachmentUncheckedCreateWithoutTicketInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    commentId?: number | null
    uploaderId: number
  }

  export type TicketAttachmentCreateOrConnectWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentCreateManyTicketInputEnvelope = {
    data: TicketAttachmentCreateManyTicketInput | TicketAttachmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutTicketInput = {
    content: string
    createdAt?: Date | string
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutCommentInput
    user: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedTicketsInput = {
    update: XOR<UserUpdateWithoutCreatedTicketsInput, UserUncheckedUpdateWithoutCreatedTicketsInput>
    create: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTicketsInput, UserUncheckedUpdateWithoutCreatedTicketsInput>
  }

  export type UserUpdateWithoutCreatedTicketsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type devicesUpsertWithoutSupportTicketInput = {
    update: XOR<devicesUpdateWithoutSupportTicketInput, devicesUncheckedUpdateWithoutSupportTicketInput>
    create: XOR<devicesCreateWithoutSupportTicketInput, devicesUncheckedCreateWithoutSupportTicketInput>
    where?: devicesWhereInput
  }

  export type devicesUpdateToOneWithWhereWithoutSupportTicketInput = {
    where?: devicesWhereInput
    data: XOR<devicesUpdateWithoutSupportTicketInput, devicesUncheckedUpdateWithoutSupportTicketInput>
  }

  export type devicesUpdateWithoutSupportTicketInput = {
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    users?: DeviceUserUpdateManyWithoutDeviceNestedInput
  }

  export type devicesUncheckedUpdateWithoutSupportTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    mac_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    users?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCommentCreateWithoutTicketAttachmentInput = {
    content: string
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketAttachmentInput = {
    id?: number
    ticketId: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutTicketAttachmentInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketAttachmentInput, TicketCommentUncheckedCreateWithoutTicketAttachmentInput>
  }

  export type SupportTicketCreateWithoutAttachmentsInput = {
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy: UserCreateNestedOneWithoutCreatedTicketsInput
    relatedDevice?: devicesCreateNestedOneWithoutSupportTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    createdById: number
    relatedDeviceId?: number | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAttachmentsInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAttachmentsInput, SupportTicketUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutTicketAttachmentInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketAttachmentInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketAttachmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
  }

  export type TicketCommentUpsertWithoutTicketAttachmentInput = {
    update: XOR<TicketCommentUpdateWithoutTicketAttachmentInput, TicketCommentUncheckedUpdateWithoutTicketAttachmentInput>
    create: XOR<TicketCommentCreateWithoutTicketAttachmentInput, TicketCommentUncheckedCreateWithoutTicketAttachmentInput>
    where?: TicketCommentWhereInput
  }

  export type TicketCommentUpdateToOneWithWhereWithoutTicketAttachmentInput = {
    where?: TicketCommentWhereInput
    data: XOR<TicketCommentUpdateWithoutTicketAttachmentInput, TicketCommentUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type TicketCommentUpdateWithoutTicketAttachmentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketAttachmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpsertWithoutAttachmentsInput = {
    update: XOR<SupportTicketUpdateWithoutAttachmentsInput, SupportTicketUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<SupportTicketCreateWithoutAttachmentsInput, SupportTicketUncheckedCreateWithoutAttachmentsInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutAttachmentsInput, SupportTicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type SupportTicketUpdateWithoutAttachmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTicketsNestedInput
    relatedDevice?: devicesUpdateOneWithoutSupportTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketAttachmentInput = {
    update: XOR<UserUpdateWithoutTicketAttachmentInput, UserUncheckedUpdateWithoutTicketAttachmentInput>
    create: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketAttachmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketAttachmentInput, UserUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type UserUpdateWithoutTicketAttachmentInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketAttachmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailTemplateCreateWithoutAlertConditionInput = {
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Command?: CommandCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutAlertConditionInput = {
    id?: number
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Command?: CommandUncheckedCreateNestedManyWithoutEmailTemplateInput
    Rule?: RuleUncheckedCreateNestedManyWithoutEmailTemplateInput
    RuleGroup?: RuleGroupUncheckedCreateNestedManyWithoutEmailTemplateInput
    SavedQuery?: SavedQueryUncheckedCreateNestedManyWithoutEmailTemplateInput
    assignedUsers?: UserEmailTemplateUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutAlertConditionInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutAlertConditionInput, EmailTemplateUncheckedCreateWithoutAlertConditionInput>
  }

  export type AlertEventCreateWithoutAlertConditionInput = {
    triggeredAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    notes?: string | null
  }

  export type AlertEventUncheckedCreateWithoutAlertConditionInput = {
    id?: number
    triggeredAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    notes?: string | null
  }

  export type AlertEventCreateOrConnectWithoutAlertConditionInput = {
    where: AlertEventWhereUniqueInput
    create: XOR<AlertEventCreateWithoutAlertConditionInput, AlertEventUncheckedCreateWithoutAlertConditionInput>
  }

  export type AlertEventCreateManyAlertConditionInputEnvelope = {
    data: AlertEventCreateManyAlertConditionInput | AlertEventCreateManyAlertConditionInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateUpsertWithoutAlertConditionInput = {
    update: XOR<EmailTemplateUpdateWithoutAlertConditionInput, EmailTemplateUncheckedUpdateWithoutAlertConditionInput>
    create: XOR<EmailTemplateCreateWithoutAlertConditionInput, EmailTemplateUncheckedCreateWithoutAlertConditionInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutAlertConditionInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutAlertConditionInput, EmailTemplateUncheckedUpdateWithoutAlertConditionInput>
  }

  export type EmailTemplateUpdateWithoutAlertConditionInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Command?: CommandUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutAlertConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Command?: CommandUncheckedUpdateManyWithoutEmailTemplateNestedInput
    Rule?: RuleUncheckedUpdateManyWithoutEmailTemplateNestedInput
    RuleGroup?: RuleGroupUncheckedUpdateManyWithoutEmailTemplateNestedInput
    SavedQuery?: SavedQueryUncheckedUpdateManyWithoutEmailTemplateNestedInput
    assignedUsers?: UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type AlertEventUpsertWithWhereUniqueWithoutAlertConditionInput = {
    where: AlertEventWhereUniqueInput
    update: XOR<AlertEventUpdateWithoutAlertConditionInput, AlertEventUncheckedUpdateWithoutAlertConditionInput>
    create: XOR<AlertEventCreateWithoutAlertConditionInput, AlertEventUncheckedCreateWithoutAlertConditionInput>
  }

  export type AlertEventUpdateWithWhereUniqueWithoutAlertConditionInput = {
    where: AlertEventWhereUniqueInput
    data: XOR<AlertEventUpdateWithoutAlertConditionInput, AlertEventUncheckedUpdateWithoutAlertConditionInput>
  }

  export type AlertEventUpdateManyWithWhereWithoutAlertConditionInput = {
    where: AlertEventScalarWhereInput
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyWithoutAlertConditionInput>
  }

  export type AlertEventScalarWhereInput = {
    AND?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
    OR?: AlertEventScalarWhereInput[]
    NOT?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
    id?: IntFilter<"AlertEvent"> | number
    conditionId?: IntFilter<"AlertEvent"> | number
    triggeredAt?: DateTimeFilter<"AlertEvent"> | Date | string
    resolved?: BoolFilter<"AlertEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    notes?: StringNullableFilter<"AlertEvent"> | string | null
  }

  export type AlertConditionCreateWithoutTriggeredAlertsInput = {
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    emailTemplate?: EmailTemplateCreateNestedOneWithoutAlertConditionInput
  }

  export type AlertConditionUncheckedCreateWithoutTriggeredAlertsInput = {
    id?: number
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
    emailTemplateId?: number | null
  }

  export type AlertConditionCreateOrConnectWithoutTriggeredAlertsInput = {
    where: AlertConditionWhereUniqueInput
    create: XOR<AlertConditionCreateWithoutTriggeredAlertsInput, AlertConditionUncheckedCreateWithoutTriggeredAlertsInput>
  }

  export type AlertConditionUpsertWithoutTriggeredAlertsInput = {
    update: XOR<AlertConditionUpdateWithoutTriggeredAlertsInput, AlertConditionUncheckedUpdateWithoutTriggeredAlertsInput>
    create: XOR<AlertConditionCreateWithoutTriggeredAlertsInput, AlertConditionUncheckedCreateWithoutTriggeredAlertsInput>
    where?: AlertConditionWhereInput
  }

  export type AlertConditionUpdateToOneWithWhereWithoutTriggeredAlertsInput = {
    where?: AlertConditionWhereInput
    data: XOR<AlertConditionUpdateWithoutTriggeredAlertsInput, AlertConditionUncheckedUpdateWithoutTriggeredAlertsInput>
  }

  export type AlertConditionUpdateWithoutTriggeredAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    emailTemplate?: EmailTemplateUpdateOneWithoutAlertConditionNestedInput
  }

  export type AlertConditionUncheckedUpdateWithoutTriggeredAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutFeedbackInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackRecipientCreateWithoutFeedbackInput = {
    user: UserCreateNestedOneWithoutFeedbackRecipientInput
  }

  export type FeedbackRecipientUncheckedCreateWithoutFeedbackInput = {
    id?: number
    userId: number
  }

  export type FeedbackRecipientCreateOrConnectWithoutFeedbackInput = {
    where: FeedbackRecipientWhereUniqueInput
    create: XOR<FeedbackRecipientCreateWithoutFeedbackInput, FeedbackRecipientUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackRecipientCreateManyFeedbackInputEnvelope = {
    data: FeedbackRecipientCreateManyFeedbackInput | FeedbackRecipientCreateManyFeedbackInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFeedbackInput = {
    update: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateWithoutFeedbackInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackRecipientUpsertWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackRecipientWhereUniqueInput
    update: XOR<FeedbackRecipientUpdateWithoutFeedbackInput, FeedbackRecipientUncheckedUpdateWithoutFeedbackInput>
    create: XOR<FeedbackRecipientCreateWithoutFeedbackInput, FeedbackRecipientUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackRecipientUpdateWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackRecipientWhereUniqueInput
    data: XOR<FeedbackRecipientUpdateWithoutFeedbackInput, FeedbackRecipientUncheckedUpdateWithoutFeedbackInput>
  }

  export type FeedbackRecipientUpdateManyWithWhereWithoutFeedbackInput = {
    where: FeedbackRecipientScalarWhereInput
    data: XOR<FeedbackRecipientUpdateManyMutationInput, FeedbackRecipientUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type FeedbackCreateWithoutRecipientsInput = {
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutRecipientsInput = {
    id?: number
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
    senderId: number
  }

  export type FeedbackCreateOrConnectWithoutRecipientsInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutRecipientsInput, FeedbackUncheckedCreateWithoutRecipientsInput>
  }

  export type UserCreateWithoutFeedbackRecipientInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackRecipientInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackRecipientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackRecipientInput, UserUncheckedCreateWithoutFeedbackRecipientInput>
  }

  export type FeedbackUpsertWithoutRecipientsInput = {
    update: XOR<FeedbackUpdateWithoutRecipientsInput, FeedbackUncheckedUpdateWithoutRecipientsInput>
    create: XOR<FeedbackCreateWithoutRecipientsInput, FeedbackUncheckedCreateWithoutRecipientsInput>
    where?: FeedbackWhereInput
  }

  export type FeedbackUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: FeedbackWhereInput
    data: XOR<FeedbackUpdateWithoutRecipientsInput, FeedbackUncheckedUpdateWithoutRecipientsInput>
  }

  export type FeedbackUpdateWithoutRecipientsInput = {
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutRecipientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutFeedbackRecipientInput = {
    update: XOR<UserUpdateWithoutFeedbackRecipientInput, UserUncheckedUpdateWithoutFeedbackRecipientInput>
    create: XOR<UserCreateWithoutFeedbackRecipientInput, UserUncheckedCreateWithoutFeedbackRecipientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackRecipientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackRecipientInput, UserUncheckedUpdateWithoutFeedbackRecipientInput>
  }

  export type UserUpdateWithoutFeedbackRecipientInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionCreateWithoutPagePermissionInput = {
    roleName: string
  }

  export type RolePermissionUncheckedCreateWithoutPagePermissionInput = {
    id?: number
    roleName: string
  }

  export type RolePermissionCreateOrConnectWithoutPagePermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPagePermissionInput, RolePermissionUncheckedCreateWithoutPagePermissionInput>
  }

  export type RolePermissionCreateManyPagePermissionInputEnvelope = {
    data: RolePermissionCreateManyPagePermissionInput | RolePermissionCreateManyPagePermissionInput[]
    skipDuplicates?: boolean
  }

  export type UserPermissionCreateWithoutPagePermissionInput = {
    user: UserCreateNestedOneWithoutUserPermissionInput
  }

  export type UserPermissionUncheckedCreateWithoutPagePermissionInput = {
    id?: number
    userId: number
  }

  export type UserPermissionCreateOrConnectWithoutPagePermissionInput = {
    where: UserPermissionWhereUniqueInput
    create: XOR<UserPermissionCreateWithoutPagePermissionInput, UserPermissionUncheckedCreateWithoutPagePermissionInput>
  }

  export type UserPermissionCreateManyPagePermissionInputEnvelope = {
    data: UserPermissionCreateManyPagePermissionInput | UserPermissionCreateManyPagePermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPagePermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPagePermissionInput, RolePermissionUncheckedUpdateWithoutPagePermissionInput>
    create: XOR<RolePermissionCreateWithoutPagePermissionInput, RolePermissionUncheckedCreateWithoutPagePermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPagePermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPagePermissionInput, RolePermissionUncheckedUpdateWithoutPagePermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPagePermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPagePermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleName?: StringFilter<"RolePermission"> | string
    pagePermissionId?: IntFilter<"RolePermission"> | number
  }

  export type UserPermissionUpsertWithWhereUniqueWithoutPagePermissionInput = {
    where: UserPermissionWhereUniqueInput
    update: XOR<UserPermissionUpdateWithoutPagePermissionInput, UserPermissionUncheckedUpdateWithoutPagePermissionInput>
    create: XOR<UserPermissionCreateWithoutPagePermissionInput, UserPermissionUncheckedCreateWithoutPagePermissionInput>
  }

  export type UserPermissionUpdateWithWhereUniqueWithoutPagePermissionInput = {
    where: UserPermissionWhereUniqueInput
    data: XOR<UserPermissionUpdateWithoutPagePermissionInput, UserPermissionUncheckedUpdateWithoutPagePermissionInput>
  }

  export type UserPermissionUpdateManyWithWhereWithoutPagePermissionInput = {
    where: UserPermissionScalarWhereInput
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyWithoutPagePermissionInput>
  }

  export type PagePermissionCreateWithoutAllowedRolesInput = {
    route: string
    description?: string | null
    createdAt?: Date | string
    allowedUsers?: UserPermissionCreateNestedManyWithoutPagePermissionInput
  }

  export type PagePermissionUncheckedCreateWithoutAllowedRolesInput = {
    id?: number
    route: string
    description?: string | null
    createdAt?: Date | string
    allowedUsers?: UserPermissionUncheckedCreateNestedManyWithoutPagePermissionInput
  }

  export type PagePermissionCreateOrConnectWithoutAllowedRolesInput = {
    where: PagePermissionWhereUniqueInput
    create: XOR<PagePermissionCreateWithoutAllowedRolesInput, PagePermissionUncheckedCreateWithoutAllowedRolesInput>
  }

  export type PagePermissionUpsertWithoutAllowedRolesInput = {
    update: XOR<PagePermissionUpdateWithoutAllowedRolesInput, PagePermissionUncheckedUpdateWithoutAllowedRolesInput>
    create: XOR<PagePermissionCreateWithoutAllowedRolesInput, PagePermissionUncheckedCreateWithoutAllowedRolesInput>
    where?: PagePermissionWhereInput
  }

  export type PagePermissionUpdateToOneWithWhereWithoutAllowedRolesInput = {
    where?: PagePermissionWhereInput
    data: XOR<PagePermissionUpdateWithoutAllowedRolesInput, PagePermissionUncheckedUpdateWithoutAllowedRolesInput>
  }

  export type PagePermissionUpdateWithoutAllowedRolesInput = {
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowedUsers?: UserPermissionUpdateManyWithoutPagePermissionNestedInput
  }

  export type PagePermissionUncheckedUpdateWithoutAllowedRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowedUsers?: UserPermissionUncheckedUpdateManyWithoutPagePermissionNestedInput
  }

  export type PagePermissionCreateWithoutAllowedUsersInput = {
    route: string
    description?: string | null
    createdAt?: Date | string
    allowedRoles?: RolePermissionCreateNestedManyWithoutPagePermissionInput
  }

  export type PagePermissionUncheckedCreateWithoutAllowedUsersInput = {
    id?: number
    route: string
    description?: string | null
    createdAt?: Date | string
    allowedRoles?: RolePermissionUncheckedCreateNestedManyWithoutPagePermissionInput
  }

  export type PagePermissionCreateOrConnectWithoutAllowedUsersInput = {
    where: PagePermissionWhereUniqueInput
    create: XOR<PagePermissionCreateWithoutAllowedUsersInput, PagePermissionUncheckedCreateWithoutAllowedUsersInput>
  }

  export type UserCreateWithoutUserPermissionInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPermissionInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPermissionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPermissionInput, UserUncheckedCreateWithoutUserPermissionInput>
  }

  export type PagePermissionUpsertWithoutAllowedUsersInput = {
    update: XOR<PagePermissionUpdateWithoutAllowedUsersInput, PagePermissionUncheckedUpdateWithoutAllowedUsersInput>
    create: XOR<PagePermissionCreateWithoutAllowedUsersInput, PagePermissionUncheckedCreateWithoutAllowedUsersInput>
    where?: PagePermissionWhereInput
  }

  export type PagePermissionUpdateToOneWithWhereWithoutAllowedUsersInput = {
    where?: PagePermissionWhereInput
    data: XOR<PagePermissionUpdateWithoutAllowedUsersInput, PagePermissionUncheckedUpdateWithoutAllowedUsersInput>
  }

  export type PagePermissionUpdateWithoutAllowedUsersInput = {
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowedRoles?: RolePermissionUpdateManyWithoutPagePermissionNestedInput
  }

  export type PagePermissionUncheckedUpdateWithoutAllowedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    route?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowedRoles?: RolePermissionUncheckedUpdateManyWithoutPagePermissionNestedInput
  }

  export type UserUpsertWithoutUserPermissionInput = {
    update: XOR<UserUpdateWithoutUserPermissionInput, UserUncheckedUpdateWithoutUserPermissionInput>
    create: XOR<UserCreateWithoutUserPermissionInput, UserUncheckedCreateWithoutUserPermissionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPermissionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPermissionInput, UserUncheckedUpdateWithoutUserPermissionInput>
  }

  export type UserUpdateWithoutUserPermissionInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutProjectTypeInput = {
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    models?: ModelEntryCreateNestedManyWithoutProjectInput
    assignments?: ProjectAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectTypeInput = {
    id?: number
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    models?: ModelEntryUncheckedCreateNestedManyWithoutProjectInput
    assignments?: ProjectAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectTypeInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput>
  }

  export type ProjectCreateManyProjectTypeInputEnvelope = {
    data: ProjectCreateManyProjectTypeInput | ProjectCreateManyProjectTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutProjectTypeInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProjectTypeInput, ProjectUncheckedUpdateWithoutProjectTypeInput>
    create: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProjectTypeInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProjectTypeInput, ProjectUncheckedUpdateWithoutProjectTypeInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProjectTypeInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectTypeInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    businessCode?: StringFilter<"Project"> | string
    projectCode?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    createDate?: DateTimeFilter<"Project"> | Date | string
    projectTypeId?: IntNullableFilter<"Project"> | number | null
  }

  export type ModelEntryCreateWithoutProjectInput = {
    code: string
    description?: string | null
    createDate: Date | string
    createBy: string
    modifyDate?: Date | string | null
    modifyBy?: string | null
  }

  export type ModelEntryUncheckedCreateWithoutProjectInput = {
    id?: number
    code: string
    description?: string | null
    createDate: Date | string
    createBy: string
    modifyDate?: Date | string | null
    modifyBy?: string | null
  }

  export type ModelEntryCreateOrConnectWithoutProjectInput = {
    where: ModelEntryWhereUniqueInput
    create: XOR<ModelEntryCreateWithoutProjectInput, ModelEntryUncheckedCreateWithoutProjectInput>
  }

  export type ModelEntryCreateManyProjectInputEnvelope = {
    data: ModelEntryCreateManyProjectInput | ModelEntryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTypeCreateWithoutProjectsInput = {
    name: string
    description?: string | null
  }

  export type ProjectTypeUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type ProjectTypeCreateOrConnectWithoutProjectsInput = {
    where: ProjectTypeWhereUniqueInput
    create: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectAssignmentCreateWithoutProjectInput = {
    role: string
    user: UserCreateNestedOneWithoutProjectAssignmentInput
  }

  export type ProjectAssignmentUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    role: string
  }

  export type ProjectAssignmentCreateOrConnectWithoutProjectInput = {
    where: ProjectAssignmentWhereUniqueInput
    create: XOR<ProjectAssignmentCreateWithoutProjectInput, ProjectAssignmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectAssignmentCreateManyProjectInputEnvelope = {
    data: ProjectAssignmentCreateManyProjectInput | ProjectAssignmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ModelEntryUpsertWithWhereUniqueWithoutProjectInput = {
    where: ModelEntryWhereUniqueInput
    update: XOR<ModelEntryUpdateWithoutProjectInput, ModelEntryUncheckedUpdateWithoutProjectInput>
    create: XOR<ModelEntryCreateWithoutProjectInput, ModelEntryUncheckedCreateWithoutProjectInput>
  }

  export type ModelEntryUpdateWithWhereUniqueWithoutProjectInput = {
    where: ModelEntryWhereUniqueInput
    data: XOR<ModelEntryUpdateWithoutProjectInput, ModelEntryUncheckedUpdateWithoutProjectInput>
  }

  export type ModelEntryUpdateManyWithWhereWithoutProjectInput = {
    where: ModelEntryScalarWhereInput
    data: XOR<ModelEntryUpdateManyMutationInput, ModelEntryUncheckedUpdateManyWithoutProjectInput>
  }

  export type ModelEntryScalarWhereInput = {
    AND?: ModelEntryScalarWhereInput | ModelEntryScalarWhereInput[]
    OR?: ModelEntryScalarWhereInput[]
    NOT?: ModelEntryScalarWhereInput | ModelEntryScalarWhereInput[]
    id?: IntFilter<"ModelEntry"> | number
    code?: StringFilter<"ModelEntry"> | string
    description?: StringNullableFilter<"ModelEntry"> | string | null
    createDate?: DateTimeFilter<"ModelEntry"> | Date | string
    createBy?: StringFilter<"ModelEntry"> | string
    modifyDate?: DateTimeNullableFilter<"ModelEntry"> | Date | string | null
    modifyBy?: StringNullableFilter<"ModelEntry"> | string | null
    projectId?: IntFilter<"ModelEntry"> | number
  }

  export type ProjectTypeUpsertWithoutProjectsInput = {
    update: XOR<ProjectTypeUpdateWithoutProjectsInput, ProjectTypeUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
    where?: ProjectTypeWhereInput
  }

  export type ProjectTypeUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProjectTypeWhereInput
    data: XOR<ProjectTypeUpdateWithoutProjectsInput, ProjectTypeUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTypeUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectTypeUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectAssignmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectAssignmentWhereUniqueInput
    update: XOR<ProjectAssignmentUpdateWithoutProjectInput, ProjectAssignmentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectAssignmentCreateWithoutProjectInput, ProjectAssignmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectAssignmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectAssignmentWhereUniqueInput
    data: XOR<ProjectAssignmentUpdateWithoutProjectInput, ProjectAssignmentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectAssignmentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectAssignmentScalarWhereInput
    data: XOR<ProjectAssignmentUpdateManyMutationInput, ProjectAssignmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutModelsInput = {
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    assignments?: ProjectAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutModelsInput = {
    id?: number
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    projectTypeId?: number | null
    assignments?: ProjectAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutModelsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutModelsInput, ProjectUncheckedCreateWithoutModelsInput>
  }

  export type ProjectUpsertWithoutModelsInput = {
    update: XOR<ProjectUpdateWithoutModelsInput, ProjectUncheckedUpdateWithoutModelsInput>
    create: XOR<ProjectCreateWithoutModelsInput, ProjectUncheckedCreateWithoutModelsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutModelsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutModelsInput, ProjectUncheckedUpdateWithoutModelsInput>
  }

  export type ProjectUpdateWithoutModelsInput = {
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    assignments?: ProjectAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignments?: ProjectAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutAssignmentsInput = {
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    models?: ModelEntryCreateNestedManyWithoutProjectInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
    projectTypeId?: number | null
    models?: ModelEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAssignmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAssignmentsInput, ProjectUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutProjectAssignmentInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectAssignmentInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectAssignmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectAssignmentInput, UserUncheckedCreateWithoutProjectAssignmentInput>
  }

  export type ProjectUpsertWithoutAssignmentsInput = {
    update: XOR<ProjectUpdateWithoutAssignmentsInput, ProjectUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ProjectCreateWithoutAssignmentsInput, ProjectUncheckedCreateWithoutAssignmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAssignmentsInput, ProjectUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ProjectUpdateWithoutAssignmentsInput = {
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelEntryUpdateManyWithoutProjectNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    models?: ModelEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectAssignmentInput = {
    update: XOR<UserUpdateWithoutProjectAssignmentInput, UserUncheckedUpdateWithoutProjectAssignmentInput>
    create: XOR<UserCreateWithoutProjectAssignmentInput, UserUncheckedCreateWithoutProjectAssignmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectAssignmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectAssignmentInput, UserUncheckedUpdateWithoutProjectAssignmentInput>
  }

  export type UserUpdateWithoutProjectAssignmentInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamLocationCreateWithoutLocationInput = {
    team: TeamCreateNestedOneWithoutLocationsInput
  }

  export type TeamLocationUncheckedCreateWithoutLocationInput = {
    id?: number
    teamId: number
  }

  export type TeamLocationCreateOrConnectWithoutLocationInput = {
    where: TeamLocationWhereUniqueInput
    create: XOR<TeamLocationCreateWithoutLocationInput, TeamLocationUncheckedCreateWithoutLocationInput>
  }

  export type TeamLocationCreateManyLocationInputEnvelope = {
    data: TeamLocationCreateManyLocationInput | TeamLocationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type TeamLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: TeamLocationWhereUniqueInput
    update: XOR<TeamLocationUpdateWithoutLocationInput, TeamLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<TeamLocationCreateWithoutLocationInput, TeamLocationUncheckedCreateWithoutLocationInput>
  }

  export type TeamLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: TeamLocationWhereUniqueInput
    data: XOR<TeamLocationUpdateWithoutLocationInput, TeamLocationUncheckedUpdateWithoutLocationInput>
  }

  export type TeamLocationUpdateManyWithWhereWithoutLocationInput = {
    where: TeamLocationScalarWhereInput
    data: XOR<TeamLocationUpdateManyMutationInput, TeamLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type TeamLocationScalarWhereInput = {
    AND?: TeamLocationScalarWhereInput | TeamLocationScalarWhereInput[]
    OR?: TeamLocationScalarWhereInput[]
    NOT?: TeamLocationScalarWhereInput | TeamLocationScalarWhereInput[]
    id?: IntFilter<"TeamLocation"> | number
    teamId?: IntFilter<"TeamLocation"> | number
    locationId?: IntFilter<"TeamLocation"> | number
  }

  export type DriveFileCreateWithoutFolderInput = {
    name: string
    type: string
    size: number
    order?: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutDriveFileInput
    permissions?: DriveFilePermissionCreateNestedManyWithoutFileInput
  }

  export type DriveFileUncheckedCreateWithoutFolderInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    ownerId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type DriveFileCreateOrConnectWithoutFolderInput = {
    where: DriveFileWhereUniqueInput
    create: XOR<DriveFileCreateWithoutFolderInput, DriveFileUncheckedCreateWithoutFolderInput>
  }

  export type DriveFileCreateManyFolderInputEnvelope = {
    data: DriveFileCreateManyFolderInput | DriveFileCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDriveFolderInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriveFolderInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriveFolderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriveFolderInput, UserUncheckedCreateWithoutDriveFolderInput>
  }

  export type DriveFolderCreateWithoutChildrenInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileCreateNestedManyWithoutFolderInput
    owner: UserCreateNestedOneWithoutDriveFolderInput
    parent?: DriveFolderCreateNestedOneWithoutChildrenInput
  }

  export type DriveFolderUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    parentId?: number | null
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type DriveFolderCreateOrConnectWithoutChildrenInput = {
    where: DriveFolderWhereUniqueInput
    create: XOR<DriveFolderCreateWithoutChildrenInput, DriveFolderUncheckedCreateWithoutChildrenInput>
  }

  export type DriveFolderCreateWithoutParentInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileCreateNestedManyWithoutFolderInput
    owner: UserCreateNestedOneWithoutDriveFolderInput
    children?: DriveFolderCreateNestedManyWithoutParentInput
  }

  export type DriveFolderUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: DriveFileUncheckedCreateNestedManyWithoutFolderInput
    children?: DriveFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type DriveFolderCreateOrConnectWithoutParentInput = {
    where: DriveFolderWhereUniqueInput
    create: XOR<DriveFolderCreateWithoutParentInput, DriveFolderUncheckedCreateWithoutParentInput>
  }

  export type DriveFolderCreateManyParentInputEnvelope = {
    data: DriveFolderCreateManyParentInput | DriveFolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type DriveFileUpsertWithWhereUniqueWithoutFolderInput = {
    where: DriveFileWhereUniqueInput
    update: XOR<DriveFileUpdateWithoutFolderInput, DriveFileUncheckedUpdateWithoutFolderInput>
    create: XOR<DriveFileCreateWithoutFolderInput, DriveFileUncheckedCreateWithoutFolderInput>
  }

  export type DriveFileUpdateWithWhereUniqueWithoutFolderInput = {
    where: DriveFileWhereUniqueInput
    data: XOR<DriveFileUpdateWithoutFolderInput, DriveFileUncheckedUpdateWithoutFolderInput>
  }

  export type DriveFileUpdateManyWithWhereWithoutFolderInput = {
    where: DriveFileScalarWhereInput
    data: XOR<DriveFileUpdateManyMutationInput, DriveFileUncheckedUpdateManyWithoutFolderInput>
  }

  export type UserUpsertWithoutDriveFolderInput = {
    update: XOR<UserUpdateWithoutDriveFolderInput, UserUncheckedUpdateWithoutDriveFolderInput>
    create: XOR<UserCreateWithoutDriveFolderInput, UserUncheckedCreateWithoutDriveFolderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriveFolderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriveFolderInput, UserUncheckedUpdateWithoutDriveFolderInput>
  }

  export type UserUpdateWithoutDriveFolderInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriveFolderInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DriveFolderUpsertWithoutChildrenInput = {
    update: XOR<DriveFolderUpdateWithoutChildrenInput, DriveFolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<DriveFolderCreateWithoutChildrenInput, DriveFolderUncheckedCreateWithoutChildrenInput>
    where?: DriveFolderWhereInput
  }

  export type DriveFolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: DriveFolderWhereInput
    data: XOR<DriveFolderUpdateWithoutChildrenInput, DriveFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type DriveFolderUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUpdateManyWithoutFolderNestedInput
    owner?: UserUpdateOneRequiredWithoutDriveFolderNestedInput
    parent?: DriveFolderUpdateOneWithoutChildrenNestedInput
  }

  export type DriveFolderUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type DriveFolderUpsertWithWhereUniqueWithoutParentInput = {
    where: DriveFolderWhereUniqueInput
    update: XOR<DriveFolderUpdateWithoutParentInput, DriveFolderUncheckedUpdateWithoutParentInput>
    create: XOR<DriveFolderCreateWithoutParentInput, DriveFolderUncheckedCreateWithoutParentInput>
  }

  export type DriveFolderUpdateWithWhereUniqueWithoutParentInput = {
    where: DriveFolderWhereUniqueInput
    data: XOR<DriveFolderUpdateWithoutParentInput, DriveFolderUncheckedUpdateWithoutParentInput>
  }

  export type DriveFolderUpdateManyWithWhereWithoutParentInput = {
    where: DriveFolderScalarWhereInput
    data: XOR<DriveFolderUpdateManyMutationInput, DriveFolderUncheckedUpdateManyWithoutParentInput>
  }

  export type DriveFolderCreateWithoutFilesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutDriveFolderInput
    parent?: DriveFolderCreateNestedOneWithoutChildrenInput
    children?: DriveFolderCreateNestedManyWithoutParentInput
  }

  export type DriveFolderUncheckedCreateWithoutFilesInput = {
    id?: number
    name: string
    parentId?: number | null
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: DriveFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type DriveFolderCreateOrConnectWithoutFilesInput = {
    where: DriveFolderWhereUniqueInput
    create: XOR<DriveFolderCreateWithoutFilesInput, DriveFolderUncheckedCreateWithoutFilesInput>
  }

  export type UserCreateWithoutDriveFileInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriveFileInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriveFileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriveFileInput, UserUncheckedCreateWithoutDriveFileInput>
  }

  export type DriveFilePermissionCreateWithoutFileInput = {
    access: string
    grantedAt?: Date | string
    granter: UserCreateNestedOneWithoutGrantedPermissionsInput
    user: UserCreateNestedOneWithoutDriveFilePermissionInput
    User?: UserCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionUncheckedCreateWithoutFileInput = {
    id?: number
    userId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
    User?: UserUncheckedCreateNestedManyWithoutReceivedPermissionsInput
  }

  export type DriveFilePermissionCreateOrConnectWithoutFileInput = {
    where: DriveFilePermissionWhereUniqueInput
    create: XOR<DriveFilePermissionCreateWithoutFileInput, DriveFilePermissionUncheckedCreateWithoutFileInput>
  }

  export type DriveFilePermissionCreateManyFileInputEnvelope = {
    data: DriveFilePermissionCreateManyFileInput | DriveFilePermissionCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type DriveFolderUpsertWithoutFilesInput = {
    update: XOR<DriveFolderUpdateWithoutFilesInput, DriveFolderUncheckedUpdateWithoutFilesInput>
    create: XOR<DriveFolderCreateWithoutFilesInput, DriveFolderUncheckedCreateWithoutFilesInput>
    where?: DriveFolderWhereInput
  }

  export type DriveFolderUpdateToOneWithWhereWithoutFilesInput = {
    where?: DriveFolderWhereInput
    data: XOR<DriveFolderUpdateWithoutFilesInput, DriveFolderUncheckedUpdateWithoutFilesInput>
  }

  export type DriveFolderUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutDriveFolderNestedInput
    parent?: DriveFolderUpdateOneWithoutChildrenNestedInput
    children?: DriveFolderUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: DriveFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutDriveFileInput = {
    update: XOR<UserUpdateWithoutDriveFileInput, UserUncheckedUpdateWithoutDriveFileInput>
    create: XOR<UserCreateWithoutDriveFileInput, UserUncheckedCreateWithoutDriveFileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriveFileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriveFileInput, UserUncheckedUpdateWithoutDriveFileInput>
  }

  export type UserUpdateWithoutDriveFileInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriveFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DriveFilePermissionUpsertWithWhereUniqueWithoutFileInput = {
    where: DriveFilePermissionWhereUniqueInput
    update: XOR<DriveFilePermissionUpdateWithoutFileInput, DriveFilePermissionUncheckedUpdateWithoutFileInput>
    create: XOR<DriveFilePermissionCreateWithoutFileInput, DriveFilePermissionUncheckedCreateWithoutFileInput>
  }

  export type DriveFilePermissionUpdateWithWhereUniqueWithoutFileInput = {
    where: DriveFilePermissionWhereUniqueInput
    data: XOR<DriveFilePermissionUpdateWithoutFileInput, DriveFilePermissionUncheckedUpdateWithoutFileInput>
  }

  export type DriveFilePermissionUpdateManyWithWhereWithoutFileInput = {
    where: DriveFilePermissionScalarWhereInput
    data: XOR<DriveFilePermissionUpdateManyMutationInput, DriveFilePermissionUncheckedUpdateManyWithoutFileInput>
  }

  export type DriveFileCreateWithoutPermissionsInput = {
    name: string
    type: string
    size: number
    order?: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: DriveFolderCreateNestedOneWithoutFilesInput
    owner: UserCreateNestedOneWithoutDriveFileInput
  }

  export type DriveFileUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    folderId?: number | null
    ownerId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriveFileCreateOrConnectWithoutPermissionsInput = {
    where: DriveFileWhereUniqueInput
    create: XOR<DriveFileCreateWithoutPermissionsInput, DriveFileUncheckedCreateWithoutPermissionsInput>
  }

  export type UserCreateWithoutGrantedPermissionsInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGrantedPermissionsInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGrantedPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
  }

  export type UserCreateWithoutDriveFilePermissionInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriveFilePermissionInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriveFilePermissionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriveFilePermissionInput, UserUncheckedCreateWithoutDriveFilePermissionInput>
  }

  export type UserCreateWithoutReceivedPermissionsInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedPermissionsInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedPermissionsInput, UserUncheckedCreateWithoutReceivedPermissionsInput>
  }

  export type DriveFileUpsertWithoutPermissionsInput = {
    update: XOR<DriveFileUpdateWithoutPermissionsInput, DriveFileUncheckedUpdateWithoutPermissionsInput>
    create: XOR<DriveFileCreateWithoutPermissionsInput, DriveFileUncheckedCreateWithoutPermissionsInput>
    where?: DriveFileWhereInput
  }

  export type DriveFileUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: DriveFileWhereInput
    data: XOR<DriveFileUpdateWithoutPermissionsInput, DriveFileUncheckedUpdateWithoutPermissionsInput>
  }

  export type DriveFileUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: DriveFolderUpdateOneWithoutFilesNestedInput
    owner?: UserUpdateOneRequiredWithoutDriveFileNestedInput
  }

  export type DriveFileUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutGrantedPermissionsInput = {
    update: XOR<UserUpdateWithoutGrantedPermissionsInput, UserUncheckedUpdateWithoutGrantedPermissionsInput>
    create: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGrantedPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGrantedPermissionsInput, UserUncheckedUpdateWithoutGrantedPermissionsInput>
  }

  export type UserUpdateWithoutGrantedPermissionsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGrantedPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDriveFilePermissionInput = {
    update: XOR<UserUpdateWithoutDriveFilePermissionInput, UserUncheckedUpdateWithoutDriveFilePermissionInput>
    create: XOR<UserCreateWithoutDriveFilePermissionInput, UserUncheckedCreateWithoutDriveFilePermissionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriveFilePermissionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriveFilePermissionInput, UserUncheckedUpdateWithoutDriveFilePermissionInput>
  }

  export type UserUpdateWithoutDriveFilePermissionInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriveFilePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReceivedPermissionsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReceivedPermissionsInput, UserUncheckedUpdateWithoutReceivedPermissionsInput>
    create: XOR<UserCreateWithoutReceivedPermissionsInput, UserUncheckedCreateWithoutReceivedPermissionsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReceivedPermissionsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReceivedPermissionsInput, UserUncheckedUpdateWithoutReceivedPermissionsInput>
  }

  export type UserUpdateManyWithWhereWithoutReceivedPermissionsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReceivedPermissionsInput>
  }

  export type TeamLeaderCreateWithoutTeamInput = {
    user: UserCreateNestedOneWithoutTeamLeaderInput
  }

  export type TeamLeaderUncheckedCreateWithoutTeamInput = {
    id?: number
    userId: number
  }

  export type TeamLeaderCreateOrConnectWithoutTeamInput = {
    where: TeamLeaderWhereUniqueInput
    create: XOR<TeamLeaderCreateWithoutTeamInput, TeamLeaderUncheckedCreateWithoutTeamInput>
  }

  export type TeamLeaderCreateManyTeamInputEnvelope = {
    data: TeamLeaderCreateManyTeamInput | TeamLeaderCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamLocationCreateWithoutTeamInput = {
    location: locationCreateNestedOneWithoutTeamLocationInput
  }

  export type TeamLocationUncheckedCreateWithoutTeamInput = {
    id?: number
    locationId: number
  }

  export type TeamLocationCreateOrConnectWithoutTeamInput = {
    where: TeamLocationWhereUniqueInput
    create: XOR<TeamLocationCreateWithoutTeamInput, TeamLocationUncheckedCreateWithoutTeamInput>
  }

  export type TeamLocationCreateManyTeamInputEnvelope = {
    data: TeamLocationCreateManyTeamInput | TeamLocationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutTeamInput = {
    user: UserCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: number
    userId: number
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamLeaderUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamLeaderWhereUniqueInput
    update: XOR<TeamLeaderUpdateWithoutTeamInput, TeamLeaderUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamLeaderCreateWithoutTeamInput, TeamLeaderUncheckedCreateWithoutTeamInput>
  }

  export type TeamLeaderUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamLeaderWhereUniqueInput
    data: XOR<TeamLeaderUpdateWithoutTeamInput, TeamLeaderUncheckedUpdateWithoutTeamInput>
  }

  export type TeamLeaderUpdateManyWithWhereWithoutTeamInput = {
    where: TeamLeaderScalarWhereInput
    data: XOR<TeamLeaderUpdateManyMutationInput, TeamLeaderUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamLocationUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamLocationWhereUniqueInput
    update: XOR<TeamLocationUpdateWithoutTeamInput, TeamLocationUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamLocationCreateWithoutTeamInput, TeamLocationUncheckedCreateWithoutTeamInput>
  }

  export type TeamLocationUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamLocationWhereUniqueInput
    data: XOR<TeamLocationUpdateWithoutTeamInput, TeamLocationUncheckedUpdateWithoutTeamInput>
  }

  export type TeamLocationUpdateManyWithWhereWithoutTeamInput = {
    where: TeamLocationScalarWhereInput
    data: XOR<TeamLocationUpdateManyMutationInput, TeamLocationUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutLeadersInput = {
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: TeamLocationCreateNestedManyWithoutTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutLeadersInput = {
    id?: number
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: TeamLocationUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutLeadersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLeadersInput, TeamUncheckedCreateWithoutLeadersInput>
  }

  export type UserCreateWithoutTeamLeaderInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamLeaderInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamLeaderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamLeaderInput, UserUncheckedCreateWithoutTeamLeaderInput>
  }

  export type TeamUpsertWithoutLeadersInput = {
    update: XOR<TeamUpdateWithoutLeadersInput, TeamUncheckedUpdateWithoutLeadersInput>
    create: XOR<TeamCreateWithoutLeadersInput, TeamUncheckedCreateWithoutLeadersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutLeadersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutLeadersInput, TeamUncheckedUpdateWithoutLeadersInput>
  }

  export type TeamUpdateWithoutLeadersInput = {
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: TeamLocationUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLeadersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: TeamLocationUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamLeaderInput = {
    update: XOR<UserUpdateWithoutTeamLeaderInput, UserUncheckedUpdateWithoutTeamLeaderInput>
    create: XOR<UserCreateWithoutTeamLeaderInput, UserUncheckedCreateWithoutTeamLeaderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamLeaderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamLeaderInput, UserUncheckedUpdateWithoutTeamLeaderInput>
  }

  export type UserUpdateWithoutTeamLeaderInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamLeaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutMembersInput = {
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaders?: TeamLeaderCreateNestedManyWithoutTeamInput
    locations?: TeamLocationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: number
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaders?: TeamLeaderUncheckedCreateNestedManyWithoutTeamInput
    locations?: TeamLocationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMemberInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMemberInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    audit_steps?: AuditStepUncheckedCreateNestedManyWithoutAssignedToInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaders?: TeamLeaderUpdateManyWithoutTeamNestedInput
    locations?: TeamLocationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaders?: TeamLeaderUncheckedUpdateManyWithoutTeamNestedInput
    locations?: TeamLocationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMemberInput = {
    update: XOR<UserUpdateWithoutTeamMemberInput, UserUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMemberInput, UserUncheckedUpdateWithoutTeamMemberInput>
  }

  export type UserUpdateWithoutTeamMemberInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type locationCreateWithoutTeamLocationInput = {
    code: string
    name: string
    modifyBy?: string | null
    createBy: string
    modifyDate?: Date | string
    CCY?: string | null
    Region?: string | null
    Remarks?: string | null
    WCI_URL?: string | null
    createDate?: Date | string
    fullname?: string | null
  }

  export type locationUncheckedCreateWithoutTeamLocationInput = {
    id?: number
    code: string
    name: string
    modifyBy?: string | null
    createBy: string
    modifyDate?: Date | string
    CCY?: string | null
    Region?: string | null
    Remarks?: string | null
    WCI_URL?: string | null
    createDate?: Date | string
    fullname?: string | null
  }

  export type locationCreateOrConnectWithoutTeamLocationInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutTeamLocationInput, locationUncheckedCreateWithoutTeamLocationInput>
  }

  export type TeamCreateWithoutLocationsInput = {
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaders?: TeamLeaderCreateNestedManyWithoutTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutLocationsInput = {
    id?: number
    sequence: number
    remarks: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaders?: TeamLeaderUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutLocationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLocationsInput, TeamUncheckedCreateWithoutLocationsInput>
  }

  export type locationUpsertWithoutTeamLocationInput = {
    update: XOR<locationUpdateWithoutTeamLocationInput, locationUncheckedUpdateWithoutTeamLocationInput>
    create: XOR<locationCreateWithoutTeamLocationInput, locationUncheckedCreateWithoutTeamLocationInput>
    where?: locationWhereInput
  }

  export type locationUpdateToOneWithWhereWithoutTeamLocationInput = {
    where?: locationWhereInput
    data: XOR<locationUpdateWithoutTeamLocationInput, locationUncheckedUpdateWithoutTeamLocationInput>
  }

  export type locationUpdateWithoutTeamLocationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CCY?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    WCI_URL?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationUncheckedUpdateWithoutTeamLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CCY?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    WCI_URL?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamUpsertWithoutLocationsInput = {
    update: XOR<TeamUpdateWithoutLocationsInput, TeamUncheckedUpdateWithoutLocationsInput>
    create: XOR<TeamCreateWithoutLocationsInput, TeamUncheckedCreateWithoutLocationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutLocationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutLocationsInput, TeamUncheckedUpdateWithoutLocationsInput>
  }

  export type TeamUpdateWithoutLocationsInput = {
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaders?: TeamLeaderUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    remarks?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaders?: TeamLeaderUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type AuditStepCreateWithoutWorkflowInput = {
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    dueDate?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAudit_stepsInput
    logs?: StepLogCreateNestedManyWithoutStepInput
  }

  export type AuditStepUncheckedCreateWithoutWorkflowInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    assignedToId?: number | null
    dueDate?: Date | string | null
    logs?: StepLogUncheckedCreateNestedManyWithoutStepInput
  }

  export type AuditStepCreateOrConnectWithoutWorkflowInput = {
    where: AuditStepWhereUniqueInput
    create: XOR<AuditStepCreateWithoutWorkflowInput, AuditStepUncheckedCreateWithoutWorkflowInput>
  }

  export type AuditStepCreateManyWorkflowInputEnvelope = {
    data: AuditStepCreateManyWorkflowInput | AuditStepCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type AuditStepUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: AuditStepWhereUniqueInput
    update: XOR<AuditStepUpdateWithoutWorkflowInput, AuditStepUncheckedUpdateWithoutWorkflowInput>
    create: XOR<AuditStepCreateWithoutWorkflowInput, AuditStepUncheckedCreateWithoutWorkflowInput>
  }

  export type AuditStepUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: AuditStepWhereUniqueInput
    data: XOR<AuditStepUpdateWithoutWorkflowInput, AuditStepUncheckedUpdateWithoutWorkflowInput>
  }

  export type AuditStepUpdateManyWithWhereWithoutWorkflowInput = {
    where: AuditStepScalarWhereInput
    data: XOR<AuditStepUpdateManyMutationInput, AuditStepUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type AuditWorkflowCreateWithoutStepsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditWorkflowUncheckedCreateWithoutStepsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditWorkflowCreateOrConnectWithoutStepsInput = {
    where: AuditWorkflowWhereUniqueInput
    create: XOR<AuditWorkflowCreateWithoutStepsInput, AuditWorkflowUncheckedCreateWithoutStepsInput>
  }

  export type UserCreateWithoutAudit_stepsInput = {
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionCreateNestedManyWithoutUserInput
    receivedPermissions?: DriveFilePermissionCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudit_stepsInput = {
    id?: number
    username?: string | null
    password: string
    email?: string | null
    role?: UserCreateroleInput | string[]
    Mobile?: number | null
    PrimaryContact?: string | null
    MobileContact?: number | null
    Relationship?: string | null
    SecondContact?: string | null
    SecondMobile?: number | null
    SecondRelationship?: string | null
    Remarks?: string | null
    ndafile?: string | null
    ndasubmissiondate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: UserCreatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    CommandMatch?: CommandMatchUncheckedCreateNestedManyWithoutAddressedByUserInput
    devices?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    DriveFile?: DriveFileUncheckedCreateNestedManyWithoutOwnerInput
    grantedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutGranterInput
    DriveFilePermission?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    DriveFolder?: DriveFolderUncheckedCreateNestedManyWithoutOwnerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutSenderInput
    FeedbackRecipient?: FeedbackRecipientUncheckedCreateNestedManyWithoutUserInput
    GroupMember?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    ProjectAssignment?: ProjectAssignmentUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: SupportTicketUncheckedCreateNestedManyWithoutCreatedByInput
    TeamLeader?: TeamLeaderUncheckedCreateNestedManyWithoutUserInput
    TeamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: UserEmailTemplateUncheckedCreateNestedManyWithoutUserInput
    UserPermission?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    receivedPermissions?: DriveFilePermissionUncheckedCreateNestedManyWithoutUserInput
    addressedMatches?: CommandMatchUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudit_stepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudit_stepsInput, UserUncheckedCreateWithoutAudit_stepsInput>
  }

  export type StepLogCreateWithoutStepInput = {
    message: string
    createdBy: string
    createdAt?: Date | string
  }

  export type StepLogUncheckedCreateWithoutStepInput = {
    id?: number
    message: string
    createdBy: string
    createdAt?: Date | string
  }

  export type StepLogCreateOrConnectWithoutStepInput = {
    where: StepLogWhereUniqueInput
    create: XOR<StepLogCreateWithoutStepInput, StepLogUncheckedCreateWithoutStepInput>
  }

  export type StepLogCreateManyStepInputEnvelope = {
    data: StepLogCreateManyStepInput | StepLogCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type AuditWorkflowUpsertWithoutStepsInput = {
    update: XOR<AuditWorkflowUpdateWithoutStepsInput, AuditWorkflowUncheckedUpdateWithoutStepsInput>
    create: XOR<AuditWorkflowCreateWithoutStepsInput, AuditWorkflowUncheckedCreateWithoutStepsInput>
    where?: AuditWorkflowWhereInput
  }

  export type AuditWorkflowUpdateToOneWithWhereWithoutStepsInput = {
    where?: AuditWorkflowWhereInput
    data: XOR<AuditWorkflowUpdateWithoutStepsInput, AuditWorkflowUncheckedUpdateWithoutStepsInput>
  }

  export type AuditWorkflowUpdateWithoutStepsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditWorkflowUncheckedUpdateWithoutStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAudit_stepsInput = {
    update: XOR<UserUpdateWithoutAudit_stepsInput, UserUncheckedUpdateWithoutAudit_stepsInput>
    create: XOR<UserCreateWithoutAudit_stepsInput, UserUncheckedCreateWithoutAudit_stepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudit_stepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudit_stepsInput, UserUncheckedUpdateWithoutAudit_stepsInput>
  }

  export type UserUpdateWithoutAudit_stepsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudit_stepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StepLogUpsertWithWhereUniqueWithoutStepInput = {
    where: StepLogWhereUniqueInput
    update: XOR<StepLogUpdateWithoutStepInput, StepLogUncheckedUpdateWithoutStepInput>
    create: XOR<StepLogCreateWithoutStepInput, StepLogUncheckedCreateWithoutStepInput>
  }

  export type StepLogUpdateWithWhereUniqueWithoutStepInput = {
    where: StepLogWhereUniqueInput
    data: XOR<StepLogUpdateWithoutStepInput, StepLogUncheckedUpdateWithoutStepInput>
  }

  export type StepLogUpdateManyWithWhereWithoutStepInput = {
    where: StepLogScalarWhereInput
    data: XOR<StepLogUpdateManyMutationInput, StepLogUncheckedUpdateManyWithoutStepInput>
  }

  export type StepLogScalarWhereInput = {
    AND?: StepLogScalarWhereInput | StepLogScalarWhereInput[]
    OR?: StepLogScalarWhereInput[]
    NOT?: StepLogScalarWhereInput | StepLogScalarWhereInput[]
    id?: IntFilter<"StepLog"> | number
    stepId?: IntFilter<"StepLog"> | number
    message?: StringFilter<"StepLog"> | string
    createdBy?: StringFilter<"StepLog"> | string
    createdAt?: DateTimeFilter<"StepLog"> | Date | string
  }

  export type AuditStepCreateWithoutLogsInput = {
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    dueDate?: Date | string | null
    workflow: AuditWorkflowCreateNestedOneWithoutStepsInput
    assignedTo?: UserCreateNestedOneWithoutAudit_stepsInput
  }

  export type AuditStepUncheckedCreateWithoutLogsInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    assignedToId?: number | null
    dueDate?: Date | string | null
    workflowId: number
  }

  export type AuditStepCreateOrConnectWithoutLogsInput = {
    where: AuditStepWhereUniqueInput
    create: XOR<AuditStepCreateWithoutLogsInput, AuditStepUncheckedCreateWithoutLogsInput>
  }

  export type AuditStepUpsertWithoutLogsInput = {
    update: XOR<AuditStepUpdateWithoutLogsInput, AuditStepUncheckedUpdateWithoutLogsInput>
    create: XOR<AuditStepCreateWithoutLogsInput, AuditStepUncheckedCreateWithoutLogsInput>
    where?: AuditStepWhereInput
  }

  export type AuditStepUpdateToOneWithWhereWithoutLogsInput = {
    where?: AuditStepWhereInput
    data: XOR<AuditStepUpdateWithoutLogsInput, AuditStepUncheckedUpdateWithoutLogsInput>
  }

  export type AuditStepUpdateWithoutLogsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: AuditWorkflowUpdateOneRequiredWithoutStepsNestedInput
    assignedTo?: UserUpdateOneWithoutAudit_stepsNestedInput
  }

  export type AuditStepUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflowId?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceUserCreateManyDeviceInput = {
    id?: number
    userId: number
    role: string
  }

  export type SupportTicketCreateManyRelatedDeviceInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    createdById: number
  }

  export type DeviceUserUpdateWithoutDeviceInput = {
    role?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUserUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUserUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SupportTicketUpdateWithoutRelatedDeviceInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutRelatedDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutRelatedDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type CommandMatchCreateManyCommandInput = {
    id?: number
    logId: number
    logType: string
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
  }

  export type CommandMatchUpdateWithoutCommandInput = {
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    addressedByUser?: UserUpdateOneWithoutCommandMatchNestedInput
    rule?: RuleUpdateOneRequiredWithoutMatchesNestedInput
    User?: UserUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateWithoutCommandInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateManyWithoutCommandInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandCreateManyRuleInput = {
    id?: number
    command: string
    emailTemplateId?: number | null
  }

  export type CommandMatchCreateManyRuleInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedBy?: number | null
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
  }

  export type CommandUpdateWithoutRuleInput = {
    command?: StringFieldUpdateOperationsInput | string
    emailTemplate?: EmailTemplateUpdateOneWithoutCommandNestedInput
    matches?: CommandMatchUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    matches?: CommandMatchUncheckedUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateManyWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommandMatchUpdateWithoutRuleInput = {
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    addressedByUser?: UserUpdateOneWithoutCommandMatchNestedInput
    command?: CommandUpdateOneRequiredWithoutMatchesNestedInput
    User?: UserUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateManyWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RuleCreateManyGroupInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplateId?: number | null
  }

  export type RuleUpdateWithoutGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutRuleNestedInput
    matches?: CommandMatchUpdateManyWithoutRuleNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutRuleNestedInput
  }

  export type RuleUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    commands?: CommandUncheckedUpdateManyWithoutRuleNestedInput
    matches?: CommandMatchUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type RuleUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutAddressedMatchesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressedMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    receivedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAddressedMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
  }

  export type AlertConditionCreateManyEmailTemplateInput = {
    id?: number
    name: string
    sourceTable: string
    fieldName: string
    comparator: string
    thresholdValue: string
    timeWindowMin?: number | null
    repeatIntervalMin?: number | null
    countThreshold?: number | null
    lastTriggeredAt?: Date | string | null
    active?: boolean
  }

  export type CommandCreateManyEmailTemplateInput = {
    id?: number
    ruleId: number
    command: string
  }

  export type RuleCreateManyEmailTemplateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupId?: number | null
  }

  export type RuleGroupCreateManyEmailTemplateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedQueryCreateManyEmailTemplateInput = {
    id?: number
    name: string
    description?: string | null
    tableName: string
    columns?: SavedQueryCreatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailTemplateCreateManyEmailTemplateInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type AlertConditionUpdateWithoutEmailTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    triggeredAlerts?: AlertEventUpdateManyWithoutAlertConditionNestedInput
  }

  export type AlertConditionUncheckedUpdateWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    triggeredAlerts?: AlertEventUncheckedUpdateManyWithoutAlertConditionNestedInput
  }

  export type AlertConditionUncheckedUpdateManyWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sourceTable?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    comparator?: StringFieldUpdateOperationsInput | string
    thresholdValue?: StringFieldUpdateOperationsInput | string
    timeWindowMin?: NullableIntFieldUpdateOperationsInput | number | null
    repeatIntervalMin?: NullableIntFieldUpdateOperationsInput | number | null
    countThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandUpdateWithoutEmailTemplateInput = {
    command?: StringFieldUpdateOperationsInput | string
    rule?: RuleUpdateOneRequiredWithoutCommandsNestedInput
    matches?: CommandMatchUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    matches?: CommandMatchUncheckedUpdateManyWithoutCommandNestedInput
  }

  export type CommandUncheckedUpdateManyWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
  }

  export type RuleUpdateWithoutEmailTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutRuleNestedInput
    matches?: CommandMatchUpdateManyWithoutRuleNestedInput
    group?: RuleGroupUpdateOneWithoutRulesNestedInput
  }

  export type RuleUncheckedUpdateWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    commands?: CommandUncheckedUpdateManyWithoutRuleNestedInput
    matches?: CommandMatchUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type RuleUncheckedUpdateManyWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuleGroupUpdateWithoutEmailTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: RuleUpdateManyWithoutGroupNestedInput
  }

  export type RuleGroupUncheckedUpdateWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: RuleUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type RuleGroupUncheckedUpdateManyWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedQueryUpdateWithoutEmailTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedQueryUncheckedUpdateWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedQueryUncheckedUpdateManyWithoutEmailTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tableName?: StringFieldUpdateOperationsInput | string
    columns?: SavedQueryUpdatecolumnsInput | string[]
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailTemplateUpdateWithoutEmailTemplateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailTemplatesNestedInput
  }

  export type UserEmailTemplateUncheckedUpdateWithoutEmailTemplateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailTemplateUncheckedUpdateManyWithoutEmailTemplateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: number
    actionType: string
    targetType: string
    targetId?: number | null
    details?: string | null
    timestamp?: Date | string
  }

  export type CommandMatchCreateManyAddressedByUserInput = {
    id?: number
    logId: number
    logType: string
    commandId: number
    ruleId: number
    commandText: string
    logEntry: string
    timestamp?: Date | string
    addressed?: boolean
    addressedAt?: Date | string
    notes?: string | null
    emailSent?: boolean
  }

  export type DeviceUserCreateManyUserInput = {
    id?: number
    deviceId: number
    role: string
  }

  export type DriveFileCreateManyOwnerInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    folderId?: number | null
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriveFilePermissionCreateManyGranterInput = {
    id?: number
    fileId: number
    userId: number
    access: string
    grantedAt?: Date | string
  }

  export type DriveFilePermissionCreateManyUserInput = {
    id?: number
    fileId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
  }

  export type DriveFolderCreateManyOwnerInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManySenderInput = {
    id?: number
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRead?: boolean
  }

  export type FeedbackRecipientCreateManyUserInput = {
    id?: number
    feedbackId: number
  }

  export type GroupMemberCreateManyUserInput = {
    id?: number
    groupId: number
    joinedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: number
    content: string
    groupId: number
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
  }

  export type NotificationReadCreateManyUserInput = {
    id?: number
    notificationId: number
    readAt?: Date | string
  }

  export type ProjectAssignmentCreateManyUserInput = {
    id?: number
    projectId: number
    role: string
  }

  export type SupportTicketCreateManyAssignedToInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    relatedDeviceId?: number | null
  }

  export type SupportTicketCreateManyCreatedByInput = {
    id?: number
    title: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    relatedDeviceId?: number | null
  }

  export type TeamLeaderCreateManyUserInput = {
    id?: number
    teamId: number
  }

  export type TeamMemberCreateManyUserInput = {
    id?: number
    teamId: number
  }

  export type TicketAttachmentCreateManyUploaderInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticketId?: number | null
    commentId?: number | null
  }

  export type TicketCommentCreateManyUserInput = {
    id?: number
    ticketId: number
    content: string
    createdAt?: Date | string
  }

  export type UserEmailTemplateCreateManyUserInput = {
    emailTemplateId: number
    assignedAt?: Date | string
  }

  export type UserPermissionCreateManyUserInput = {
    id?: number
    pagePermissionId: number
  }

  export type AuditStepCreateManyAssignedToInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    dueDate?: Date | string | null
    workflowId: number
  }

  export type ActivityLogUpdateWithoutUserInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandMatchUpdateWithoutAddressedByUserInput = {
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    command?: CommandUpdateOneRequiredWithoutMatchesNestedInput
    rule?: RuleUpdateOneRequiredWithoutMatchesNestedInput
    User?: UserUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateWithoutAddressedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutAddressedMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateManyWithoutAddressedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeviceUserUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    device?: devicesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type DeviceUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DriveFileUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: DriveFolderUpdateOneWithoutFilesNestedInput
    permissions?: DriveFilePermissionUpdateManyWithoutFileNestedInput
  }

  export type DriveFileUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DriveFilePermissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type DriveFileUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFilePermissionUpdateWithoutGranterInput = {
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: DriveFileUpdateOneRequiredWithoutPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutDriveFilePermissionNestedInput
    User?: UserUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateWithoutGranterInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutGranterInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFilePermissionUpdateWithoutUserInput = {
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: DriveFileUpdateOneRequiredWithoutPermissionsNestedInput
    granter?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
    User?: UserUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFolderUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUpdateManyWithoutFolderNestedInput
    parent?: DriveFolderUpdateOneWithoutChildrenNestedInput
    children?: DriveFolderUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUncheckedUpdateManyWithoutFolderNestedInput
    children?: DriveFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutSenderInput = {
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipients?: FeedbackRecipientUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipients?: FeedbackRecipientUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeedbackRecipientUpdateWithoutUserInput = {
    feedback?: FeedbackUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type FeedbackRecipientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackRecipientUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMemberUpdateWithoutUserInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    group?: GroupUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationReadUpdateWithoutUserInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutReadsNestedInput
  }

  export type NotificationReadUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAssignmentUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type ProjectAssignmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SupportTicketUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTicketsNestedInput
    relatedDevice?: devicesUpdateOneWithoutSupportTicketNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SupportTicketUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    relatedDevice?: devicesUpdateOneWithoutSupportTicketNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    relatedDeviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamLeaderUpdateWithoutUserInput = {
    team?: TeamUpdateOneRequiredWithoutLeadersNestedInput
  }

  export type TeamLeaderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLeaderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUpdateWithoutUserInput = {
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentUpdateWithoutUploaderInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: TicketCommentUpdateOneWithoutTicketAttachmentNestedInput
    ticket?: SupportTicketUpdateOneWithoutAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TicketAttachment?: TicketAttachmentUpdateManyWithoutCommentNestedInput
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailTemplateUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplate?: EmailTemplateUpdateOneRequiredWithoutAssignedUsersNestedInput
  }

  export type UserEmailTemplateUncheckedUpdateWithoutUserInput = {
    emailTemplateId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailTemplateUncheckedUpdateManyWithoutUserInput = {
    emailTemplateId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionUpdateWithoutUserInput = {
    pagePermission?: PagePermissionUpdateOneRequiredWithoutAllowedUsersNestedInput
  }

  export type UserPermissionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditStepUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: AuditWorkflowUpdateOneRequiredWithoutStepsNestedInput
    logs?: StepLogUpdateManyWithoutStepNestedInput
  }

  export type AuditStepUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflowId?: IntFieldUpdateOperationsInput | number
    logs?: StepLogUncheckedUpdateManyWithoutStepNestedInput
  }

  export type AuditStepUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflowId?: IntFieldUpdateOperationsInput | number
  }

  export type DriveFilePermissionUpdateWithoutUserInput = {
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: DriveFileUpdateOneRequiredWithoutPermissionsNestedInput
    granter?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutDriveFilePermissionNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandMatchUpdateWithoutUserInput = {
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    addressedByUser?: UserUpdateOneWithoutCommandMatchNestedInput
    command?: CommandUpdateOneRequiredWithoutMatchesNestedInput
    rule?: RuleUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type CommandMatchUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandMatchUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    commandId?: IntFieldUpdateOperationsInput | number
    ruleId?: IntFieldUpdateOperationsInput | number
    commandText?: StringFieldUpdateOperationsInput | string
    logEntry?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    addressed?: BoolFieldUpdateOperationsInput | boolean
    addressedBy?: NullableIntFieldUpdateOperationsInput | number | null
    addressedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: number
    userId: number
    joinedAt?: Date | string
  }

  export type MessageCreateManyGroupInput = {
    id?: number
    content: string
    senderId: number
    edited?: boolean
    createdAt?: Date | string
    fileAttachment?: string | null
    fileOriginalName?: string | null
    fileType?: string | null
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMemberNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutGroupInput = {
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    edited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileAttachment?: NullableStringFieldUpdateOperationsInput | string | null
    fileOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationReadCreateManyNotificationInput = {
    id?: number
    userId: number
    readAt?: Date | string
  }

  export type NotificationReadUpdateWithoutNotificationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationReadNestedInput
  }

  export type NotificationReadUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadUncheckedUpdateManyWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateManyCommentInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticketId?: number | null
    uploaderId: number
  }

  export type TicketAttachmentUpdateWithoutCommentInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneWithoutAttachmentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutTicketAttachmentNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    uploaderId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    uploaderId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentCreateManyTicketInput = {
    id?: number
    filename: string
    originalFilename: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    commentId?: number | null
    uploaderId: number
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUpdateWithoutTicketInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: TicketCommentUpdateOneWithoutTicketAttachmentNestedInput
    uploader?: UserUpdateOneRequiredWithoutTicketAttachmentNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    uploaderId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
    uploaderId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TicketAttachment?: TicketAttachmentUpdateManyWithoutCommentNestedInput
    user?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertEventCreateManyAlertConditionInput = {
    id?: number
    triggeredAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    notes?: string | null
  }

  export type AlertEventUpdateWithoutAlertConditionInput = {
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateWithoutAlertConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateManyWithoutAlertConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackRecipientCreateManyFeedbackInput = {
    id?: number
    userId: number
  }

  export type FeedbackRecipientUpdateWithoutFeedbackInput = {
    user?: UserUpdateOneRequiredWithoutFeedbackRecipientNestedInput
  }

  export type FeedbackRecipientUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackRecipientUncheckedUpdateManyWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionCreateManyPagePermissionInput = {
    id?: number
    roleName: string
  }

  export type UserPermissionCreateManyPagePermissionInput = {
    id?: number
    userId: number
  }

  export type RolePermissionUpdateWithoutPagePermissionInput = {
    roleName?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateWithoutPagePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPagePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
  }

  export type UserPermissionUpdateWithoutPagePermissionInput = {
    user?: UserUpdateOneRequiredWithoutUserPermissionNestedInput
  }

  export type UserPermissionUncheckedUpdateWithoutPagePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionUncheckedUpdateManyWithoutPagePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateManyProjectTypeInput = {
    id?: number
    businessCode: string
    projectCode: string
    name: string
    createDate?: Date | string
  }

  export type ProjectUpdateWithoutProjectTypeInput = {
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelEntryUpdateManyWithoutProjectNestedInput
    assignments?: ProjectAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelEntryUncheckedUpdateManyWithoutProjectNestedInput
    assignments?: ProjectAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessCode?: StringFieldUpdateOperationsInput | string
    projectCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelEntryCreateManyProjectInput = {
    id?: number
    code: string
    description?: string | null
    createDate: Date | string
    createBy: string
    modifyDate?: Date | string | null
    modifyBy?: string | null
  }

  export type ProjectAssignmentCreateManyProjectInput = {
    id?: number
    userId: number
    role: string
  }

  export type ModelEntryUpdateWithoutProjectInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelEntryUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelEntryUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createBy?: StringFieldUpdateOperationsInput | string
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectAssignmentUpdateWithoutProjectInput = {
    role?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProjectAssignmentNestedInput
  }

  export type ProjectAssignmentUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectAssignmentUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
  }

  export type TeamLocationCreateManyLocationInput = {
    id?: number
    teamId: number
  }

  export type TeamLocationUpdateWithoutLocationInput = {
    team?: TeamUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type TeamLocationUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLocationUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type DriveFileCreateManyFolderInput = {
    id?: number
    name: string
    type: string
    size: number
    order?: number
    ownerId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriveFolderCreateManyParentInput = {
    id?: number
    name: string
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriveFileUpdateWithoutFolderInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutDriveFileNestedInput
    permissions?: DriveFilePermissionUpdateManyWithoutFileNestedInput
  }

  export type DriveFileUncheckedUpdateWithoutFolderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DriveFilePermissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type DriveFileUncheckedUpdateManyWithoutFolderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFolderUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUpdateManyWithoutFolderNestedInput
    owner?: UserUpdateOneRequiredWithoutDriveFolderNestedInput
    children?: DriveFolderUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: DriveFileUncheckedUpdateManyWithoutFolderNestedInput
    children?: DriveFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DriveFolderUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriveFilePermissionCreateManyFileInput = {
    id?: number
    userId: number
    access: string
    grantedBy: number
    grantedAt?: Date | string
  }

  export type DriveFilePermissionUpdateWithoutFileInput = {
    access?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    granter?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutDriveFilePermissionNestedInput
    User?: UserUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutReceivedPermissionsNestedInput
  }

  export type DriveFilePermissionUncheckedUpdateManyWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: StringFieldUpdateOperationsInput | string
    grantedBy?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutReceivedPermissionsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUpdateManyWithoutAssignedToNestedInput
    addressedMatches?: CommandMatchUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    CommandMatch?: CommandMatchUncheckedUpdateManyWithoutAddressedByUserNestedInput
    devices?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    DriveFile?: DriveFileUncheckedUpdateManyWithoutOwnerNestedInput
    grantedPermissions?: DriveFilePermissionUncheckedUpdateManyWithoutGranterNestedInput
    DriveFilePermission?: DriveFilePermissionUncheckedUpdateManyWithoutUserNestedInput
    DriveFolder?: DriveFolderUncheckedUpdateManyWithoutOwnerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutSenderNestedInput
    FeedbackRecipient?: FeedbackRecipientUncheckedUpdateManyWithoutUserNestedInput
    GroupMember?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    ProjectAssignment?: ProjectAssignmentUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: SupportTicketUncheckedUpdateManyWithoutCreatedByNestedInput
    TeamLeader?: TeamLeaderUncheckedUpdateManyWithoutUserNestedInput
    TeamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: UserEmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    UserPermission?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    audit_steps?: AuditStepUncheckedUpdateManyWithoutAssignedToNestedInput
    addressedMatches?: CommandMatchUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReceivedPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | string[]
    Mobile?: NullableIntFieldUpdateOperationsInput | number | null
    PrimaryContact?: NullableStringFieldUpdateOperationsInput | string | null
    MobileContact?: NullableIntFieldUpdateOperationsInput | number | null
    Relationship?: NullableStringFieldUpdateOperationsInput | string | null
    SecondContact?: NullableStringFieldUpdateOperationsInput | string | null
    SecondMobile?: NullableIntFieldUpdateOperationsInput | number | null
    SecondRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    Remarks?: NullableStringFieldUpdateOperationsInput | string | null
    ndafile?: NullableStringFieldUpdateOperationsInput | string | null
    ndasubmissiondate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: UserUpdatelocationInput | string[]
  }

  export type TeamLeaderCreateManyTeamInput = {
    id?: number
    userId: number
  }

  export type TeamLocationCreateManyTeamInput = {
    id?: number
    locationId: number
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: number
    userId: number
  }

  export type TeamLeaderUpdateWithoutTeamInput = {
    user?: UserUpdateOneRequiredWithoutTeamLeaderNestedInput
  }

  export type TeamLeaderUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLeaderUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLocationUpdateWithoutTeamInput = {
    location?: locationUpdateOneRequiredWithoutTeamLocationNestedInput
  }

  export type TeamLocationUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamLocationUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    user?: UserUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditStepCreateManyWorkflowInput = {
    id?: number
    title: string
    description?: string | null
    position: number
    status?: $Enums.StepStatus
    assignedToId?: number | null
    dueDate?: Date | string | null
  }

  export type AuditStepUpdateWithoutWorkflowInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAudit_stepsNestedInput
    logs?: StepLogUpdateManyWithoutStepNestedInput
  }

  export type AuditStepUncheckedUpdateWithoutWorkflowInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: StepLogUncheckedUpdateManyWithoutStepNestedInput
  }

  export type AuditStepUncheckedUpdateManyWithoutWorkflowInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StepLogCreateManyStepInput = {
    id?: number
    message: string
    createdBy: string
    createdAt?: Date | string
  }

  export type StepLogUpdateWithoutStepInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepLogUncheckedUpdateWithoutStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepLogUncheckedUpdateManyWithoutStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}